{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"README","text":"<p>探索 Odin Inspector 进阶功能、整合优质资源、优化游戏开发流程</p> <p> </p> <p> </p>","path":["README"],"tags":["readme"]},{"location":"#-重要声明","level":2,"title":"⚠️ 重要声明","text":"<ul> <li><code>Odin Toolkits</code> 是开源的、第三方扩展工具集，主要面向 <code>Odin Inspector and Serializer</code> 的中文用户。</li> <li><code>Odin Toolkits</code> 提供了英文界面解决方案，欢迎贡献完善英文界面。</li> <li>本项目与 Sirenix 公司及官方产品 <code>Odin Inspector and Serializer</code> 无任何隶属、合作关系，并非官方衍生产品。</li> <li>本项目不包含 <code>Odin Inspector and Serializer</code> 的发行版本。</li> <li>本文中的 <code>Odin Inspector</code> 为 <code>Odin Inspector and Serializer</code> 的简称。</li> </ul>","path":["README"],"tags":["readme"]},{"location":"#项目愿景","level":2,"title":"项目愿景","text":"<ul> <li>成为使用 <code>Odin Inspector and Serializer</code> 的开发者的必备扩展工具集</li> </ul>","path":["README"],"tags":["readme"]},{"location":"#主要模块","level":2,"title":"主要模块","text":"<ol> <li><code>Script Doc Generator</code> ：脚本文档生成工具，一键生成 <code>API</code> 文档，也可以自定义文档格式。</li> <li><code>Attribute Overview Pro</code> ：中文特性总览窗口，在官方的 <code>Attribute Overview</code> 内容上进行扩展</li> <li><code>Community</code> ：社区模块，收集、整理、分享使用 <code>Odin Inspector</code> 制作的工具以及推荐其他优质资源</li> <li>原生多语言特性，在构造函数层面直接添加多语言参数。</li> </ol>","path":["README"],"tags":["readme"]},{"location":"#安装","level":2,"title":"安装","text":"","path":["README"],"tags":["readme"]},{"location":"#前提条件","level":3,"title":"前提条件","text":"<ul> <li><code>Unity 2021.3.45f2c1 LTS</code> 或更高版本</li> <li><code>Odin Inspector And Serializer 3.3</code> 或更高版本</li> </ul>","path":["README"],"tags":["readme"]},{"location":"#具体步骤","level":3,"title":"具体步骤","text":"<p><code>Odin Toolkits</code> 依赖 <code>Odin Inspector</code> 插件，请先自行导入 <code>Odin Inspector</code> 插件到项目。</p> <p>从 Unity Global AssetStore 和 Sirenix 官网 上购买 <code>Odin Inspector</code> 或其他方式获取。</p> <ol> <li>确保项目中已安装 <code>Odin Inspector</code></li> <li>下载最新发布包</li> <li>将包导入到 <code>Unity</code> 项目中</li> <li>通过 <code>Tools/Odin Toolkits</code> 菜单访问工具</li> </ol>","path":["README"],"tags":["readme"]},{"location":"#开始使用","level":2,"title":"开始使用","text":"<p>导入后，您可以通过 Unity 编辑器菜单访问 <code>Odin Toolkits</code>：</p> <ul> <li><code>Tools/Odin Toolkits/Getting Started</code> - 开始使用</li> <li><code>Tools/Odin Toolkits/Editor Settings</code> - 配置编辑器偏好设置</li> <li><code>Tools/Odin Toolkits/Runtime Config</code> - 配置运行时设置</li> <li><code>Tools/Odin Toolkits/Script Doc Generator</code> - 脚本文档生成工具</li> <li><code>Tools/Odin Toolkits/Attributes Overview Pro</code> - 中文特性总览</li> <li><code>Tools/Odin Toolkits/Tool Packages</code> - 工具箱</li> <li><code>Tools/Odin Toolkits/Community</code> - 访问社区模块</li> </ul>","path":["README"],"tags":["readme"]},{"location":"#项目结构","level":2,"title":"项目结构","text":"<pre><code>Plugins/\n├─ Yuumix/\n│  ├─ Community/\n│  │  ├─ Editor/\n│  │  ├─ Modules/\n│  ├─ OdinToolkits/\n│  │  ├─ AttributeOverviewPro/\n│  │  ├─ Core/\n│  │  │  ├─ Editor/\n│  │  │  ├─ Resources/\n│  │  │  ├─ Runtime/\n│  │  ├─ Modules/\n│  │  ├─ ScriptDocGenerator/\n│  │  ├─ Tests/\n</code></pre>","path":["README"],"tags":["readme"]},{"location":"#相关链接","level":2,"title":"相关链接","text":"<p>推荐 - Odin Toolkits 文档网站 - GitHub 部署</p> <p>Odin Toolkits 文档网站 - Read the Docs 部署</p> <p>Odin Inspector 官方网站</p> <p>Odin Inspector 许可信息</p>","path":["README"],"tags":["readme"]},{"location":"#许可证","level":2,"title":"许可证","text":"<p>本项目基于 MIT 许可证授权。</p>","path":["README"],"tags":["readme"]},{"location":"#logo-许可证","level":3,"title":"Logo 许可证","text":"<p>查看 <code>LOGO-LICENSE.md</code> 文档。</p>","path":["README"],"tags":["readme"]},{"location":"#更新日志","level":2,"title":"更新日志","text":"<p>详细版本历史和变更请查看项目中的 <code>CHANGELOG.md</code> 或者 Odin Toolkits 文档网站 - GitHub 部署 的 <code>CHANGELOG</code> 章节。</p>","path":["README"],"tags":["readme"]},{"location":"#贡献指南","level":2,"title":"贡献指南","text":"<p>Note</p> <p>暂不推荐，因为目前 API 可能随时改变。查看 <code>CONTRIBUTING.md</code> 文档。</p>","path":["README"],"tags":["readme"]},{"location":"#支持与反馈","level":2,"title":"支持与反馈","text":"<p>zeriying@gmail.com</p> <p>感谢你看到这里，如果 <code>Odin Toolkits</code> 在你的 <code>Unity</code> 开发过程中切实提供了帮助，恳请为项目点亮一颗 ★ Star！</p> <p>如果 <code>Odin Toolkits</code> 打包出现错误，请提 issue，或者联系我，我会尽快处理，业余时间开发，无法即时回复，请优先邮件联系。</p>","path":["README"],"tags":["readme"]},{"location":"#项目及友链推荐","level":2,"title":"项目及友链推荐","text":"<p>QFramework - Unity 开发框架</p> <p>ES Framework - Unity 开发框架</p> <p>Wcowin 的 MkDocs 博客</p> <p>Aaron 的博客</p> <p></p> <p></p>","path":["README"],"tags":["readme"]},{"location":"Artical/CSharp-SOLID/","level":1,"title":"C# SOLID 原则","text":"<p>在 Unity 游戏开发中，随着项目规模的扩大，代码的可维护性、可扩展性和可测试性变得至关重要。SOLID 原则作为面向对象设计的五大基石，为我们提供了构建高质量代码的指导方针。本文将结合 Unity 开发实践和 Odin Inspector 工具，深入探讨如何在 C# 项目中应用这些原则。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#引言为什么需要-solid-原则","level":2,"title":"引言：为什么需要 SOLID 原则？","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#传统-unity-开发中的常见问题","level":3,"title":"传统 Unity 开发中的常见问题","text":"<p>在许多 Unity 项目中，我们经常会遇到以下问题：</p> <ol> <li>神类问题：一个 MonoBehaviour 脚本承担了太多职责</li> <li>修改困难：添加新功能时需要修改大量现有代码</li> <li>测试困难：组件之间耦合度高，难以进行单元测试</li> <li>代码重复：相似的功能在多个地方重复实现</li> </ol> <pre><code>// ❌ 违反多个 SOLID 原则的示例\npublic class PlayerController : MonoBehaviour\n{\n    public float health = 100f;\n    public float speed = 5f;\n    public GameObject bulletPrefab;\n    public AudioSource audioSource;\n\n    void Update()\n    {\n        // 处理移动\n        HandleMovement();\n        // 处理射击\n        HandleShooting();\n        // 处理血量显示\n        UpdateHealthUI();\n        // 处理音效\n        PlaySounds();\n        // 处理动画\n        UpdateAnimations();\n    }\n\n    // ... 大量混杂的功能代码\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#solid-原则如何解决这些问题","level":3,"title":"SOLID 原则如何解决这些问题","text":"<p>SOLID 原则通过以下方式改善代码质量：</p> <ul> <li>职责分离：每个类只负责一个特定的功能</li> <li>扩展友好：新功能可以通过扩展而非修改现有代码来实现</li> <li>接口规范：通过抽象和接口降低模块间的耦合</li> <li>依赖管理：高层模块不直接依赖低层实现细节</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#solid-原则概览","level":2,"title":"SOLID 原则概览","text":"<p>SOLID 是五个设计原则的首字母缩写：</p> 原则 英文名称 中文名称 核心理念 S Single Responsibility Principle 单一职责原则 一个类应该只有一个引起它变化的原因 O Open-Closed Principle 开闭原则 软件实体应对扩展开放，对修改封闭 L Liskov Substitution Principle 里氏替换原则 子类对象必须能够替换基类对象 I Interface Segregation Principle 接口隔离原则 不应强迫客户依赖于它们不使用的接口 D Dependency Inversion Principle 依赖倒置原则 高层模块不应依赖低层模块，都应依赖抽象 <p>这些原则相互补充，共同构建了一个健壮的软件架构基础。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#s---单一职责原则-single-responsibility-principle","level":2,"title":"S - 单一职责原则 (Single Responsibility Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#原理阐述","level":3,"title":"原理阐述","text":"<p>单一职责原则是 SOLID 原则中最基础也是最重要的一个。它的核心思想是：一个类应该只有一个引起它变化的原因。换句话说，一个类应该只承担一种职责。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#违反-srp-的问题示例","level":3,"title":"违反 SRP 的问题示例","text":"<p>让我们看一个典型的违反 SRP 的 Unity 脚本：</p> <pre><code>// ❌ 违反单一职责原则的示例\npublic class BadPlayerController : MonoBehaviour\n{\n    [Header(\"健康系统\")]\n    public float maxHealth = 100f;\n    private float currentHealth;\n\n    [Header(\"移动系统\")]\n    public float moveSpeed = 5f;\n    private Rigidbody2D rb;\n\n    [Header(\"武器系统\")]\n    public GameObject bulletPrefab;\n    public Transform firePoint;\n    public float fireRate = 0.5f;\n    private float nextFireTime;\n\n    [Header(\"音效系统\")]\n    public AudioClip shootSound;\n    public AudioClip hurtSound;\n    private AudioSource audioSource;\n\n    [Header(\"UI 显示\")]\n    public Slider healthBar;\n    public Text healthText;\n\n    void Start()\n    {\n        currentHealth = maxHealth;\n        rb = GetComponent&lt;Rigidbody2D&gt;();\n        audioSource = GetComponent&lt;AudioSource&gt;();\n    }\n\n    void Update()\n    {\n        HandleMovement();   // 移动职责\n        HandleShooting();   // 射击职责\n        UpdateHealthUI();   // UI 更新职责\n        CheckHealthStatus(); // 健康状态检查职责\n    }\n\n    // 移动相关代码\n    void HandleMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        Vector2 movement = new Vector2(horizontal, vertical);\n        rb.velocity = movement * moveSpeed;\n    }\n\n    // 射击相关代码\n    void HandleShooting()\n    {\n        if (Input.GetButton(\"Fire1\") &amp;&amp; Time.time &gt;= nextFireTime)\n        {\n            Shoot();\n            nextFireTime = Time.time + fireRate;\n        }\n    }\n\n    void Shoot()\n    {\n        Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        audioSource.PlayOneShot(shootSound);\n    }\n\n    // 健康系统相关代码\n    public void TakeDamage(float damage)\n    {\n        currentHealth -= damage;\n        audioSource.PlayOneShot(hurtSound);\n        UpdateHealthUI();\n\n        if (currentHealth &lt;= 0)\n        {\n            Die();\n        }\n    }\n\n    void Die()\n    {\n        // 死亡逻辑\n        gameObject.SetActive(false);\n    }\n\n    // UI 更新相关代码\n    void UpdateHealthUI()\n    {\n        if (healthBar != null)\n            healthBar.value = currentHealth / maxHealth;\n        if (healthText != null)\n            healthText.text = $\"{currentHealth:F0}/{maxHealth:F0}\";\n    }\n\n    void CheckHealthStatus()\n    {\n        // 健康状态检查逻辑\n    }\n}\n</code></pre> <p>这个类违反了 SRP，因为它承担了多个职责：</p> <ul> <li>移动控制</li> <li>射击系统</li> <li>健康管理</li> <li>音效播放</li> <li>UI 更新</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#遵循-srp-的重构方案","level":3,"title":"遵循 SRP 的重构方案","text":"<p>让我们将上述代码重构为遵循 SRP 的版本：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#1-健康系统组件","level":4,"title":"1. 健康系统组件","text":"<pre><code>// ✅ 遵循 SRP：只负责健康管理\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class HealthComponent : MonoBehaviour\n{\n    [Title(\"健康配置\")]\n    [SerializeField, Range(1, 1000)] private float maxHealth = 100f;\n\n    [ShowInInspector, ReadOnly, ProgressBar(0, \"maxHealth\", ColorGetter = \"GetHealthColor\")]\n    private float currentHealth;\n\n    [Title(\"事件\")]\n    public UnityEvent&lt;float&gt; OnHealthChanged;\n    public UnityEvent&lt;float&gt; OnDamageTaken;\n    public UnityEvent OnDeath;\n\n    public float CurrentHealth =&gt; currentHealth;\n    public float MaxHealth =&gt; maxHealth;\n    public bool IsAlive =&gt; currentHealth &gt; 0;\n    public float HealthPercentage =&gt; currentHealth / maxHealth;\n\n    void Start()\n    {\n        currentHealth = maxHealth;\n    }\n\n    [Button(\"造成伤害\"), DisableInEditorMode]\n    public void TakeDamage(float damage)\n    {\n        if (!IsAlive) return;\n\n        currentHealth = Mathf.Max(0, currentHealth - damage);\n\n        OnHealthChanged?.Invoke(currentHealth);\n        OnDamageTaken?.Invoke(damage);\n\n        if (!IsAlive)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n\n    [Button(\"恢复血量\"), DisableInEditorMode]\n    public void Heal(float amount)\n    {\n        if (!IsAlive) return;\n\n        currentHealth = Mathf.Min(maxHealth, currentHealth + amount);\n        OnHealthChanged?.Invoke(currentHealth);\n    }\n\n    // Odin Inspector 颜色获取器\n    private Color GetHealthColor()\n    {\n        float percentage = HealthPercentage;\n        if (percentage &gt; 0.6f) return Color.green;\n        if (percentage &gt; 0.3f) return Color.yellow;\n        return Color.red;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#2-移动控制组件","level":4,"title":"2. 移动控制组件","text":"<pre><code>// ✅ 遵循 SRP：只负责移动控制\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class MovementComponent : MonoBehaviour\n{\n    [Title(\"移动配置\")]\n    [SerializeField, Range(1, 20)] private float moveSpeed = 5f;\n\n    [ShowInInspector, ReadOnly]\n    private Vector2 currentVelocity;\n\n    private Rigidbody2D rb;\n\n    void Start()\n    {\n        rb = GetComponent&lt;Rigidbody2D&gt;();\n    }\n\n    void Update()\n    {\n        HandleMovementInput();\n    }\n\n    void HandleMovementInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n\n        Move(new Vector2(horizontal, vertical));\n    }\n\n    [Button(\"停止移动\")]\n    public void Stop()\n    {\n        Move(Vector2.zero);\n    }\n\n    public void Move(Vector2 direction)\n    {\n        currentVelocity = direction.normalized * moveSpeed;\n        rb.velocity = currentVelocity;\n    }\n\n    public void SetSpeed(float newSpeed)\n    {\n        moveSpeed = Mathf.Max(0, newSpeed);\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#3-武器系统组件","level":4,"title":"3. 武器系统组件","text":"<pre><code>// ✅ 遵循 SRP：只负责武器射击\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class WeaponComponent : MonoBehaviour\n{\n    [Title(\"武器配置\")]\n    [SerializeField] private GameObject bulletPrefab;\n    [SerializeField] private Transform firePoint;\n    [SerializeField, Range(0.1f, 5f)] private float fireRate = 0.5f;\n\n    [ShowInInspector, ReadOnly]\n    private float nextFireTime;\n\n    [Title(\"事件\")]\n    public UnityEvent OnWeaponFired;\n\n    public bool CanFire =&gt; Time.time &gt;= nextFireTime;\n\n    void Update()\n    {\n        if (Input.GetButton(\"Fire1\") &amp;&amp; CanFire)\n        {\n            Fire();\n        }\n    }\n\n    [Button(\"开火\"), DisableInEditorMode]\n    public void Fire()\n    {\n        if (!CanFire) return;\n\n        Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        nextFireTime = Time.time + fireRate;\n\n        OnWeaponFired?.Invoke();\n    }\n\n    public void SetFireRate(float newFireRate)\n    {\n        fireRate = Mathf.Max(0.1f, newFireRate);\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#4-重构后的玩家控制器","level":4,"title":"4. 重构后的玩家控制器","text":"<pre><code>// ✅ 遵循 SRP：只负责组件协调\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    [Title(\"组件引用\")]\n    [SerializeField, Required] private HealthComponent healthComponent;\n    [SerializeField, Required] private MovementComponent movementComponent;\n    [SerializeField, Required] private WeaponComponent weaponComponent;\n    [SerializeField, Required] private AudioSource audioSource;\n\n    [Title(\"音效配置\")]\n    [SerializeField] private AudioClip shootSound;\n    [SerializeField] private AudioClip hurtSound;\n\n    void Start()\n    {\n        SetupEventListeners();\n    }\n\n    void SetupEventListeners()\n    {\n        // 监听健康变化事件\n        healthComponent.OnDamageTaken.AddListener(OnPlayerHurt);\n        healthComponent.OnDeath.AddListener(OnPlayerDeath);\n\n        // 监听武器射击事件\n        weaponComponent.OnWeaponFired.AddListener(OnWeaponFired);\n    }\n\n    void OnPlayerHurt(float damage)\n    {\n        if (hurtSound != null)\n            audioSource.PlayOneShot(hurtSound);\n    }\n\n    void OnPlayerDeath()\n    {\n        // 处理玩家死亡\n        movementComponent.Stop();\n        // 可以触发游戏结束逻辑\n    }\n\n    void OnWeaponFired()\n    {\n        if (shootSound != null)\n            audioSource.PlayOneShot(shootSound);\n    }\n\n    void OnDestroy()\n    {\n        // 清理事件监听\n        if (healthComponent != null)\n        {\n            healthComponent.OnDamageTaken.RemoveListener(OnPlayerHurt);\n            healthComponent.OnDeath.RemoveListener(OnPlayerDeath);\n        }\n\n        if (weaponComponent != null)\n        {\n            weaponComponent.OnWeaponFired.RemoveListener(OnWeaponFired);\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#srp-的优势","level":3,"title":"SRP 的优势","text":"<p>重构后的代码具有以下优势：</p> <ol> <li>职责清晰：每个组件只负责一个特定功能</li> <li>易于测试：可以单独测试每个组件</li> <li>易于维护：修改某个功能不会影响其他功能</li> <li>可重用性高：组件可以在其他地方复用</li> <li>易于扩展：添加新功能只需要添加新组件</li> </ol> <p>Odin Inspector 的 SRP 支持</p> <ul> <li>使用 <code>[Title]</code> 和 <code>[BoxGroup]</code> 来组织单一职责的配置项</li> <li>使用 <code>[Required]</code> 特性确保必要依赖的完整性</li> <li>使用 <code>[Button]</code> 特性提供测试接口</li> <li>使用 <code>[ShowInInspector]</code> 和 <code>[ReadOnly]</code> 显示运行时状态</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#o---开闭原则-open-closed-principle","level":2,"title":"O - 开闭原则 (Open-Closed Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#原理阐述_1","level":3,"title":"原理阐述","text":"<p>开闭原则要求软件实体（类、模块、函数等）对扩展开放，对修改封闭。这意味着当需要添加新功能时，应该通过扩展现有代码来实现，而不是修改现有代码。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#违反-ocp-的问题示例","level":3,"title":"违反 OCP 的问题示例","text":"<p>考虑一个武器系统，如果不遵循开闭原则：</p> <pre><code>// ❌ 违反开闭原则的武器系统\npublic enum WeaponType\n{\n    Pistol,\n    Rifle,\n    Shotgun\n    // 每次添加新武器都需要修改这个枚举\n}\n\npublic class BadWeaponSystem : MonoBehaviour\n{\n    public WeaponType weaponType;\n    public GameObject bulletPrefab;\n    public Transform firePoint;\n\n    public void Fire()\n    {\n        // 每次添加新武器都需要修改这个方法\n        switch (weaponType)\n        {\n            case WeaponType.Pistol:\n                FirePistol();\n                break;\n            case WeaponType.Rifle:\n                FireRifle();\n                break;\n            case WeaponType.Shotgun:\n                FireShotgun();\n                break;\n            // 需要不断添加新的 case\n        }\n    }\n\n    void FirePistol()\n    {\n        // 手枪射击逻辑\n        Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n    }\n\n    void FireRifle()\n    {\n        // 步枪射击逻辑（三连发）\n        for (int i = 0; i &lt; 3; i++)\n        {\n            Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        }\n    }\n\n    void FireShotgun()\n    {\n        // 鸳弹枪射击逻辑（散弹）\n        for (int i = 0; i &lt; 5; i++)\n        {\n            float angle = (i - 2) * 15f;\n            Quaternion rotation = Quaternion.Euler(0, 0, angle) * firePoint.rotation;\n            Instantiate(bulletPrefab, firePoint.position, rotation);\n        }\n    }\n}\n</code></pre> <p>这种设计的问题：</p> <ul> <li>每次添加新武器都需要修改现有代码</li> <li>代码修改可能引入新的 Bug</li> <li>难以进行单元测试</li> <li>不符合开闭原则</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#遵循-ocp-的重构方案","level":3,"title":"遵循 OCP 的重构方案","text":"<p>使用策略模式和接口来遵循开闭原则：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#1-定义武器接口","level":4,"title":"1. 定义武器接口","text":"<pre><code>// ✅ 武器接口：对扩展开放\nusing UnityEngine;\n\npublic interface IWeapon\n{\n    string WeaponName { get; }\n    float Damage { get; }\n    float FireRate { get; }\n    void Fire(Transform firePoint, GameObject bulletPrefab);\n    bool CanFire();\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#2-具体武器实现","level":4,"title":"2. 具体武器实现","text":"<pre><code>// ✅ 手枪实现\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\n[System.Serializable]\npublic class PistolWeapon : IWeapon\n{\n    [Title(\"手枪配置\")]\n    [SerializeField] private string weaponName = \"手枪\";\n    [SerializeField, Range(10, 50)] private float damage = 25f;\n    [SerializeField, Range(0.1f, 2f)] private float fireRate = 0.5f;\n\n    private float lastFireTime;\n\n    public string WeaponName =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n\n    public bool CanFire()\n    {\n        return Time.time &gt;= lastFireTime + fireRate;\n    }\n\n    public void Fire(Transform firePoint, GameObject bulletPrefab)\n    {\n        if (!CanFire()) return;\n\n        GameObject bullet = Object.Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        if (bullet.TryGetComponent&lt;Bullet&gt;(out var bulletComponent))\n        {\n            bulletComponent.SetDamage(damage);\n        }\n\n        lastFireTime = Time.time;\n    }\n}\n\n// ✅ 步枪实现\n[System.Serializable]\npublic class RifleWeapon : IWeapon\n{\n    [Title(\"步枪配置\")]\n    [SerializeField] private string weaponName = \"步枪\";\n    [SerializeField, Range(15, 40)] private float damage = 20f;\n    [SerializeField, Range(0.05f, 0.3f)] private float fireRate = 0.1f;\n    [SerializeField, Range(1, 5)] private int burstCount = 3;\n\n    private float lastFireTime;\n\n    public string WeaponName =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n\n    public bool CanFire()\n    {\n        return Time.time &gt;= lastFireTime + fireRate;\n    }\n\n    public void Fire(Transform firePoint, GameObject bulletPrefab)\n    {\n        if (!CanFire()) return;\n\n        // 三连发射击\n        for (int i = 0; i &lt; burstCount; i++)\n        {\n            GameObject bullet = Object.Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n            if (bullet.TryGetComponent&lt;Bullet&gt;(out var bulletComponent))\n            {\n                bulletComponent.SetDamage(damage);\n            }\n        }\n\n        lastFireTime = Time.time;\n    }\n}\n\n// ✅ 鸳弹枪实现\n[System.Serializable]\npublic class ShotgunWeapon : IWeapon\n{\n    [Title(\"鸳弹枪配置\")]\n    [SerializeField] private string weaponName = \"鸳弹枪\";\n    [SerializeField, Range(5, 15)] private float damage = 8f;\n    [SerializeField, Range(0.5f, 3f)] private float fireRate = 1.2f;\n    [SerializeField, Range(3, 8)] private int pelletCount = 5;\n    [SerializeField, Range(5, 30)] private float spreadAngle = 15f;\n\n    private float lastFireTime;\n\n    public string WeaponName =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n\n    public bool CanFire()\n    {\n        return Time.time &gt;= lastFireTime + fireRate;\n    }\n\n    public void Fire(Transform firePoint, GameObject bulletPrefab)\n    {\n        if (!CanFire()) return;\n\n        // 散弹射击\n        for (int i = 0; i &lt; pelletCount; i++)\n        {\n            float angle = (i - (pelletCount - 1) / 2f) * spreadAngle;\n            Quaternion rotation = Quaternion.Euler(0, 0, angle) * firePoint.rotation;\n\n            GameObject bullet = Object.Instantiate(bulletPrefab, firePoint.position, rotation);\n            if (bullet.TryGetComponent&lt;Bullet&gt;(out var bulletComponent))\n            {\n                bulletComponent.SetDamage(damage);\n            }\n        }\n\n        lastFireTime = Time.time;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#3-武器系统控制器","level":4,"title":"3. 武器系统控制器","text":"<pre><code>// ✅ 遵循开闭原则的武器系统\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class WeaponSystem : MonoBehaviour\n{\n    [Title(\"武器配置\")]\n    [SerializeReference, Sirenix.OdinInspector.LabelText(\"当前武器\")]\n    private IWeapon currentWeapon;\n\n    [SerializeField, Required] private Transform firePoint;\n    [SerializeField, Required] private GameObject bulletPrefab;\n\n    [Title(\"预设武器\")]\n    [SerializeField] private PistolWeapon pistol = new PistolWeapon();\n    [SerializeField] private RifleWeapon rifle = new RifleWeapon();\n    [SerializeField] private ShotgunWeapon shotgun = new ShotgunWeapon();\n\n    [Title(\"事件\")]\n    public UnityEvent&lt;string&gt; OnWeaponChanged;\n    public UnityEvent OnWeaponFired;\n\n    [ShowInInspector, ReadOnly]\n    public string CurrentWeaponName =&gt; currentWeapon?.WeaponName ?? \"无\";\n\n    void Start()\n    {\n        // 默认武器\n        EquipWeapon(pistol);\n    }\n\n    void Update()\n    {\n        HandleInput();\n    }\n\n    void HandleInput()\n    {\n        // 射击\n        if (Input.GetButton(\"Fire1\"))\n        {\n            Fire();\n        }\n\n        // 切换武器\n        if (Input.GetKeyDown(KeyCode.Alpha1)) EquipWeapon(pistol);\n        if (Input.GetKeyDown(KeyCode.Alpha2)) EquipWeapon(rifle);\n        if (Input.GetKeyDown(KeyCode.Alpha3)) EquipWeapon(shotgun);\n    }\n\n    [Button(\"开火\"), DisableInEditorMode]\n    public void Fire()\n    {\n        if (currentWeapon != null &amp;&amp; currentWeapon.CanFire())\n        {\n            currentWeapon.Fire(firePoint, bulletPrefab);\n            OnWeaponFired?.Invoke();\n        }\n    }\n\n    [Button(\"装备手枪\")]\n    public void EquipPistol() =&gt; EquipWeapon(pistol);\n\n    [Button(\"装备步枪\")]\n    public void EquipRifle() =&gt; EquipWeapon(rifle);\n\n    [Button(\"装备鸳弹枪\")]\n    public void EquipShotgun() =&gt; EquipWeapon(shotgun);\n\n    public void EquipWeapon(IWeapon weapon)\n    {\n        currentWeapon = weapon;\n        OnWeaponChanged?.Invoke(weapon.WeaponName);\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#添加新武器对扩展开放","level":3,"title":"添加新武器：对扩展开放","text":"<p>现在添加一个新的激光枪，无需修改现有代码：</p> <pre><code>// ✅ 新武器：激光枪（无需修改现有代码）\n[System.Serializable]\npublic class LaserWeapon : IWeapon\n{\n    [Title(\"激光枪配置\")]\n    [SerializeField] private string weaponName = \"激光枪\";\n    [SerializeField, Range(30, 100)] private float damage = 50f;\n    [SerializeField, Range(0.3f, 1.5f)] private float fireRate = 0.8f;\n    [SerializeField, Range(5, 20)] private float laserDuration = 2f;\n\n    private float lastFireTime;\n\n    public string WeaponName =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n\n    public bool CanFire()\n    {\n        return Time.time &gt;= lastFireTime + fireRate;\n    }\n\n    public void Fire(Transform firePoint, GameObject bulletPrefab)\n    {\n        if (!CanFire()) return;\n\n        // 创建激光束效果\n        GameObject laser = Object.Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        if (laser.TryGetComponent&lt;LaserBeam&gt;(out var laserComponent))\n        {\n            laserComponent.SetDamage(damage);\n            laserComponent.SetDuration(laserDuration);\n        }\n\n        lastFireTime = Time.time;\n    }\n}\n</code></pre> <p>只需要在 <code>WeaponSystem</code> 中添加一个字段：</p> <pre><code>[SerializeField] private LaserWeapon laser = new LaserWeapon();\n\n[Button(\"装备激光枪\")]\npublic void EquipLaser() =&gt; EquipWeapon(laser);\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#ocp-的优势","level":3,"title":"OCP 的优势","text":"<ol> <li>扩展性：添加新功能无需修改现有代码</li> <li>数据稳定性：现有功能不会被新功能影响</li> <li>测试友好：每个武器可以单独测试</li> <li>代码复用：武器实现可以在其他系统中复用</li> </ol> <p>Odin Inspector 的 OCP 支持</p> <ul> <li>使用 <code>[SerializeReference]</code> 实现接口序列化</li> <li>使用 <code>[Button]</code> 提供运行时切换功能</li> <li>使用 <code>[Title]</code> 和 <code>[BoxGroup]</code> 组织不同的武器配置</li> <li>使用 <code>[ShowInInspector]</code> 显示当前状态</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#l---里氏替换原则-liskov-substitution-principle","level":2,"title":"L - 里氏替换原则 (Liskov Substitution Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#原理阐述_2","level":3,"title":"原理阐述","text":"<p>里氏替换原则要求：子类对象必须能够替换其基类对象，而不会影响程序的正确性。这意味着子类应该增强而不是删弱基类的功能。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#违反-lsp-的问题示例","level":3,"title":"违反 LSP 的问题示例","text":"<p>考虑一个飞行物体的继承体系：</p> <pre><code>// ❌ 违反里氏替换原则的设计\npublic abstract class FlyingObject : MonoBehaviour\n{\n    public float speed = 10f;\n\n    public virtual void Fly()\n    {\n        transform.Translate(Vector3.forward * speed * Time.deltaTime);\n    }\n\n    public virtual void Land()\n    {\n        // 默认着陆行为\n        speed = 0;\n    }\n}\n\npublic class Airplane : FlyingObject\n{\n    public override void Fly()\n    {\n        // 飞机正常飞行\n        transform.Translate(Vector3.forward * speed * Time.deltaTime);\n    }\n\n    public override void Land()\n    {\n        // 飞机可以着陆\n        speed = 0;\n        Debug.Log(\"飞机已着陆\");\n    }\n}\n\n// 问题：企鹅不能飞行，违反了 LSP\npublic class Penguin : FlyingObject\n{\n    public override void Fly()\n    {\n        // 企鹅不能飞！\n        throw new System.NotSupportedException(\"企鹅不能飞行！\");\n    }\n\n    public override void Land()\n    {\n        // 企鹅本来就在地上，这个方法没有意义\n        Debug.Log(\"企鹅本来就在地上...\");\n    }\n}\n\n// 使用时会出现问题\npublic class FlightController : MonoBehaviour\n{\n    public FlyingObject[] flyingObjects;\n\n    void Start()\n    {\n        foreach (var obj in flyingObjects)\n        {\n            obj.Fly(); // 如果数组中有企鹅，这里会抛出异常！\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#遵循-lsp-的重构方案","level":3,"title":"遵循 LSP 的重构方案","text":"<p>重新设计类层次结构，使其遵循里氏替换原则：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#1-重新设计基类结构","level":4,"title":"1. 重新设计基类结构","text":"<pre><code>// ✅ 遵循 LSP 的设计：动物基类\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic abstract class Animal : MonoBehaviour\n{\n    [Title(\"动物基本信息\")]\n    [SerializeField, ReadOnly] protected string animalName;\n    [SerializeField, Range(1, 50)] protected float moveSpeed = 5f;\n\n    [ShowInInspector, ReadOnly]\n    public string AnimalName =&gt; animalName;\n\n    [ShowInInspector, ReadOnly]\n    public float MoveSpeed =&gt; moveSpeed;\n\n    protected virtual void Start()\n    {\n        animalName = GetType().Name;\n    }\n\n    // 所有动物都可以移动\n    public abstract void Move(Vector3 direction);\n\n    // 所有动物都可以发出声音\n    public abstract void MakeSound();\n}\n\n// ✅ 可飞行动物接口\npublic interface IFlyable\n{\n    float FlySpeed { get; }\n    void Fly(Vector3 direction);\n    void Land();\n    bool IsFlying { get; }\n}\n\n// ✅ 可游泳动物接口\npublic interface ISwimmable\n{\n    float SwimSpeed { get; }\n    void Swim(Vector3 direction);\n    bool IsSwimming { get; }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#2-具体动物实现","level":4,"title":"2. 具体动物实现","text":"<pre><code>// ✅ 企鹅：只实现它能做的事情\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class Penguin : Animal, ISwimmable\n{\n    [Title(\"企鹅特有属性\")]\n    [SerializeField, Range(1, 20)] private float swimSpeed = 8f;\n    [SerializeField] private bool isSwimming = false;\n\n    public float SwimSpeed =&gt; swimSpeed;\n    public bool IsSwimming =&gt; isSwimming;\n\n    public override void Move(Vector3 direction)\n    {\n        // 企鹅在陆地上走路\n        transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在陆地上行走\");\n    }\n\n    public void Swim(Vector3 direction)\n    {\n        isSwimming = true;\n        transform.Translate(direction.normalized * swimSpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在水中游泳\");\n    }\n\n    public override void MakeSound()\n    {\n        Debug.Log(\"企鹅叫：噖噖噖！\");\n    }\n\n    [Button(\"开始/停止游泳\")]\n    public void ToggleSwimming()\n    {\n        isSwimming = !isSwimming;\n    }\n}\n\n// ✅ 鹰：实现飞行能力\npublic class Eagle : Animal, IFlyable\n{\n    [Title(\"鹰特有属性\")]\n    [SerializeField, Range(5, 30)] private float flySpeed = 15f;\n    [SerializeField] private bool isFlying = false;\n\n    public float FlySpeed =&gt; flySpeed;\n    public bool IsFlying =&gt; isFlying;\n\n    public override void Move(Vector3 direction)\n    {\n        if (isFlying)\n        {\n            Fly(direction);\n        }\n        else\n        {\n            // 在地面行走\n            transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n            Debug.Log($\"{animalName} 在地面行走\");\n        }\n    }\n\n    public void Fly(Vector3 direction)\n    {\n        isFlying = true;\n        transform.Translate(direction.normalized * flySpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在天空飞翔\");\n    }\n\n    public void Land()\n    {\n        isFlying = false;\n        Debug.Log($\"{animalName} 已着陆\");\n    }\n\n    public override void MakeSound()\n    {\n        Debug.Log(\"鹰叫：嘛嘛嘛！\");\n    }\n\n    [Button(\"起飞/着陆\")]\n    public void ToggleFlight()\n    {\n        if (isFlying)\n            Land();\n        else\n            isFlying = true;\n    }\n}\n\n// ✅ 鸭子：实现多种能力\npublic class Duck : Animal, IFlyable, ISwimmable\n{\n    [Title(\"鸭子特有属性\")]\n    [SerializeField, Range(3, 15)] private float flySpeed = 10f;\n    [SerializeField, Range(2, 12)] private float swimSpeed = 6f;\n    [SerializeField] private bool isFlying = false;\n    [SerializeField] private bool isSwimming = false;\n\n    public float FlySpeed =&gt; flySpeed;\n    public float SwimSpeed =&gt; swimSpeed;\n    public bool IsFlying =&gt; isFlying;\n    public bool IsSwimming =&gt; isSwimming;\n\n    public override void Move(Vector3 direction)\n    {\n        if (isFlying)\n        {\n            Fly(direction);\n        }\n        else if (isSwimming)\n        {\n            Swim(direction);\n        }\n        else\n        {\n            // 在陆地行走\n            transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n            Debug.Log($\"{animalName} 在陆地行走\");\n        }\n    }\n\n    public void Fly(Vector3 direction)\n    {\n        isFlying = true;\n        isSwimming = false;\n        transform.Translate(direction.normalized * flySpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在天空飞翔\");\n    }\n\n    public void Land()\n    {\n        isFlying = false;\n        Debug.Log($\"{animalName} 已着陆\");\n    }\n\n    public void Swim(Vector3 direction)\n    {\n        isSwimming = true;\n        isFlying = false;\n        transform.Translate(direction.normalized * swimSpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在水中游泳\");\n    }\n\n    public override void MakeSound()\n    {\n        Debug.Log(\"鸭子叫：嘉嘉嘉！\");\n    }\n\n    [Button(\"起飞/着陆\")]\n    public void ToggleFlight()\n    {\n        if (isFlying)\n            Land();\n        else\n        {\n            isFlying = true;\n            isSwimming = false;\n        }\n    }\n\n    [Button(\"开始/停止游泳\")]\n    public void ToggleSwimming()\n    {\n        isSwimming = !isSwimming;\n        if (isSwimming)\n            isFlying = false;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#3-遵循-lsp-的控制器","level":4,"title":"3. 遵循 LSP 的控制器","text":"<pre><code>// ✅ 遵循 LSP 的控制器\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class AnimalController : MonoBehaviour\n{\n    [Title(\"动物集合\")]\n    [SerializeField] private Animal[] allAnimals;\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;IFlyable&gt; flyableAnimals = new List&lt;IFlyable&gt;();\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;ISwimmable&gt; swimmableAnimals = new List&lt;ISwimmable&gt;();\n\n    void Start()\n    {\n        CategorizeAnimals();\n    }\n\n    void CategorizeAnimals()\n    {\n        flyableAnimals.Clear();\n        swimmableAnimals.Clear();\n\n        foreach (var animal in allAnimals)\n        {\n            if (animal is IFlyable flyable)\n                flyableAnimals.Add(flyable);\n\n            if (animal is ISwimmable swimmable)\n                swimmableAnimals.Add(swimmable);\n        }\n    }\n\n    [Button(\"所有动物移动\")]\n    public void MoveAllAnimals()\n    {\n        foreach (var animal in allAnimals)\n        {\n            // 所有动物都能移动，符合 LSP\n            animal.Move(Vector3.forward);\n        }\n    }\n\n    [Button(\"所有动物发声\")]\n    public void MakeAllAnimalsSound()\n    {\n        foreach (var animal in allAnimals)\n        {\n            // 所有动物都能发声，符合 LSP\n            animal.MakeSound();\n        }\n    }\n\n    [Button(\"所有会飞的动物飞行\")]\n    public void MakeAllFlyableAnimalsFly()\n    {\n        foreach (var flyable in flyableAnimals)\n        {\n            flyable.Fly(Vector3.up);\n        }\n    }\n\n    [Button(\"所有会游泳的动物游泳\")]\n    public void MakeAllSwimmableAnimalsSwim()\n    {\n        foreach (var swimmable in swimmableAnimals)\n        {\n            swimmable.Swim(Vector3.forward);\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#lsp-的关键原则","level":3,"title":"LSP 的关键原则","text":"<ol> <li>子类必须能替换基类：在任何使用基类的地方，都可以使用子类</li> <li>不能弱化基类的功能：子类不能抛出基类不会抛出的异常</li> <li>保持行为一致性：子类的行为应该与基类的期望一致</li> <li>子类可以增强功能：但不能删弱原有功能</li> </ol> <p>Odin Inspector 的 LSP 支持</p> <ul> <li>使用 <code>[ShowInInspector]</code> 显示类型信息和状态</li> <li>使用 <code>[Button]</code> 提供不同行为的测试接口</li> <li>使用 <code>[ReadOnly]</code> 防止意外修改关键属性</li> <li>使用 <code>[Title]</code> 清晰区分不同类型的功能</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#i---接口隔离原则-interface-segregation-principle","level":2,"title":"I - 接口隔离原则 (Interface Segregation Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#原理阐述_3","level":3,"title":"原理阐述","text":"<p>接口隔离原则要求：不应该强迫客户端依赖于它们不使用的接口。接口应该细粒度且专门针对特定的客户端需求。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#违反-isp-的问题示例","level":3,"title":"违反 ISP 的问题示例","text":"<p>考虑一个臃胖的游戏对象接口：</p> <pre><code>// ❌ 违反接口隔离原则的臃胖接口\npublic interface IBloatedGameObject\n{\n    // 移动相关\n    void Move(Vector3 direction);\n    void Stop();\n    float GetSpeed();\n\n    // 战斗相关\n    void Attack(GameObject target);\n    void TakeDamage(float damage);\n    float GetHealth();\n\n    // 道具相关\n    void UseItem(int itemId);\n    void PickupItem(GameObject item);\n    void DropItem(int itemId);\n\n    // NPC 对话相关\n    void StartDialogue();\n    void EndDialogue();\n    string GetDialogueText();\n\n    // 商店相关\n    void OpenShop();\n    void BuyItem(int itemId);\n    void SellItem(int itemId);\n\n    // 任务相关\n    void AcceptQuest(int questId);\n    void CompleteQuest(int questId);\n    void GetQuestProgress(int questId);\n}\n\n// 问题：武器物品不需要对话和商店功能\npublic class Weapon : MonoBehaviour, IBloatedGameObject\n{\n    public void Move(Vector3 direction) { /* 正常实现 */ }\n    public void Stop() { /* 正常实现 */ }\n    public float GetSpeed() { return 0; }\n\n    public void Attack(GameObject target) { /* 正常实现 */ }\n    public void TakeDamage(float damage) { /* 正常实现 */ }\n    public float GetHealth() { return 100; }\n\n    // 不需要的方法，但被迫实现\n    public void UseItem(int itemId) { throw new System.NotImplementedException(); }\n    public void PickupItem(GameObject item) { throw new System.NotImplementedException(); }\n    public void DropItem(int itemId) { throw new System.NotImplementedException(); }\n\n    public void StartDialogue() { throw new System.NotImplementedException(); }\n    public void EndDialogue() { throw new System.NotImplementedException(); }\n    public string GetDialogueText() { throw new System.NotImplementedException(); }\n\n    public void OpenShop() { throw new System.NotImplementedException(); }\n    public void BuyItem(int itemId) { throw new System.NotImplementedException(); }\n    public void SellItem(int itemId) { throw new System.NotImplementedException(); }\n\n    public void AcceptQuest(int questId) { throw new System.NotImplementedException(); }\n    public void CompleteQuest(int questId) { throw new System.NotImplementedException(); }\n    public void GetQuestProgress(int questId) { throw new System.NotImplementedException(); }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#遵循-isp-的重构方案","level":3,"title":"遵循 ISP 的重构方案","text":"<p>将臃胖接口拆分为多个细粒度的接口：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#1-细粒度接口定义","level":4,"title":"1. 细粒度接口定义","text":"<pre><code>// ✅ 移动能力接口\npublic interface IMoveable\n{\n    void Move(Vector3 direction);\n    void Stop();\n    float Speed { get; set; }\n}\n\n// ✅ 战斗能力接口\npublic interface ICombatable\n{\n    void Attack(GameObject target);\n    void TakeDamage(float damage);\n    float Health { get; }\n    float MaxHealth { get; }\n    bool IsAlive { get; }\n}\n\n// ✅ 道具使用接口\npublic interface IItemUser\n{\n    void UseItem(int itemId);\n    void PickupItem(GameObject item);\n    void DropItem(int itemId);\n    int[] GetInventory();\n}\n\n// ✅ 对话能力接口\npublic interface IDialogable\n{\n    void StartDialogue();\n    void EndDialogue();\n    string GetDialogueText();\n    bool IsInDialogue { get; }\n}\n\n// ✅ 商店接口\npublic interface IShopkeeper\n{\n    void OpenShop();\n    void BuyItem(int itemId, int quantity);\n    void SellItem(int itemId, int quantity);\n    bool HasItem(int itemId);\n    int GetItemPrice(int itemId);\n}\n\n// ✅ 任务系统接口\npublic interface IQuestGiver\n{\n    void GiveQuest(int questId);\n    bool CanGiveQuest(int questId);\n}\n\npublic interface IQuestReceiver\n{\n    void AcceptQuest(int questId);\n    void CompleteQuest(int questId);\n    float GetQuestProgress(int questId);\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#2-精简的实现类","level":4,"title":"2. 精简的实现类","text":"<pre><code>// ✅ 武器：只实现需要的接口\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class Weapon : MonoBehaviour, IMoveable, ICombatable\n{\n    [Title(\"武器属性\")]\n    [SerializeField, Range(1, 20)] private float speed = 5f;\n    [SerializeField, Range(10, 100)] private float health = 50f;\n    [SerializeField, Range(10, 100)] private float maxHealth = 50f;\n    [SerializeField, Range(10, 50)] private float damage = 25f;\n\n    public float Speed \n    { \n        get =&gt; speed; \n        set =&gt; speed = Mathf.Max(0, value); \n    }\n\n    public float Health =&gt; health;\n    public float MaxHealth =&gt; maxHealth;\n    public bool IsAlive =&gt; health &gt; 0;\n\n    public void Move(Vector3 direction)\n    {\n        transform.Translate(direction.normalized * speed * Time.deltaTime);\n    }\n\n    public void Stop()\n    {\n        // 停止移动逻辑\n    }\n\n    public void Attack(GameObject target)\n    {\n        if (target.TryGetComponent&lt;ICombatable&gt;(out var combatable))\n        {\n            combatable.TakeDamage(damage);\n        }\n    }\n\n    public void TakeDamage(float damage)\n    {\n        health = Mathf.Max(0, health - damage);\n        if (!IsAlive)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n\n// ✅ NPC：实现多个相关接口\npublic class NPC : MonoBehaviour, IMoveable, ICombatable, IDialogable, IShopkeeper\n{\n    [Title(\"NPC 基本属性\")]\n    [SerializeField, Range(1, 10)] private float speed = 3f;\n    [SerializeField, Range(50, 200)] private float health = 100f;\n    [SerializeField, Range(50, 200)] private float maxHealth = 100f;\n\n    [Title(\"对话系统\")]\n    [SerializeField] private string[] dialogueLines;\n    [SerializeField] private bool isInDialogue = false;\n\n    [Title(\"商店系统\")]\n    [SerializeField] private int[] shopItems;\n    [SerializeField] private int[] itemPrices;\n\n    // IMoveable 实现\n    public float Speed \n    { \n        get =&gt; speed; \n        set =&gt; speed = Mathf.Max(0, value); \n    }\n\n    public void Move(Vector3 direction)\n    {\n        if (!isInDialogue)\n            transform.Translate(direction.normalized * speed * Time.deltaTime);\n    }\n\n    public void Stop() { }\n\n    // ICombatable 实现\n    public float Health =&gt; health;\n    public float MaxHealth =&gt; maxHealth;\n    public bool IsAlive =&gt; health &gt; 0;\n\n    public void Attack(GameObject target)\n    {\n        // NPC 攻击逻辑\n    }\n\n    public void TakeDamage(float damage)\n    {\n        health = Mathf.Max(0, health - damage);\n    }\n\n    // IDialogable 实现\n    public bool IsInDialogue =&gt; isInDialogue;\n\n    public void StartDialogue()\n    {\n        isInDialogue = true;\n        Stop();\n    }\n\n    public void EndDialogue()\n    {\n        isInDialogue = false;\n    }\n\n    public string GetDialogueText()\n    {\n        return dialogueLines[Random.Range(0, dialogueLines.Length)];\n    }\n\n    // IShopkeeper 实现\n    public void OpenShop()\n    {\n        Debug.Log(\"NPC 商店开启\");\n    }\n\n    public void BuyItem(int itemId, int quantity)\n    {\n        // 购买逻辑\n    }\n\n    public void SellItem(int itemId, int quantity)\n    {\n        // 出售逻辑\n    }\n\n    public bool HasItem(int itemId)\n    {\n        return System.Array.Exists(shopItems, item =&gt; item == itemId);\n    }\n\n    public int GetItemPrice(int itemId)\n    {\n        int index = System.Array.IndexOf(shopItems, itemId);\n        return index &gt;= 0 ? itemPrices[index] : 0;\n    }\n}\n\n// ✅ 玩家：实现与玩家相关的接口\npublic class Player : MonoBehaviour, IMoveable, ICombatable, IItemUser, IQuestReceiver\n{\n    [Title(\"玩家属性\")]\n    [SerializeField] private float speed = 8f;\n    [SerializeField] private float health = 100f;\n    [SerializeField] private float maxHealth = 100f;\n\n    [Title(\"道具系统\")]\n    [SerializeField] private int[] inventory = new int[10];\n\n    [Title(\"任务系统\")]\n    [SerializeField] private int[] activeQuests = new int[5];\n\n    // 实现所有需要的接口方法...\n    public float Speed { get =&gt; speed; set =&gt; speed = value; }\n    public float Health =&gt; health;\n    public float MaxHealth =&gt; maxHealth;\n    public bool IsAlive =&gt; health &gt; 0;\n\n    public void Move(Vector3 direction)\n    {\n        transform.Translate(direction.normalized * speed * Time.deltaTime);\n    }\n\n    public void Stop() { }\n\n    public void Attack(GameObject target) \n    {\n        // 玩家攻击逻辑\n    }\n\n    public void TakeDamage(float damage)\n    {\n        health = Mathf.Max(0, health - damage);\n    }\n\n    public void UseItem(int itemId) { /* 使用道具 */ }\n    public void PickupItem(GameObject item) { /* 拾取道具 */ }\n    public void DropItem(int itemId) { /* 丢弃道具 */ }\n    public int[] GetInventory() =&gt; inventory;\n\n    public void AcceptQuest(int questId) { /* 接受任务 */ }\n    public void CompleteQuest(int questId) { /* 完成任务 */ }\n    public float GetQuestProgress(int questId) { return 0f; }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#isp-的优势","level":3,"title":"ISP 的优势","text":"<ol> <li>接口精简：每个接口只包含相关的方法</li> <li>降低耦合：类只依赖于它们实际使用的接口</li> <li>易于维护：修改一个接口不会影响不相关的类</li> <li>提高单元测试效率：可以单独模拟每个细粒度接口</li> </ol> <p>Odin Inspector 的 ISP 支持</p> <ul> <li>使用 <code>[Title]</code> 将不同接口的功能分组显示</li> <li>使用 <code>[ShowInInspector]</code> 适度暴露接口状态</li> <li>使用 <code>[Required]</code> 确保接口依赖的完整性</li> <li>使用 <code>[Button]</code> 为每个接口提供测试入口</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#d---依赖倒置原则-dependency-inversion-principle","level":2,"title":"D - 依赖倒置原则 (Dependency Inversion Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#原理阐述_4","level":3,"title":"原理阐述","text":"<p>依赖倒置原则包含两个重要概念：</p> <ol> <li>高层模块不应该依赖于低层模块，两者都应该依赖于抽象</li> <li>抽象不应该依赖于实现，实现应该依赖于抽象</li> </ol> <p>这个原则的核心是通过抽象（接口或抽象类）来降低模块间的耦合度。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#违反-dip-的问题示例","level":3,"title":"违反 DIP 的问题示例","text":"<p>考虑一个游戏保存系统：</p> <pre><code>// ❌ 违反依赖倒置原则的设计\npublic class FileDataStorage\n{\n    public void SaveData(string data, string filename)\n    {\n        System.IO.File.WriteAllText(filename, data);\n        Debug.Log(\"数据已保存到文件: \" + filename);\n    }\n\n    public string LoadData(string filename)\n    {\n        if (System.IO.File.Exists(filename))\n        {\n            return System.IO.File.ReadAllText(filename);\n        }\n        return string.Empty;\n    }\n}\n\n// 问题：高层的 GameManager 直接依赖于低层的 FileDataStorage\npublic class BadGameManager : MonoBehaviour\n{\n    private FileDataStorage fileStorage; // 直接依赖具体实现\n\n    void Start()\n    {\n        fileStorage = new FileDataStorage(); // 紧耦合\n    }\n\n    public void SaveGame()\n    {\n        string gameData = GetGameData();\n        fileStorage.SaveData(gameData, \"savegame.json\"); // 直接调用具体实现\n    }\n\n    public void LoadGame()\n    {\n        string gameData = fileStorage.LoadData(\"savegame.json\");\n        ApplyGameData(gameData);\n    }\n\n    // 要更换为云存储，必须修改这个类\n    // 要支持多种存储方式，需要大量修改\n\n    private string GetGameData() { return \"{}\"; }\n    private void ApplyGameData(string data) { }\n}\n</code></pre> <p>这种设计的问题：</p> <ul> <li><code>GameManager</code>（高层）直接依赖于 <code>FileDataStorage</code>（低层）</li> <li>难以扩展为云存储或其他存储方式</li> <li>难以进行单元测试（无法模拟存储）</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#遵循-dip-的重构方案","level":3,"title":"遵循 DIP 的重构方案","text":"<p>通过抽象接口和依赖注入来解决问题：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#1-定义抽象接口","level":4,"title":"1. 定义抽象接口","text":"<pre><code>// ✅ 存储系统抽象接口\npublic interface IDataStorage\n{\n    void SaveData(string data, string key);\n    string LoadData(string key);\n    bool HasData(string key);\n    void DeleteData(string key);\n}\n\n// ✅ 事件系统抽象接口\npublic interface IEventSystem\n{\n    void Subscribe&lt;T&gt;(System.Action&lt;T&gt; handler) where T : class;\n    void Unsubscribe&lt;T&gt;(System.Action&lt;T&gt; handler) where T : class;\n    void Publish&lt;T&gt;(T eventData) where T : class;\n}\n\n// ✅ 日志系统抽象接口\npublic interface ILogger\n{\n    void Log(string message);\n    void LogWarning(string message);\n    void LogError(string message);\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#2-具体实现低层模块","level":4,"title":"2. 具体实现（低层模块）","text":"<pre><code>// ✅ 文件存储实现\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing System.IO;\n\npublic class FileDataStorage : IDataStorage\n{\n    [Title(\"文件存储配置\")]\n    [SerializeField, FolderPath] private string saveDirectory = \"SaveData\";\n    [SerializeField] private string fileExtension = \".json\";\n\n    public void SaveData(string data, string key)\n    {\n        string fullPath = GetFullPath(key);\n        Directory.CreateDirectory(Path.GetDirectoryName(fullPath));\n        File.WriteAllText(fullPath, data);\n        Debug.Log($\"数据已保存到: {fullPath}\");\n    }\n\n    public string LoadData(string key)\n    {\n        string fullPath = GetFullPath(key);\n        if (File.Exists(fullPath))\n        {\n            return File.ReadAllText(fullPath);\n        }\n        Debug.LogWarning($\"文件不存在: {fullPath}\");\n        return string.Empty;\n    }\n\n    public bool HasData(string key)\n    {\n        return File.Exists(GetFullPath(key));\n    }\n\n    public void DeleteData(string key)\n    {\n        string fullPath = GetFullPath(key);\n        if (File.Exists(fullPath))\n        {\n            File.Delete(fullPath);\n            Debug.Log($\"文件已删除: {fullPath}\");\n        }\n    }\n\n    private string GetFullPath(string key)\n    {\n        return Path.Combine(Application.persistentDataPath, saveDirectory, key + fileExtension);\n    }\n}\n\n// ✅ PlayerPrefs 存储实现\npublic class PlayerPrefsDataStorage : IDataStorage\n{\n    public void SaveData(string data, string key)\n    {\n        PlayerPrefs.SetString(key, data);\n        PlayerPrefs.Save();\n        Debug.Log($\"数据已保存到 PlayerPrefs: {key}\");\n    }\n\n    public string LoadData(string key)\n    {\n        return PlayerPrefs.GetString(key, string.Empty);\n    }\n\n    public bool HasData(string key)\n    {\n        return PlayerPrefs.HasKey(key);\n    }\n\n    public void DeleteData(string key)\n    {\n        PlayerPrefs.DeleteKey(key);\n        PlayerPrefs.Save();\n        Debug.Log($\"PlayerPrefs 键已删除: {key}\");\n    }\n}\n\n// ✅ Unity 日志实现\npublic class UnityLogger : ILogger\n{\n    public void Log(string message)\n    {\n        Debug.Log($\"[INFO] {message}\");\n    }\n\n    public void LogWarning(string message)\n    {\n        Debug.LogWarning($\"[WARNING] {message}\");\n    }\n\n    public void LogError(string message)\n    {\n        Debug.LogError($\"[ERROR] {message}\");\n    }\n}\n\n// ✅ 简单事件系统实现\nusing System.Collections.Generic;\nusing System;\n\npublic class SimpleEventSystem : IEventSystem\n{\n    private Dictionary&lt;Type, List&lt;Delegate&gt;&gt; eventHandlers = new Dictionary&lt;Type, List&lt;Delegate&gt;&gt;();\n\n    public void Subscribe&lt;T&gt;(Action&lt;T&gt; handler) where T : class\n    {\n        Type eventType = typeof(T);\n        if (!eventHandlers.ContainsKey(eventType))\n        {\n            eventHandlers[eventType] = new List&lt;Delegate&gt;();\n        }\n        eventHandlers[eventType].Add(handler);\n    }\n\n    public void Unsubscribe&lt;T&gt;(Action&lt;T&gt; handler) where T : class\n    {\n        Type eventType = typeof(T);\n        if (eventHandlers.ContainsKey(eventType))\n        {\n            eventHandlers[eventType].Remove(handler);\n        }\n    }\n\n    public void Publish&lt;T&gt;(T eventData) where T : class\n    {\n        Type eventType = typeof(T);\n        if (eventHandlers.ContainsKey(eventType))\n        {\n            foreach (var handler in eventHandlers[eventType])\n            {\n                (handler as Action&lt;T&gt;)?.Invoke(eventData);\n            }\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#3-依赖注入容器","level":4,"title":"3. 依赖注入容器","text":"<pre><code>// ✅ 简单的依赖注入容器\nusing System;\nusing System.Collections.Generic;\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class ServiceContainer : MonoBehaviour\n{\n    private static ServiceContainer instance;\n    public static ServiceContainer Instance \n    { \n        get\n        {\n            if (instance == null)\n            {\n                instance = FindObjectOfType&lt;ServiceContainer&gt;();\n                if (instance == null)\n                {\n                    GameObject go = new GameObject(\"ServiceContainer\");\n                    instance = go.AddComponent&lt;ServiceContainer&gt;();\n                    DontDestroyOnLoad(go);\n                }\n            }\n            return instance;\n        }\n    }\n\n    [Title(\"服务配置\")]\n    [SerializeField] private bool useFileStorage = true;\n    [SerializeField] private bool useUnityLogger = true;\n\n    private Dictionary&lt;Type, object&gt; services = new Dictionary&lt;Type, object&gt;();\n\n    void Awake()\n    {\n        if (instance == null)\n        {\n            instance = this;\n            DontDestroyOnLoad(gameObject);\n            RegisterServices();\n        }\n        else if (instance != this)\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    void RegisterServices()\n    {\n        // 注册存储服务\n        if (useFileStorage)\n        {\n            Register&lt;IDataStorage&gt;(new FileDataStorage());\n        }\n        else\n        {\n            Register&lt;IDataStorage&gt;(new PlayerPrefsDataStorage());\n        }\n\n        // 注册日志服务\n        if (useUnityLogger)\n        {\n            Register&lt;ILogger&gt;(new UnityLogger());\n        }\n\n        // 注册事件系统\n        Register&lt;IEventSystem&gt;(new SimpleEventSystem());\n    }\n\n    public void Register&lt;T&gt;(T service)\n    {\n        services[typeof(T)] = service;\n    }\n\n    public T Get&lt;T&gt;()\n    {\n        Type serviceType = typeof(T);\n        if (services.ContainsKey(serviceType))\n        {\n            return (T)services[serviceType];\n        }\n        throw new InvalidOperationException($\"服务 {serviceType.Name} 未注册\");\n    }\n\n    [Button(\"显示所有已注册的服务\")]\n    public void ShowRegisteredServices()\n    {\n        Debug.Log(\"已注册的服务:\");\n        foreach (var service in services)\n        {\n            Debug.Log($\"- {service.Key.Name}: {service.Value.GetType().Name}\");\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#4-遵循-dip-的高层模块","level":4,"title":"4. 遵循 DIP 的高层模块","text":"<pre><code>// ✅ 遵循依赖倒置原则的 GameManager\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing System;\n\npublic class GameManager : MonoBehaviour\n{\n    [Title(\"依赖服务\")]\n    [ShowInInspector, ReadOnly] private IDataStorage dataStorage;\n    [ShowInInspector, ReadOnly] private ILogger logger;\n    [ShowInInspector, ReadOnly] private IEventSystem eventSystem;\n\n    [Title(\"游戏状态\")]\n    [SerializeField] private int playerLevel = 1;\n    [SerializeField] private float playerHealth = 100f;\n    [SerializeField] private int playerScore = 0;\n\n    void Start()\n    {\n        // 依赖注入：通过抽象接口获取服务\n        InjectDependencies();\n\n        // 设置事件监听\n        SetupEventListeners();\n\n        logger.Log(\"GameManager 已初始化\");\n    }\n\n    void InjectDependencies()\n    {\n        try\n        {\n            dataStorage = ServiceContainer.Instance.Get&lt;IDataStorage&gt;();\n            logger = ServiceContainer.Instance.Get&lt;ILogger&gt;();\n            eventSystem = ServiceContainer.Instance.Get&lt;IEventSystem&gt;();\n        }\n        catch (Exception ex)\n        {\n            Debug.LogError($\"依赖注入失败: {ex.Message}\");\n        }\n    }\n\n    void SetupEventListeners()\n    {\n        eventSystem.Subscribe&lt;PlayerLevelUpEvent&gt;(OnPlayerLevelUp);\n        eventSystem.Subscribe&lt;PlayerHealthChangedEvent&gt;(OnPlayerHealthChanged);\n    }\n\n    [Button(\"保存游戏\")]\n    public void SaveGame()\n    {\n        try\n        {\n            var gameData = new GameData\n            {\n                level = playerLevel,\n                health = playerHealth,\n                score = playerScore,\n                saveTime = DateTime.Now.ToString()\n            };\n\n            string jsonData = JsonUtility.ToJson(gameData, true);\n            dataStorage.SaveData(jsonData, \"savegame\");\n\n            logger.Log(\"游戏已保存\");\n        }\n        catch (Exception ex)\n        {\n            logger.LogError($\"保存游戏失败: {ex.Message}\");\n        }\n    }\n\n    [Button(\"加载游戏\")]\n    public void LoadGame()\n    {\n        try\n        {\n            if (dataStorage.HasData(\"savegame\"))\n            {\n                string jsonData = dataStorage.LoadData(\"savegame\");\n                var gameData = JsonUtility.FromJson&lt;GameData&gt;(jsonData);\n\n                playerLevel = gameData.level;\n                playerHealth = gameData.health;\n                playerScore = gameData.score;\n\n                logger.Log($\"游戏已加载（保存时间: {gameData.saveTime}）\");\n            }\n            else\n            {\n                logger.LogWarning(\"未找到存档文件\");\n            }\n        }\n        catch (Exception ex)\n        {\n            logger.LogError($\"加载游戏失败: {ex.Message}\");\n        }\n    }\n\n    [Button(\"玩家升级\")]\n    public void LevelUp()\n    {\n        playerLevel++;\n        eventSystem.Publish(new PlayerLevelUpEvent { NewLevel = playerLevel });\n    }\n\n    void OnPlayerLevelUp(PlayerLevelUpEvent eventData)\n    {\n        logger.Log($\"玩家升级到 {eventData.NewLevel} 级！\");\n    }\n\n    void OnPlayerHealthChanged(PlayerHealthChangedEvent eventData)\n    {\n        logger.Log($\"玩家血量变为 {eventData.NewHealth}\");\n    }\n\n    void OnDestroy()\n    {\n        if (eventSystem != null)\n        {\n            eventSystem.Unsubscribe&lt;PlayerLevelUpEvent&gt;(OnPlayerLevelUp);\n            eventSystem.Unsubscribe&lt;PlayerHealthChangedEvent&gt;(OnPlayerHealthChanged);\n        }\n    }\n}\n\n// ✅ 事件数据类\n[System.Serializable]\npublic class GameData\n{\n    public int level;\n    public float health;\n    public int score;\n    public string saveTime;\n}\n\npublic class PlayerLevelUpEvent\n{\n    public int NewLevel { get; set; }\n}\n\npublic class PlayerHealthChangedEvent\n{\n    public float NewHealth { get; set; }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#dip-的优势","level":3,"title":"DIP 的优势","text":"<ol> <li>降低耦合度：高层模块不直接依赖低层实现</li> <li>提高灵活性：可以轻松替换不同的实现</li> <li>便于测试：可以轻松模拟依赖的服务</li> <li>易于扔展：添加新的实现无需修改高层代码</li> </ol> <p>Odin Inspector 的 DIP 支持</p> <ul> <li>使用 <code>[ShowInInspector]</code> 显示注入的依赖服务<ul> <li>使用 <code>[Button]</code> 提供服务测试功能</li> <li>使用 <code>[ReadOnly]</code> 防止意外修改注入的服务</li> <li>使用 <code>[Title]</code> 组织不同类型的依赖关系</li> </ul> </li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#unity-实战应用案例角色系统重构","level":2,"title":"Unity 实战应用案例：角色系统重构","text":"<p>让我们通过一个完整的案例来看看如何将 SOLID 原则应用到 Unity 项目中。我们将重构一个传统的角色系统，使其遵循所有 SOLID 原则。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#原始设计违反-solid-原则","level":3,"title":"原始设计：违反 SOLID 原则","text":"<p>这是一个典型的“神类”设计：</p> <pre><code>// ❌ 违反多个 SOLID 原则的角色系统\npublic class BadCharacter : MonoBehaviour\n{\n    // 违反 SRP：一个类承担太多职责\n    public float health = 100f;\n    public float maxHealth = 100f;\n    public float moveSpeed = 5f;\n    public float attackDamage = 25f;\n    public float attackRange = 2f;\n    public string[] inventory = new string[10];\n    public int level = 1;\n    public int experience = 0;\n\n    // 各种系统混在一起\n    void Update()\n    {\n        HandleMovement();\n        HandleCombat();\n        HandleLevelUp();\n        UpdateUI();\n        HandleInventory();\n    }\n\n    // 违反 OCP：添加新角色类型需要修改这个方法\n    void HandleMovement()\n    {\n        // 处理不同类型的移动\n        if (gameObject.name.Contains(\"Warrior\"))\n        {\n            // 战士移动逻辑\n        }\n        else if (gameObject.name.Contains(\"Mage\"))\n        {\n            // 法师移动逻辑\n        }\n        // ... 更多类型\n    }\n\n    // 其他方法...\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#重构后遵循-solid-原则的设计","level":3,"title":"重构后：遵循 SOLID 原则的设计","text":"<p>让我们将这个系统重构为遵循 SOLID 原则的架构。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#1-应用-srp职责分离","level":4,"title":"1. 应用 SRP：职责分离","text":"<pre><code>// ✅ 健康系统（单一职责）\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class HealthSystem : MonoBehaviour\n{\n    [Title(\"健康配置\")]\n    [SerializeField, Range(1, 1000)] private float maxHealth = 100f;\n    [SerializeField] private bool regenerateHealth = true;\n    [SerializeField, ShowIf(\"regenerateHealth\")] private float regenRate = 5f;\n\n    [ShowInInspector, ReadOnly, ProgressBar(0, \"maxHealth\", ColorGetter = \"GetHealthColor\")]\n    private float currentHealth;\n\n    [Title(\"事件\")]\n    public UnityEvent&lt;float&gt; OnHealthChanged;\n    public UnityEvent&lt;float, float&gt; OnDamageTaken; // damage, remaining health\n    public UnityEvent OnDeath;\n    public UnityEvent OnFullyHealed;\n\n    public float CurrentHealth =&gt; currentHealth;\n    public float MaxHealth =&gt; maxHealth;\n    public float HealthPercentage =&gt; currentHealth / maxHealth;\n    public bool IsAlive =&gt; currentHealth &gt; 0;\n    public bool IsAtFullHealth =&gt; Mathf.Approximately(currentHealth, maxHealth);\n\n    void Start()\n    {\n        currentHealth = maxHealth;\n    }\n\n    void Update()\n    {\n        if (regenerateHealth &amp;&amp; !IsAtFullHealth &amp;&amp; IsAlive)\n        {\n            Heal(regenRate * Time.deltaTime);\n        }\n    }\n\n    public void TakeDamage(float damage)\n    {\n        if (!IsAlive || damage &lt;= 0) return;\n\n        float previousHealth = currentHealth;\n        currentHealth = Mathf.Max(0, currentHealth - damage);\n\n        OnHealthChanged?.Invoke(currentHealth);\n        OnDamageTaken?.Invoke(damage, currentHealth);\n\n        if (!IsAlive)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n\n    public void Heal(float amount)\n    {\n        if (!IsAlive || amount &lt;= 0 || IsAtFullHealth) return;\n\n        currentHealth = Mathf.Min(maxHealth, currentHealth + amount);\n        OnHealthChanged?.Invoke(currentHealth);\n\n        if (IsAtFullHealth)\n        {\n            OnFullyHealed?.Invoke();\n        }\n    }\n\n    public void SetMaxHealth(float newMaxHealth)\n    {\n        float ratio = HealthPercentage;\n        maxHealth = Mathf.Max(1, newMaxHealth);\n        currentHealth = maxHealth * ratio;\n        OnHealthChanged?.Invoke(currentHealth);\n    }\n\n    private Color GetHealthColor()\n    {\n        float percentage = HealthPercentage;\n        if (percentage &gt; 0.6f) return Color.green;\n        if (percentage &gt; 0.3f) return Color.yellow;\n        return Color.red;\n    }\n}\n\n// ✅ 经验系统（单一职责）\npublic class ExperienceSystem : MonoBehaviour\n{\n    [Title(\"经验配置\")]\n    [SerializeField] private int currentLevel = 1;\n    [SerializeField] private int currentExperience = 0;\n    [SerializeField] private int baseExperienceToNext = 100;\n    [SerializeField, Range(1.1f, 2f)] private float experienceMultiplier = 1.5f;\n\n    [ShowInInspector, ReadOnly]\n    private int experienceToNextLevel;\n\n    [Title(\"事件\")]\n    public UnityEvent&lt;int&gt; OnLevelUp;\n    public UnityEvent&lt;int&gt; OnExperienceGained;\n\n    public int Level =&gt; currentLevel;\n    public int Experience =&gt; currentExperience;\n    public int ExperienceToNext =&gt; experienceToNextLevel;\n    public float ExperienceProgress =&gt; (float)currentExperience / experienceToNextLevel;\n\n    void Start()\n    {\n        CalculateExperienceToNext();\n    }\n\n    public void GainExperience(int amount)\n    {\n        if (amount &lt;= 0) return;\n\n        currentExperience += amount;\n        OnExperienceGained?.Invoke(amount);\n\n        while (currentExperience &gt;= experienceToNextLevel)\n        {\n            LevelUp();\n        }\n    }\n\n    void LevelUp()\n    {\n        currentExperience -= experienceToNextLevel;\n        currentLevel++;\n        CalculateExperienceToNext();\n        OnLevelUp?.Invoke(currentLevel);\n    }\n\n    void CalculateExperienceToNext()\n    {\n        experienceToNextLevel = Mathf.RoundToInt(baseExperienceToNext * Mathf.Pow(experienceMultiplier, currentLevel - 1));\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#2-应用-ocp角色类型的可扩展设计","level":4,"title":"2. 应用 OCP：角色类型的可扩展设计","text":"<pre><code>// ✅ 角色能力接口（对扩展开放）\npublic interface IMoveable\n{\n    float MoveSpeed { get; set; }\n    void Move(Vector3 direction);\n    void Stop();\n}\n\npublic interface IAttacker\n{\n    float AttackDamage { get; }\n    float AttackRange { get; }\n    void Attack(GameObject target);\n    bool CanAttack(GameObject target);\n}\n\npublic interface ICaster\n{\n    float ManaPoints { get; }\n    float MaxMana { get; }\n    void CastSpell(string spellName, Vector3 target);\n    bool HasEnoughMana(float cost);\n}\n\n// ✅ 基础角色类定义抽象行为\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic abstract class Character : MonoBehaviour\n{\n    [Title(\"角色基础信息\")]\n    [SerializeField] protected string characterName;\n    [SerializeField] protected int characterLevel = 1;\n\n    [Title(\"组件引用\")]\n    [SerializeField, Required] protected HealthSystem healthSystem;\n    [SerializeField, Required] protected ExperienceSystem experienceSystem;\n\n    [ShowInInspector, ReadOnly]\n    public string CharacterName =&gt; characterName;\n\n    [ShowInInspector, ReadOnly]\n    public int Level =&gt; experienceSystem ? experienceSystem.Level : characterLevel;\n\n    protected virtual void Start()\n    {\n        InitializeCharacter();\n        SetupEventListeners();\n    }\n\n    protected virtual void InitializeCharacter()\n    {\n        if (string.IsNullOrEmpty(characterName))\n            characterName = GetType().Name;\n    }\n\n    protected virtual void SetupEventListeners()\n    {\n        if (healthSystem != null)\n        {\n            healthSystem.OnDeath.AddListener(OnCharacterDeath);\n        }\n\n        if (experienceSystem != null)\n        {\n            experienceSystem.OnLevelUp.AddListener(OnCharacterLevelUp);\n        }\n    }\n\n    protected virtual void OnCharacterDeath()\n    {\n        Debug.Log($\"{characterName} 已死亡\");\n    }\n\n    protected virtual void OnCharacterLevelUp(int newLevel)\n    {\n        Debug.Log($\"{characterName} 升级到 {newLevel} 级！\");\n    }\n\n    protected virtual void OnDestroy()\n    {\n        if (healthSystem != null)\n        {\n            healthSystem.OnDeath.RemoveListener(OnCharacterDeath);\n        }\n\n        if (experienceSystem != null)\n        {\n            experienceSystem.OnLevelUp.RemoveListener(OnCharacterLevelUp);\n        }\n    }\n}\n\n// ✅ 战士类：扩展而非修改\npublic class Warrior : Character, IMoveable, IAttacker\n{\n    [Title(\"战士属性\")]\n    [SerializeField, Range(1, 20)] private float moveSpeed = 5f;\n    [SerializeField, Range(10, 100)] private float attackDamage = 30f;\n    [SerializeField, Range(1, 5)] private float attackRange = 2.5f;\n    [SerializeField, Range(0.5f, 3f)] private float attackCooldown = 1.2f;\n\n    private float lastAttackTime;\n\n    public float MoveSpeed \n    { \n        get =&gt; moveSpeed; \n        set =&gt; moveSpeed = Mathf.Max(0, value); \n    }\n\n    public float AttackDamage =&gt; attackDamage;\n    public float AttackRange =&gt; attackRange;\n\n    public void Move(Vector3 direction)\n    {\n        if (healthSystem &amp;&amp; healthSystem.IsAlive)\n        {\n            transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n        }\n    }\n\n    public void Stop()\n    {\n        // 停止移动逻辑\n    }\n\n    public bool CanAttack(GameObject target)\n    {\n        if (!healthSystem || !healthSystem.IsAlive) return false;\n        if (Time.time &lt; lastAttackTime + attackCooldown) return false;\n\n        float distance = Vector3.Distance(transform.position, target.transform.position);\n        return distance &lt;= attackRange;\n    }\n\n    public void Attack(GameObject target)\n    {\n        if (!CanAttack(target)) return;\n\n        var targetHealth = target.GetComponent&lt;HealthSystem&gt;();\n        if (targetHealth != null)\n        {\n            targetHealth.TakeDamage(attackDamage);\n            lastAttackTime = Time.time;\n            Debug.Log($\"{characterName} 攻击了 {target.name}，造成 {attackDamage} 点伤害\");\n        }\n    }\n}\n\n// ✅ 法师类：新的角色类型，无需修改现有代码\npublic class Mage : Character, IMoveable, ICaster\n{\n    [Title(\"法师属性\")]\n    [SerializeField, Range(1, 15)] private float moveSpeed = 3f;\n    [SerializeField, Range(20, 200)] private float maxMana = 100f;\n    [SerializeField, Range(1, 10)] private float manaRegenRate = 5f;\n\n    [ShowInInspector, ReadOnly, ProgressBar(0, \"maxMana\", r: 0.2f, g: 0.5f, b: 1f)]\n    private float currentMana;\n\n    public float MoveSpeed \n    { \n        get =&gt; moveSpeed; \n        set =&gt; moveSpeed = Mathf.Max(0, value); \n    }\n\n    public float ManaPoints =&gt; currentMana;\n    public float MaxMana =&gt; maxMana;\n\n    protected override void Start()\n    {\n        base.Start();\n        currentMana = maxMana;\n    }\n\n    void Update()\n    {\n        RegenerateMana();\n    }\n\n    public void Move(Vector3 direction)\n    {\n        if (healthSystem &amp;&amp; healthSystem.IsAlive)\n        {\n            transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n        }\n    }\n\n    public bool HasEnoughMana(float cost)\n    {\n        return currentMana &gt;= cost;\n    }\n\n    public void CastSpell(string spellName, Vector3 target)\n    {\n        float manaCost = GetSpellCost(spellName);\n        if (!HasEnoughMana(manaCost)) return;\n\n        currentMana -= manaCost;\n\n        switch (spellName.ToLower())\n        {\n            case \"fireball\":\n                CastFireball(target);\n                break;\n            case \"heal\":\n                CastHeal();\n                break;\n            default:\n                Debug.LogWarning($\"未知法术: {spellName}\");\n                break;\n        }\n    }\n\n    void RegenerateMana()\n    {\n        if (currentMana &lt; maxMana)\n        {\n            currentMana = Mathf.Min(maxMana, currentMana + manaRegenRate * Time.deltaTime);\n        }\n    }\n\n    float GetSpellCost(string spellName)\n    {\n        return spellName.ToLower() switch\n        {\n            \"fireball\" =&gt; 20f,\n            \"heal\" =&gt; 30f,\n            _ =&gt; 10f\n        };\n    }\n\n    void CastFireball(Vector3 target)\n    {\n        Debug.Log($\"{characterName} 释放了火球术！\");\n        // 火球法术逻辑\n    }\n\n    void CastHeal()\n    {\n        if (healthSystem != null)\n        {\n            healthSystem.Heal(50f);\n            Debug.Log($\"{characterName} 使用了治疗法术！\");\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#3-应用-lsp-和-isp正确的继承和接口设计","level":4,"title":"3. 应用 LSP 和 ISP：正确的继承和接口设计","text":"<pre><code>// ✅ 遵循 LSP：所有子类都可以替换基类\n// 遵循 ISP：接口精简且不强制依赖\n\npublic class CharacterManager : MonoBehaviour\n{\n    [Title(\"角色管理\")]\n    [SerializeField] private Character[] allCharacters;\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;IMoveable&gt; moveableCharacters = new List&lt;IMoveable&gt;();\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;IAttacker&gt; attackerCharacters = new List&lt;IAttacker&gt;();\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;ICaster&gt; casterCharacters = new List&lt;ICaster&gt;();\n\n    void Start()\n    {\n        CategorizeCharacters();\n    }\n\n    void CategorizeCharacters()\n    {\n        moveableCharacters.Clear();\n        attackerCharacters.Clear();\n        casterCharacters.Clear();\n\n        foreach (var character in allCharacters)\n        {\n            if (character is IMoveable moveable)\n                moveableCharacters.Add(moveable);\n\n            if (character is IAttacker attacker)\n                attackerCharacters.Add(attacker);\n\n            if (character is ICaster caster)\n                casterCharacters.Add(caster);\n        }\n    }\n\n    [Button(\"所有角色向前移动\")]\n    public void MoveAllCharactersForward()\n    {\n        foreach (var moveable in moveableCharacters)\n        {\n            moveable.Move(Vector3.forward);\n        }\n    }\n\n    [Button(\"所有攻击型角色攻击目标\")]\n    public void AllAttackersAttackTarget()\n    {\n        GameObject target = GameObject.FindWithTag(\"Enemy\");\n        if (target != null)\n        {\n            foreach (var attacker in attackerCharacters)\n            {\n                attacker.Attack(target);\n            }\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#总结","level":2,"title":"总结","text":"<p>SOLID 原则是建设高质量 Unity 项目的基石。通过本文的学习，你应该掌握了：</p> <ul> <li>SOLID 五大原则的核心概念和实用方法</li> <li>在 Unity 中的具体应用，从简单的组件分离到复杂的架构设计</li> <li>Odin Inspector 的强大支持，提升开发效率和代码质量</li> <li>实战经验和最佳实践，避免常见陷阱</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#下一步学习建议","level":3,"title":"下一步学习建议","text":"<ol> <li>实践练习：找一个小项目尝试应用所学原则</li> <li>深入学习：研究设计模式如何体现 SOLID 原则</li> <li>工具掌握：学习更多 Odin Inspector 高级特性</li> <li>团队分享：将所学知识分享给团队成员</li> </ol>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/CSharp-SOLID/#参考资源","level":3,"title":"参考资源","text":"<ul> <li>Unity 官方文档</li> <li>Odin Inspector 文档</li> <li>Unity 官方 Clean Code 电子书：C# 代码风格指南</li> <li>Unity 官方设计模式和 SOLID 原则电子书</li> <li>Martin Fowler 的设计文章</li> </ul> <p>希望这篇文章能帮助你在 Unity 开发中更好地应用 SOLID 原则！如果你有任何问题或建议，欢迎在评论区交流讨论。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Information/CHANGELOG/","level":1,"title":"CHANGELOG","text":"<p>这个项目的所有显著变化都将记录在这个文件中。</p> <p>格式基于 Keep a Changelog，以及这个项目尽量遵循 Semantic Versioning。</p> <p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog,and this project adheres to Semantic Versioning.</p>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#052---alpha---2025-11-12","level":2,"title":"[0.5.2 - alpha] - 2025-11-12","text":"","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#fixed","level":3,"title":"Fixed","text":"<ul> <li>修复中文 API 文档生成设置中，接口的类型种类的字符串中包含 <code>abstract</code> 关键字的问题。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#051---alpha---2025-11-11","level":2,"title":"[0.5.1 - alpha] - 2025-11-11","text":"","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added","level":3,"title":"Added","text":"<ul> <li>新增 TypeData 完整解析 <code>ReferenceLinkURLAttribute</code> 处理。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#fixed_1","level":3,"title":"Fixed","text":"<ul> <li>修复 Script Doc Generator 生成文档目标文件夹不支持绝对路径的问题。</li> <li>修复 Script Doc Generator 生成文档时，文档编码格式默认使用 UTF-8 with BOM 的问题，此问题曾导致文档的首个标题在特定情况下渲染异常。</li> <li>修复因移除实例成员的自定义默认值解析而出现的单元测试问题。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#050---alpha---2025-11-10","level":2,"title":"[0.5.0 - alpha] - 2025-11-10","text":"<ul> <li>Alpha 阶段不保证向前兼容性。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#核心架构","level":3,"title":"核心架构","text":"","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed","level":4,"title":"Changed","text":"<ul> <li>优化插件结构，设置一级模块和二级模块概念，突出重要模块，一级模块位于 OdinToolkits 文件夹下，二级模块位于 OdinToolkits/Modules 文件夹下。</li> <li>移动 Community 模块，文件路径和 OdinToolkits 同级，将发布两个版本的 UnityPackage，一个包含 Community 模块，一个不包含 Community 模块。修正依赖关系，Community 依赖 OdinToolkits 集成模块，没有循环依赖。因此 OdinToolkits 集成模块可以独立使用。</li> <li>更新项目 Unity 版本为 2021.3.45f2c1</li> <li>修改 <code>AttributeOverviewPro</code> 为一级模块，位于 OdinToolkits 文件夹下。</li> <li>修改 <code>ChineseSummaryAttribute</code> 为 <code>SummaryAttribute</code>，不考虑同时存在中文和英文的注释特性情况，只有一个 Summary 注释。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#script-doc-generator-脚本文档生成器","level":3,"title":"Script Doc Generator 脚本文档生成器","text":"","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_1","level":4,"title":"Added","text":"<ul> <li>新增 <code>MemberData</code>、<code>TypeData</code>、<code>ConstructorData</code>、<code>EventData</code>、<code>MethodData</code>、<code>ParameterData</code>、<code>PropertyData</code>、<code>FieldData</code> 类，用于存储成员的解析数据，与 C# 反射相关的类一一对应。其中 <code>MethodData</code> 类不包含构造方法。</li> <li>新增 TypeAnalyzer 类型解析器的类的单元测试，共 143 个测试用例，其中 <code>TypeData</code> 14 个，<code>ConstructorData</code> 2 个，<code>EventData</code> 6 个，<code>MethodData</code> 23 个，<code>PropertyData</code>  13 个，<code>FieldData</code> 85 个，基本覆盖大部分类型解析情况。</li> <li>新增 <code>IsFromInheritance(this MemberInfo memberInfo)</code> 方法的单元测试，一共 4 个测试用例，确保方法可以正确判断成员是否来自继承关系。</li> <li>新增 <code>DocGeneratorSettingSO</code> 的设置字段，包括是否生成命名空间文件夹，是否自定义文档扩展名，是否自动生成增量标识符。增加了文档生成的灵活性，可以根据需要自定义文档的组织方式和文件名。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_1","level":4,"title":"Changed","text":"<ul> <li>遵循 SOLID 原则，使用工厂模式，优化代码结构，增强代码结构扩展性，但是增加了代码冗余，可以作为工厂模式参考的示例。</li> <li>修改部分脚本命名。</li> <li>补充部分脚本注释。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#removed","level":4,"title":"Removed","text":"<ul> <li>移除解析实例成员的自定义默认值，仅支持静态、常量默认值。实例成员的默认值可以从构造函数中初始化，也可以硬编码在类中。实际源代码中，可能存在多个构造函数，仅能部分特定实例成员的自定义默认值，避免文档造成误导，因此移除所有实例成员的自定义默认值解析。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#040---alpha---2025-09-21","level":2,"title":"[0.4.0 - alpha] - 2025-09-21","text":"<ul> <li>Alpha 阶段不保证兼容性，内容随时可能修改。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#已知问题","level":3,"title":"已知问题","text":"<ul> <li><code>Attribute Overview Pro</code> 处于重制阶段（其原模块为 <code>Chinese Attribute Overview</code>），当前仍存在错误；但该错误仅属于展示层面问题，大部分特性正常显示，不影响其他未报错内容，且不影响打包流程</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_2","level":3,"title":"Changed","text":"<ul> <li>优化代码架构，更新版本需要重新导入</li> <li>移动 <code>Wigdet</code> 部分到 <code>YuumixEditor</code> 中，重命名为 <code>InspectorWigdet</code>，设计为仅限编辑器阶段使用，打包后剔除，需要使用 <code>UNITY_EDITOR</code> 宏定义包裹</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_2","level":3,"title":"Added","text":"<ul> <li>新增 <code>InspectorBiligualismConfigSO</code>，设置面板语言，提供 <code>OnLanguageChange</code> 事件接口</li> <li>新增 <code>OdinToolkits</code> 文件夹定位接口，<code>OdinToolkitsPaths.GetRootPath()</code> 可以获取到 <code>OdinToolkits</code> 文件夹的相对路径，默认为 <code>\"Assets/Plugins/Yuumix/OdinToolkits\"</code></li> <li>新增 <code>Add ChineseSummary</code> 和 <code>Remove ChineseSummary</code> 右键菜单项，可以一键同步脚本中的 <code>Summary</code> 注释到 <code>ChineseSummary</code> 特性，同时提供一键移除操作，在不需要时可以快速脱离，不影响项目</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#重要更新---script-doc-generator-脚本文档生成器","level":3,"title":"重要更新 - Script Doc Generator 脚本文档生成器","text":"","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_3","level":4,"title":"Changed","text":"<ul> <li>升级为独立模块，重构代码逻辑和用户 UI 界面</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_3","level":4,"title":"Added","text":"<ul> <li>新增 <code>ChineseSummaryAttribute</code> 特性，用于替代 XML 的 Summary 注释，将内容作为元数据标记到成员中，使得反射可以获取</li> <li>新增支持分析公共实例构造函数、非构造方法、运算符重载方法、属性、事件及字段</li> <li>新增支持分析目标程序集中的类型并生成文档</li> <li>新增 <code>Test</code> 文件夹，经手动测试，可以支持相当多的脚本内容分析。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#fixed_2","level":4,"title":"Fixed","text":"<ul> <li>修复在中文 API 文档生成器中，方法在高层级基类（不限层级，如祖父类及以上）声明、在下层基类（不限层级）重写时未被正确归纳至继承方法列表的问题</li> <li>修复在方法分析数据中，接口声明的方法在当前类实现时，代码逻辑中并不存在 override 关键字，而方法声明字符串中错误显示 override 的问题</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#community-社区模块","level":3,"title":"Community 社区模块","text":"","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_4","level":4,"title":"Added","text":"<ul> <li>新增 <code>ResolvedParametersOverviewCardSO</code> 卡片案例，为纯 <code>Editor</code> 模块</li> <li>新增 <code>SwitchButtonAttributeCardSO</code> 卡片案例，包含 <code>Runtime</code> 和 <code>Editor</code> 两部分</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#033---alpha---2025-08-17","level":2,"title":"[0.3.3 - alpha] - 2025-08-17","text":"<ul> <li>Alpha 阶段不保证兼容性，内容随时可能修改。</li> <li>目前 <code>v0.3.3 - alpha</code> 已经可以支持基础功能运行，具体查看 Odin Toolkits For Unity</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#013beta---2025-05-21","level":2,"title":"[0.1.3.beta] - 2025-05-21","text":"<ul> <li>Beta 阶段不保证向前兼容，删除旧版本再导入</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_5","level":3,"title":"Added","text":"<ul> <li>新增 <code>SwitchButtonAttribute</code>，将 <code>bool</code> 显示为开关，兼容 <code>ToggleLeftAttribute</code> 特性 - 修改自 <code>Schwapo</code> 开源项目</li> <li>新增 <code>Singleton</code> 单例模块</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_4","level":3,"title":"Changed","text":"<ul> <li>完善生成模板代码工具 <code>GenerateTemplateCode</code>，并完善 <code>OdinToolkits</code> 文档网站信息</li> <li>调整菜单路径</li> <li>调整 <code>OdinToolkits</code> 文件夹定位，支持 <code>OdinToolkits</code> 文件夹整体移动</li> <li>调整 <code>Common</code> 文件夹</li> <li>完善 <code>QuickGenerateSO</code> 文档信息</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#removed_1","level":3,"title":"Removed","text":"<ul> <li><code>ComponentBinder</code>，组件绑定工具，在项目中并未完善，无法使用</li> <li>移除 <code>OdinToolkits</code> 编辑器配置，未修改完善</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#012beta---2025-05-09","level":2,"title":"[0.1.2.beta] - 2025-05-09","text":"","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_5","level":3,"title":"Changed","text":"<ul> <li>Beta 阶段不向前兼容</li> <li>重新设计项目结构，根目录为 Plugins/Yuumix/OdinToolkits，将 SO 框架移至 OdinToolkits 文件夹内。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#011---2025-04-28","level":2,"title":"[0.1.1] - 2025-04-28","text":"","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_6","level":3,"title":"Added","text":"<ul> <li>新增两个第三方引用，位于 ThirdParty 文件夹，包括一个 Odin 相关开源库 和一个 Log相关免费资源</li> <li>新增 Odin 自带特性解析手册，中文解析 Odin 默认提供的 Attributes，比官方的手册更适合中文开发者。</li> <li>新增模版代码生成工具</li> <li>新增 ComponentBinder ，组件绑定工具</li> <li>新增 OdinToolkits 编辑器配置</li> <li>新增自定义扩展 Odin Attribute</li> <li>新增提取 Odin Syntax Highlight 资源文件，让 Odin 的语法高亮为开发者所用</li> <li>新增通用模块 Common，一些跨项目通用类，方法</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#010---2025-04-21","level":2,"title":"[0.1.0] - 2025-04-21","text":"","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_7","level":3,"title":"Added","text":"<ul> <li>新增一个简单工具，QuickGenerateSO - 快速右键生成 SO 资源，自动遍历选择的资源，根据继承了 <code>ScriptableObject</code> 的脚本，生成 SO 资源。</li> </ul>","path":["Info","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CONTRIBUTING/","level":1,"title":"CONTRIBUTING","text":"<p>[正在编写中...]</p>","path":["CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#community-社区模块贡献指南","level":2,"title":"<code>Community</code> 社区模块贡献指南","text":"","path":["CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#贡献规范","level":3,"title":"贡献规范","text":"<ol> <li>尽量以单个文件夹的形式贡献</li> <li>在用户不使用的情况下，不能影响运行逻辑，不影响其他模块的正常使用。可以有后台自动运行的实例，比如场景单例。</li> <li>删除相关文件夹不报错，不会导致项目运行时错误。</li> <li>编辑器扩展方面尽量使用 <code>Odin Inspector</code>，可以给其他开发者参考，学习 <code>Odin Inspector</code> 的使用。</li> <li>Community 模块的代码样式无要求，选择你喜欢的方式。</li> <li>只包含 <code>OdinToolkits</code> 的新项目打包无警告或错误。</li> <li>静态变量要求兼容 <code>Play Mode</code>，在禁止域重新加载时不出错，下文包含示例。</li> </ol>","path":["CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#静态变量兼容-play-mode-示例","level":3,"title":"静态变量兼容 <code>Play Mode</code> 示例","text":"<pre><code>#if UNITY_EDITOR  \n\n        #region 兼容 [禁用域重新加载]  \n\n        [InitializeOnLoadMethod]  \n        static void Initialize()  \n        {            \n            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;  \n            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;  \n        }\n\n        static void OnPlayModeStateChanged(PlayModeStateChange state)  \n        {            \n            if (state == PlayModeStateChange.EnteredPlayMode)  \n            {                \n                OnLanguageChange = null;  \n            }        \n        }  \n\n        #endregion  \n\n#endif\n</code></pre>","path":["CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#modules-核心模块贡献","level":2,"title":"<code>Modules</code> 核心模块贡献","text":"<p>待补充...</p>","path":["CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#core-核心部分贡献","level":2,"title":"<code>Core</code> 核心部分贡献","text":"<p>待补充...</p> <p>如贡献 <code>Core</code> 或 <code>Module</code> 模块，请参考 <code>Core/Editor/Misc/OdinToolkitsCodeStyleExample.cs</code> 代码样式文件。</p>","path":["CONTRIBUTING"],"tags":[]},{"location":"Information/LICENSE/","level":1,"title":"The MIT License (MIT)","text":"<p>Copyright (c) 2025 Yuumix and contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software<sup>1</sup>.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p>现特此授予任何获取本软件及相关文档文件（以下简称“软件”）的人士免费使用该软件的权限，且不受任何限制，包括但不限于使用、复制、修改、合并、发布、分发、转授许可以及/或出售该软件的权利，以及允许因使用该软件而获得该软件的人进行上述操作的权限，但需遵守以下条件：</p> <p>上述版权声明以及本许可声明应包含在所有副本或软件的实质性内容中。</p> <p>该软件“按原样”提供，不提供任何形式的保证，包括但不限于关于其性能、适用性以及不侵犯版权的保证。在任何情况下，作者或版权持有者均不承担任何因该软件或其使用而引起的任何索赔、损害赔偿或其他责任，无论是基于合同、侵权还是其他原因。</p> <ol> <li> <p>在基于 Odin Toolkits 进行修改或衍生的 Unity 插件中应包含本许可声明。 ↩</p> </li> </ol>","path":["Info","The MIT License (MIT)"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/","level":1,"title":"Logo 图标许可证声明","text":"","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#基本信息","level":2,"title":"基本信息","text":"项目 详情 项目名称 Odin Toolkits Logo Logo 设计者 Yuumix 创建日期 2025年 版权归属 Yuumix 许可证 MIT License","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#logo-设计详情","level":2,"title":"Logo 设计详情","text":"","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#设计工具与来源","level":3,"title":"设计工具与来源","text":"<ul> <li>设计工具: ShipFast LogoFast</li> <li>图标来源: Lucide Icons - <code>Webhook</code> 图标</li> <li>图标许可证: ISC License (开源友好)</li> <li>设计方式: 在线工具生成 + 自定义样式配置</li> </ul>","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#设计参数配置","level":3,"title":"设计参数配置","text":"","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#图标设置","level":4,"title":"图标设置","text":"参数 数值 图标名称 Webhook 尺寸 350px 旋转角度 180° 边框宽度 2.5px 主体颜色 <code>#333333</code>","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#背景设计","level":4,"title":"背景设计","text":"参数 数值 圆角 120px 内边距 100px 渐变角度 45° 左下角色 <code>#ff3802</code> 中间过渡 纯白色 (60%位置) 右上角色 <code>#0095ff</code>","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#颜色方案","level":3,"title":"颜色方案","text":"","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#全彩版本","level":4,"title":"全彩版本","text":"<pre><code>/* 主图标颜色 */\n.logo-icon {\n  color: #333333; /* 深灰色 */\n  border: 2.5px solid #333333;\n}\n\n/* 背景渐变 */\n.logo-background {\n  background: linear-gradient(45deg, \n    #ff3802 0%,     /* 橙红色 */\n    #ffffff 60%,    /* 白色过渡 */\n    #0095ff 100%    /* 深蓝色 */\n  );\n  border-radius: 120px;\n  padding: 100px;\n}\n</code></pre>","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#许可证声明","level":2,"title":"许可证声明","text":"","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#logo-版权信息","level":3,"title":"Logo 版权信息","text":"<pre><code>Copyright (c) 2025 Yuumix\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this logo design and associated documentation files (the \"Logo\"), to deal\nin the Logo without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Logo, and to permit persons to whom the Logo is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Logo.\n\nTHE LOGO IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE LOGO OR THE USE OR OTHER DEALINGS IN THE\nLOGO.\n</code></pre>","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#联系","level":2,"title":"联系","text":"<p>如有关于 Logo 使用的疑问，请联系：</p> <ul> <li>邮箱: zeriying@gmail.com</li> <li>项目地址: https://github.com/yuumixcode/OdinToolkits-For-Unity</li> <li>网站: https://www.odintoolkits.cn/</li> </ul>","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#致谢","level":2,"title":"致谢","text":"","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#lucide-icons-致谢","level":3,"title":"Lucide Icons 致谢","text":"<pre><code>本Logo使用了 Lucide Icons 项目中的 \"Webhook\" 图标\n\n- 项目地址: https://lucide.dev/\n- 许可证: ISC License\n- 版权: Lucide Contributors\n- 使用方式: 经过旋转和样式定制后集成到 Logo 设计中\n</code></pre>","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#设计工具致谢","level":3,"title":"设计工具致谢","text":"<pre><code>Logo 通过 ShipFast LogoFast 在线工具生成\n\n- 工具地址: https://shipfa.st/tools/logo-fast\n- 开发者: Marc Lou (Sirenix)\n- 性质: 免费在线设计工具\n- 生成内容版权归用户所有\n</code></pre>","path":["Info","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/ROADMAP/","level":1,"title":"ROADMAP","text":"<p>记录项目的发展方向和计划。</p>","path":["ROADMAP"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/","level":1,"title":"Quick Generate SO","text":"","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/#简介","level":2,"title":"简介","text":"<p>Quick Generate SO 是一个用于快速生成 ScriptableObject 资源的工具。</p>","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/#开始使用","level":2,"title":"开始使用","text":"<ol> <li>选择继承了 <code>ScriptableObject</code> 的脚本</li> <li>右键选择 <code>Create SO Asset From Selected</code></li> <li>在当前目录生成一个 SO 资源</li> </ol> <p>提示</p> <ol> <li>支持单选和多选。<ol> <li>单选 SO 脚本生成时可以立即设置文件名。</li> <li>多选 SO 脚本生成时将直接生成资源文件，使用默认命名。</li> </ol> </li> <li>只有当选择的资源中包含有继承 <code>ScriptableObject</code> 的脚本文件时才可以点击 <code>Create SO Asset From Selected</code>。</li> </ol>","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/#菜单项","level":2,"title":"菜单项","text":"","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/#已知限制","level":2,"title":"已知限制","text":"<p>Warning</p> <p>为确保准确，一个脚本文件中只包含一个 public 的 class，并且继承 <code>ScriptableObject</code>。 </p>","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/","level":1,"title":"Script Doc Generator 使用指南","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#简介","level":2,"title":"简介","text":"<p>Script Doc Generator 是 Odin Toolkits For Unity 的核心模块之一，快捷生成代码注释文档。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#核心特性","level":3,"title":"核心特性","text":"<ol> <li>支持单个类型、多个类型或整个程序集的文档批量生成。</li> <li>支持脚本文档增量生成，默认保留文档中 “## 额外说明” 后的内容，不覆盖生成。</li> <li>支持分析源代码中声明的类，以及类包含的构造函数、方法、事件、属性、字段。</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#开始使用","level":2,"title":"开始使用","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#源代码要求","level":3,"title":"源代码要求","text":"<p>Script Doc Generator 主要依靠 <code>Reflection</code> 反射。注释采用的是读取 <code>[Summary(\"xxx\")]</code> 的值的方案。因此，要求源代码中给需要生成注释的成员添加 <code>[Summary]</code> 。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#summaryprocessormenuitems","level":4,"title":"SummaryProcessorMenuItems","text":"<p>为了更方便地使用工具，设计了 <code>SummaryProcessorMenuItems</code> 右键菜单。</p> <p>提供了三个右键选项，当选择的资源中包含脚本文件时，可以选择执行。</p> <ol> <li>Sync SummaryAttribute。读取 XML 注释中的 <code>&lt;summary&gt;</code> 内容，添加<code>[Summary(\"xxx\")]</code> 特性到成员上方。</li> <li>Replace SummaryAttribute。读取 XML 注释中的 <code>&lt;summary&gt;</code> 内容，删除 XML 的 <code>&lt;summary&gt;</code> 内容，然后添加 <code>[Summary(\"xxx\")]</code> 特性到成员上方。</li> <li>Remove SummaryAttribute。移除选择的脚本源代码中的 <code>[Summary(\"xxx\")]</code> 特性。</li> </ol> <p></p> <p>为了正确添加 <code>[Summary]</code> 特性，在执行操作前，推荐使用 IDE 对代码进行格式化。最好设置为特性和成员永不在同一行，以 Rider 举例。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#打开工具面板","level":3,"title":"打开工具面板","text":"<p>通过 Unity 编辑器菜单打开：Tools/Odin Toolkits/Script Doc Generator。</p> <p></p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#设置文档保存路径","level":3,"title":"设置文档保存路径","text":"<p>在工具窗口的 “存放脚本文档的目标文件夹路径” 输入框中，设置文档导出根目录</p> <ul> <li>支持绝对路径输入</li> <li>支持拖拽文件夹到输入框快速设置</li> <li>若路径不存在，生成时会提示自动创建文件夹</li> </ul> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#文档生成器设置","level":3,"title":"文档生成器设置","text":"<p>默认提供中文 API 文档生成器 <code>CnAPIDocGeneratorSettingSO</code>，可生成包含中文注释的 Markdown 文档。</p> <p>如需自定义文档格式，声明一个继承自 <code>DocGeneratorSettingSO</code> 的类，实现 <code>GetGeneratedDoc</code> 方法，生成 SO 资源文件并更换文档生成设置资源文件。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#docgeneratorsettingso","level":4,"title":"DocGeneratorSettingSO","text":"<ol> <li>是否按命名空间生成文件夹</li> <li>是否使用自定义文档扩展名</li> <li>文档扩展名设置</li> <li>是否自动生成增量标识符</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#中文-api-脚本文档结构默认提供的-docgeneratorsettingso","level":4,"title":"中文 API 脚本文档结构（默认提供的 DocGeneratorSettingSO）","text":"<ol> <li>类型名</li> <li>类型类别（如 class、struct，是否静态 / 抽象）</li> <li>所在程序集</li> <li>命名空间</li> <li>类型声明代码（如 <code>public class TestClass : MonoBehaviour</code>）</li> <li>注释（读取源代码中的 SummaryAttribute 的值）</li> <li>构造方法表格形式展示公共实例构造函数的签名及注释。</li> <li>非构造方法按 “声明的普通方法”“继承的普通方法”“运算符特殊方法” 分类，展示方法签名、注释及声明类。</li> <li>事件按 “声明的事件”“继承的事件” 分类，展示事件名称及注释。</li> <li>属性按 “声明的属性”“继承的属性” 分类，展示属性签名及注释。</li> <li>字段按 “声明的字段”“继承的字段” 分类，展示字段签名及注释。</li> <li>额外说明标识符，持久保留在标识符后的自定义内容（增量生成时不覆盖）。</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#选择类型来源","level":3,"title":"选择类型来源","text":"<p>在 “类型来源” 选项中，选择需要生成文档的目标范围。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#singletype-单个目标类型","level":4,"title":"SingleType 单个目标类型","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#multipletypes-多个类型","level":4,"title":"MultipleTypes 多个类型","text":"<p>多类型模式有两种类型提供方式。</p> <p>第一种是 TypeCacheSO 资源，内部有一个类型列表，可以把多个类型的列表持久化存储，比如某个命名空间下的类，之后如果同时修改了多个类，那么可以直接使用这个资源文件，重新生成这些类的脚本文档。</p> <p>同时，在选择了 TypeCacheSO 资源后，临时的 Type 列表将会隐藏。</p> <p></p> <p>其中一种是临时的列表，逐个添加类型。</p> <p>提供了快捷生成 TypeCacheSO 的解决方案，首次添加列表后，点击保存为 SO 资源，可以一键把该临时列表存储到一个新的 TypeCacheSO 中去。</p> <p>另外，可以自定义新生成 TypeCacheSO 资源的文件夹，点击自定义资源存储位置，即可出现路径设置。点击完成设置后，将会隐藏。</p> <p></p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#singleassembly-单个程序集","level":4,"title":"SingleAssembly 单个程序集","text":"<p>单程序集和多类型模式本质一样，不过是选择程序集后，工具将会收集该程序集中包含的所有的类。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#分析类型","level":3,"title":"分析类型","text":"<p>点击按钮分析设置的 Type 类型。</p> <p>可以在类型分析数据结果中查看具体信息。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#生成文档","level":3,"title":"生成文档","text":"<p>在分析类型完成后，将会自动显示生成按钮，点击后，执行生成文档。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#singletype-单类型","level":4,"title":"SingleType 单类型","text":"<ol> <li>若目标类型已标记为 “过时”，会提示确认是否继续生成。</li> <li>生成文档后，自动用默认程序打开文档，并刷新 Unity 资源面板</li> <li>若目标路径已存在同名文档，会提示是否覆盖（覆盖时保留 “## 额外说明” 后的内容）</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#multipletypes-和-singleassembly","level":4,"title":"MultipleTypes 和 SingleAssembly","text":"<p>生成文档后，将自动打开存放文档的文件夹路径。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#文档结果预览","level":3,"title":"文档结果预览","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#rider-格式化设置推荐","level":3,"title":"Rider 格式化设置推荐","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#设置脚本文件布局","level":4,"title":"设置脚本文件布局","text":"<p>推荐使用带区域的默认值。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#快捷键","level":4,"title":"快捷键","text":"<p>InteliJ 默认快捷键：</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#macos","level":5,"title":"MacOS","text":"<p>Shift+Option+Cmd+L</p> <p>打开重新设置代码格式选择面板，没有自定义格式的话，选择完全清理即可。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#已知限制","level":3,"title":"已知限制","text":"<p>Warning</p> <ol> <li>不支持分析 <code>unsafe</code> 代码。</li> <li>不支持获取实例成员的默认值。</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#常见问题","level":3,"title":"常见问题","text":"<p>Q：生成的文档缺少某些成员？</p> <p>A：工具只解析公共构造函数，以及用户定义的成员，已经剔除程序集自动生成的成员。</p> <p>Q：如何自定义生成的脚本文档格式？</p> <p>A：声明一个继承自 <code>DocGeneratorSettingSO</code> 的类，实现 <code>GetGeneratedDoc</code> 方法，更换文档生成设置资源文件。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#推荐阅读","level":3,"title":"推荐阅读","text":"<ul> <li>ScriptDocGenerator 单元测试</li> </ul>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/SupportMemberOverview/","level":1,"title":"ScriptDocGenerator 支持的成员种类","text":"","path":["ScriptDocGenerator 支持的成员种类"],"tags":[]},{"location":"Manual/ScriptDocGenerator/SupportMemberOverview/#type","level":2,"title":"Type","text":"<ol> <li>类</li> <li>结构体</li> <li>枚举</li> <li>委托</li> <li>接口</li> <li>记录（Record）</li> </ol>","path":["ScriptDocGenerator 支持的成员种类"],"tags":[]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/","level":1,"title":"Script Doc Generator 单元测试","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#概述","level":2,"title":"概述","text":"<p>TypeAnalyzer 类型解析器单元测试，共 143 个测试用例，其中 <code>TypeData</code> 14 个，<code>ConstructorData</code> 2 个，<code>EventData</code> 6 个，<code>MethodData</code> 23 个，<code>PropertyData</code>  13 个，<code>FieldData</code> 85 个，基本覆盖大部分类型解析情况。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#typedata","level":2,"title":"<code>TypeData</code>","text":"<p><code>TypeData</code> 单元测试须知</p> <p>TypeData 一共有 14 个测试用例。</p> <p>类型解析支持包括 <code>class</code>、<code>struct</code>、<code>enum</code>、<code>interface</code>、<code>delegate</code>、<code>nested type</code>、<code>record</code>。</p> 14 个测试用例 No.1 - ITestInterface 源码声明<pre><code>public interface ITestInterface { }\n</code></pre> <p>解析结果<pre><code>public interface ITestInterface\n</code></pre> No.2 - TestAbstractClass 源码声明<pre><code>public abstract class TestAbstractClass { }\n</code></pre> 解析结果<pre><code>public abstract class TestAbstractClass\n</code></pre> No.3 - TestSealedClass 源码声明<pre><code>public sealed class TestSealedClass { }\n</code></pre> 解析结果<pre><code>public sealed class TestSealedClass\n</code></pre> No.4 - TestStaticClass 源码声明<pre><code>public static class TestStaticClass { }\n</code></pre> 解析结果<pre><code>public static class TestStaticClass\n</code></pre></p> <p>No.5 - TestGenericClass 源码声明<pre><code>public class TestGenericClass&lt;T&gt; where T : class\n{\n    public T Owner;\n}\n</code></pre> 解析结果<pre><code>public class TestGenericClass&lt;T&gt; where T : class\n</code></pre> No.6 - UnitTestTypes 源码声明<pre><code>public abstract class TestAbstractClass { }\n\npublic class UnitTestTypes : TestAbstractClass { }\n</code></pre> 解析结果<pre><code>public class UnitTestTypes : Yuumix.OdinToolkits.Tests.Editor.TestAbstractClass\n</code></pre> No.7 - TestClassWithAttribute 源码声明<pre><code>[Summary(\"支持解析特性\")]\n[ReferenceLinkURL(\"https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-9.0\")]\npublic class TestClassWithAttribute { }\n</code></pre> 解析结果<pre><code>[ReferenceLinkURL(\"https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-9.0\")]\npublic class TestClassWithAttribute\n</code></pre> <p>No.8 - TestDelegate 源码声明<pre><code>public delegate void TestDelegate();\n</code></pre> 解析结果<pre><code>public delegate void TestDelegate()\n</code></pre></p> <p>No.9 - TestDelegateHasParameters 源码声明<pre><code>public delegate void TestDelegateHasParameters(int a, List&lt;string&gt; b);\n</code></pre> 解析结果<pre><code>public delegate void TestDelegateHasParameters(int a, List&lt;string&gt; b)\n</code></pre></p> <p>No.10 - TestDelegateHasReturnType 源码声明<pre><code>public delegate bool TestDelegateHasReturnType(float a, int[] b);\n</code></pre> 解析结果<pre><code>public delegate bool TestDelegateHasReturnType(float a, int[] b)\n</code></pre> No.11 - TestRecord 源码声明<pre><code>public record TestRecord;\n</code></pre> 解析结果<pre><code>[NullableContext(NullableContextOptions.flow)]\n[Nullable(NullableContextOptions.flow)]\npublic record TestRecord : System.IEquatable&lt;TestRecord&gt;\n</code></pre></p> <p>No.12 - TestStruct 源码声明<pre><code>public struct TestStruct { }\n</code></pre> 解析结果<pre><code>public struct TestStruct : System.ValueType\n</code></pre></p> No.13 - ScriptDocGeneratorTestEnum 源码声明<pre><code>public enum ScriptDocGeneratorTestEnum\n{\n    Value1,\n    Value2,\n    Value3\n}\n</code></pre> 解析结果<pre><code>public enum ScriptDocGeneratorTestEnum : System.Enum, \nSystem.IFormattable, \nSystem.IComparable, \nSystem.IConvertible\n</code></pre> No.14 - NestedClass 源码声明<pre><code>public class UnitTestTypes\n{\n    class NestedClass { }\n}\n</code></pre> 解析结果<pre><code>private class UnitTestTypes.NestedClass\n</code></pre>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#constructordata","level":2,"title":"<code>ConstructorData</code>","text":"<p><code>ConstructorData</code> 单元测试须知</p> <p><code>ConstructorData</code> 一共有 2 个测试用例。</p> <p>只解析公共实例构造方法。</p> <p>构造方法属于特殊的方法成员，部分可参考 <code>MethodData</code> 解析.</p> 2 个测试用例 源码声明<pre><code>public abstract class TestClassAbstract\n{\n    protected TestClassAbstract(int a) { }\n\n    protected TestClassAbstract() { }\n}\n\npublic class TestClass : TestClassAbstract\n{\n    public TestClass() { }\n\n    public TestClass(bool b, int a) : base(a) { }\n\n    TestClass(string s) { }\n}\n</code></pre> 解析后的构造方法完整签名 <code>public UnitTestConstructorsCommon.TestClass()</code> <code>public UnitTestConstructorsCommon.TestClass(bool b, int a)</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#eventdata","level":2,"title":"<code>EventData</code>","text":"<p><code>EventData</code> 单元测试须知</p> <p><code>EventData</code> 一共有 6 个测试用例。</p> <p>只解析使用 <code>event</code> 关键字声明的事件，简单委托属于字段。</p> <p>事件相当于在字段的声明中添加了 <code>event</code> 关键字，部分可参考 <code>FieldData</code> 解析.</p> 6 个测试用例 <pre><code>public event Action ActionEvent;\npublic event Action&lt;int, string&gt; ActionWithParamsEvent;\npublic event Func&lt;int, string, bool&gt; FuncWithParamsEvent;\npublic event Predicate&lt;int&gt; PredicateEvent;\npublic event Comparison&lt;string&gt; ComparisonEvent;\npublic static event Action&lt;bool&gt; StaticActionEvent;\n</code></pre> 解析后的事件完整签名 <code>public event Action ActionEvent;</code> <code>public event Action&lt;int, string&gt; ActionWithParamsEvent;</code> <code>public event Func&lt;int, string, bool&gt; FuncWithParamsEvent;</code> <code>public event Predicate&lt;int&gt; PredicateEvent;</code> <code>public event Comparison&lt;string&gt; ComparisonEvent;</code> <code>public static event Action&lt;bool&gt; StaticActionEvent;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#methoddata","level":2,"title":"<code>MethodData</code>","text":"<p><code>MethodData</code> 单元测试须知</p> <p><code>MethodData</code> 一共有 23 个测试用例。</p> <p><code>MethodData</code> 不包括构造函数，仅包括普通方法。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#非继承方法测试","level":3,"title":"非继承方法测试","text":"11 个测试用例 No.1 - EmptyParamMethod 方法源码声明<pre><code>public void EmptyParamMethod()\n{\n    Debug.Log(\"EmptyParamMethod\");\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void EmptyParamMethod\n完整方法签名：public void EmptyParamMethod()\n</code></pre> No.2 - OneIntParamMethod 方法源码声明<pre><code>public void OneIntParamMethod(int param)\n{\n    Debug.Log(param);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void OneIntParamMethod\n完整方法签名：public void OneIntParamMethod(int param)\n</code></pre> No.3 - TwoParamMethod 方法源码声明<pre><code>public void TwoParamMethod(string param1, bool param2)\n{\n    Debug.Log(param1 + param2);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void TwoParamMethod\n完整方法签名：public void TwoParamMethod(string param1, bool param2)\n</code></pre> No.4 - GenericMethod 方法源码声明<pre><code>public void GenericMethod&lt;T&gt;(T param)\n{\n    Debug.Log(param);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void GenericMethod&lt;T&gt;\n完整方法签名：public void GenericMethod&lt;T&gt;(T param)\n</code></pre> No.5 - TwoParamsGenericMethod 方法源码声明<pre><code>public void TwoParamsGenericMethod&lt;T, T1&gt;(T param1, List&lt;T1&gt; param2)\n{\n    Debug.Log(param1);\n    Debug.Log(param2);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void TwoParamsGenericMethod&lt;T, T1&gt;\n完整方法签名：public void TwoParamsGenericMethod&lt;T, T1&gt;(T param1, List&lt;T1&gt; param2)\n</code></pre> No.6 - IndefiniteParamsMethod 方法源码声明<pre><code>public void IndefiniteParamsMethod(string param1, params bool[] param2)\n{\n    Debug.Log(param1 + param2);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void IndefiniteParamsMethod\n完整方法签名：public void IndefiniteParamsMethod(string param1, params bool[] param2)\n</code></pre> No.7 - HasReturnStringMethod 方法源码声明<pre><code>public string HasReturnStringMethod(float param1)\n{\n    Debug.Log(param1);\n    return \"HasReturnStringMethod\";\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public string HasReturnStringMethod\n完整方法签名：public string HasReturnStringMethod(float param1)\n</code></pre> No.8 - StaticMethod 方法源码声明<pre><code>public static void StaticMethod()\n{\n    Debug.Log(\"StaticMethod\");\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public static void StaticMethod\n完整方法签名：public static void StaticMethod()\n</code></pre> No.9 - HasReturnBoolMethodWithDefault 方法源码声明<pre><code>public static bool HasReturnBoolMethodWithDefault(float param1 = 5f, bool param2 = false,\n    string param3 = \"Hello World\", int param4 = 0,\n    ScriptDocGeneratorTestEnum param5 = ScriptDocGeneratorTestEnum.Value3)\n{\n    Debug.Log(param3 + param4);\n    return true;\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public static bool HasReturnBoolMethodWithDefault\n完整方法签名：public static bool HasReturnBoolMethodWithDefault(float param1 = 5f, \nbool param2 = false, string param3 = \"Hello World\", int param4 = 0,\nScriptDocGeneratorTestEnum param5 = ScriptDocGeneratorTestEnum.Value3)\n</code></pre> No.10 - AsyncMethod 方法源码声明<pre><code>public static async Task AsyncMethod()\n{\n    await Task.Delay(1);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public static async Task AsyncMethod\n完整方法签名：public static async Task AsyncMethod()\n</code></pre> No.11 - AsyncMethodWithReturnValue 方法源码声明<pre><code>public async Task&lt;int&gt; AsyncMethodWithReturnValue()\n{\n    await Task.Delay(1);\n    return 42;\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public async Task&lt;int&gt; AsyncMethodWithReturnValue\n完整方法签名：public async Task&lt;int&gt; AsyncMethodWithReturnValue()\n</code></pre>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#继承接口方法测试","level":3,"title":"继承、接口方法测试","text":"4 个测试用例 <pre><code>public interface IInterface\n{\n    void InterfaceMethod();\n}\n\npublic abstract class TestClassAbstract\n{\n    public virtual void OverrideVirtualMethod() { }\n    public abstract void OverrideAbstractMethod();\n}\n\npublic class TestClassImplement : TestClassAbstract, IInterface\n{\n    public override void OverrideAbstractMethod() { }\n    public override void OverrideVirtualMethod() { \n    public void InterfaceMethod()\n    {\n        Debug.Log(\"InterfaceMethod\");\n    }\n}\n</code></pre> 解析后的方法完整签名 <code>public virtual void OverrideVirtualMethod()</code> <code>public override void OverrideAbstractMethod()</code> <code>public override void OverrideVirtualMethod()</code> <code>public void InterfaceMethod()</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#运算符方法测试","level":3,"title":"运算符方法测试","text":"7 个测试用例 <pre><code>public static TestClass operator +(TestClass a, TestClass b) =&gt; new TestClass();\npublic static TestClass operator -(TestClass a, TestClass b) =&gt; new TestClass();\npublic static TestClass operator *(TestClass a, TestClass b) =&gt; new TestClass();\npublic static TestClass operator /(TestClass a, TestClass b) =&gt; new TestClass();\npublic static TestClass operator %(TestClass a, TestClass b) =&gt; new TestClass();\npublic static implicit operator TestClass(int a) =&gt; new TestClass();\npublic static explicit operator float(TestClass a) =&gt; 1f;\n</code></pre> 解析后的运算符方法完整签名 <code>public static UnitTestMethodsOperator.TestClass operator +(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static UnitTestMethodsOperator.TestClass operator -(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static UnitTestMethodsOperator.TestClass operator *(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static UnitTestMethodsOperator.TestClass operator /(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static UnitTestMethodsOperator.TestClass operator %(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static implicit operator UnitTestMethodsOperator.TestClass(int a)</code> <code>public static explicit operator float(UnitTestMethodsOperator.TestClass a)</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#静态扩展方法测试","level":3,"title":"静态扩展方法测试","text":"1 个测试用例 <pre><code>public static class TestStaticExtension\n{\n    public static int StaticMethod(this UnitTestMethodsStaticExtension.TestClass t) =&gt; 0;\n}\n</code></pre> 解析后的静态扩展方法完整签名 <code>public static int StaticMethod(this UnitTestMethodsStaticExtension.TestClass t)</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#propertydata","level":2,"title":"<code>PropertyData</code>","text":"<p><code>PropertyData</code> 测试须知</p> <p><code>PropertyData</code> 一共有 13 个测试用例。</p> <p>属性相当于在字段的声明中添加了 <code>get</code> 和 <code>set</code> 访问器，部分属性参考字段解析。</p> <p><code>PropertyData</code> 自定义默认值解析仅支持静态属性。</p> <p>不支持属性的访问修饰符与 get 和 set 访问器都不同的情况</p> <pre><code>protected bool BoolPropertyPrivateGetPublicSet { private get; set; }\n</code></pre>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#实例和静态基础类型属性单元测试","level":3,"title":"实例和静态基础类型属性单元测试","text":"8 个测试用例 <pre><code>public int IntPropertyPublicGetPublicSet { get; set; }\npublic string StringPropertyPublicGetInternalSet { get; internal set; }\npublic float FloatPropertyPublicGetProtectedSet { get; protected set; }\npublic bool BoolPropertyPublicGetPrivateSet { get; private set; }\npublic int IntPropertyInternalGetPublicSet { internal get; set; }\npublic float FloatPropertyProtectedGetPublicSet { protected get; set; }\npublic bool BoolPropertyPrivateGetPublicSet { private get; set; }\npublic static int StaticIntPropertyPublicGetPublicSet { get; set; }\n</code></pre> 解析后的属性完整签名 <code>public int IntPropertyPublicGetPublicSet { get; set; }</code> <code>public string StringPropertyPublicGetInternalSet { get; internal set; }</code> <code>public float FloatPropertyPublicGetProtectedSet { get; protected set; }</code> <code>public bool BoolPropertyPublicGetPrivateSet { get; private set; }</code> <code>public int IntPropertyInternalGetPublicSet { internal get; set; }</code> <code>public float FloatPropertyProtectedGetPublicSet { protected get; set; }</code> <code>public bool BoolPropertyPrivateGetPublicSet { private get; set; }</code> <code>public static int StaticIntPropertyPublicGetPublicSet { get; set; }</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#自定义默认值属性单元测试","level":3,"title":"自定义默认值属性单元测试","text":"5 个测试用例 <pre><code>public static int StaticIntPropertyWithDefaultValue { get; set; } = 1;\npublic static float StaticFloatPropertyWithDefaultValue { get; set; } = 1f;\npublic static bool StaticBoolPropertyWithDefaultValue { get; set; } = true;\npublic static string StaticStringPropertyWithDefaultValue { get; set; } = \"Hello\";\npublic static TestEnum StaticEnumPropertyWithDefaultValue { get; set; } = TestEnum.B;\n</code></pre> 解析后的属性完整签名 <code>public static int StaticIntPropertyWithDefaultValue { get; set; } = 1;</code> <code>public static float StaticFloatPropertyWithDefaultValue { get; set; } = 1f;</code> <code>public static bool StaticBoolPropertyWithDefaultValue { get; set; } = true;</code> <code>public static string StaticStringPropertyWithDefaultValue { get; set; } = \"Hello\";</code> <code>public static TestEnum StaticEnumPropertyWithDefaultValue { get; set; } = TestEnum.B;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#fielddata","level":2,"title":"<code>FieldData</code>","text":"<p><code>FieldData</code> 单元测试须知</p> <p><code>FieldData</code> 一共有 85 个测试用例。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#不同访问修饰符和复合关键字","level":3,"title":"不同访问修饰符和复合关键字","text":"6 个测试用例 <pre><code>int _privateField;\ninternal int InternalField;\nprivate protected int PrivateProtectedField;\nprotected int ProtectedField;\nprotected internal int ProtectedInternalField;\npublic int PublicField;\n</code></pre> 解析后的字段完整签名 <code>private int _privateField;</code> <code>internal int InternalField;</code> <code>private protected int PrivateProtectedField;</code> <code>protected int ProtectedField;</code> <code>protected internal int ProtectedInternalField;</code> <code>public int PublicField;</code> 4 个测试用例 <pre><code>public const int CONST_FIELD = 42;\npublic static readonly int StaticReadOnlyField;\npublic static int StaticField;\npublic readonly int ReadOnlyField;\n</code></pre> 解析后的字段完整签名 <code>public const int CONST_FIELD = 42;</code> <code>public static readonly int StaticReadOnlyField;</code> <code>public static int StaticField;</code> <code>public readonly int ReadOnlyField;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#常量字段","level":3,"title":"常量字段","text":"<p>常量字段单元测试须知</p> <ol> <li> <p>常量字段自定义设置默认值的解析测试只包括基础值类型、枚举类型、特殊的 string 引用类型。</p> </li> <li> <p>常量字段部分类型解析限制如下：</p> <p>a. 长整型常量字段，long，解析后的字段数据设置为以 'L' 字符结尾。</p> <p>b. 无符号长整型常量字段，ulong，解析后的字段数据设置为以 'ul' 字符结尾。</p> <p>c. 无符号整型常量字段，uint，解析后的字段数据设置为以 'u' 字符结尾。</p> <p>d. 双精度浮点型常量字段，double，解析后的字段数据设置为以 'd' 字符结尾，且为了保证精准，位数不能超过 15 位，这里的 15 位是指有效数字的位数，不只是小数点后的位数。</p> <p>e. 十进制浮点型常量字段，decimal，解析后的字段数据设置为以 'm' 字符结尾。</p> <p>f. 嵌套类枚举常量字段，UnitTestFieldsIsConstantWithDefaultValue.TestEnum，解析后的字段数据的字段类型会显示嵌套路径。</p> </li> </ol> 16 个测试用例 <pre><code>public const string STRING_CONST_FIELD = \"Hello, World!\";\npublic const int INT_CONST_FIELD = 2147483647;\npublic const float FLOAT_CONST_FIELD = 3.14159f;\npublic const bool BOOLEAN_CONST_FIELD = true;\npublic const char CHAR_CONST_FIELD = 'A';\npublic const byte BYTE_CONST_FIELD = 255;\npublic const sbyte SBYTE_CONST_FIELD = -128;\npublic const short SHORT_CONST_FIELD = 32767;\npublic const ushort USHORT_CONST_FIELD = 65535;\n</code></pre> 解析后的字段完整签名 <code>public const string STRING_CONST_FIELD = \"Hello, World!\";</code> <code>public const int INT_CONST_FIELD = 2147483647;</code> <code>public const float FLOAT_CONST_FIELD = 3.14159f;</code> <code>public const bool BOOLEAN_CONST_FIELD = true;</code> <code>public const char CHAR_CONST_FIELD = 'A';</code> <code>public const byte BYTE_CONST_FIELD = 255;</code> <code>public const sbyte SBYTE_CONST_FIELD = -128;</code> <code>public const short SHORT_CONST_FIELD = 32767;</code> <code>public const ushort USHORT_CONST_FIELD = 65535;</code> <pre><code>public const long LONG_CONST_FIELD = 9223372036854775807L;\npublic const ulong ULONG_CONST_FIELD = 18446744073709551615ul;\npublic const uint UINT_CONST_FIELD = 4294967295u;\npublic const double DOUBLE_CONST_FIELD = 2.71828182845904d; \npublic const decimal DECIMAL_CONST_FIELD = 123.456m;\npublic const ScriptDocGeneratorTestEnum ENUM_CONST_FIELD = ScriptDocGeneratorTestEnum.Value1;\n\n// 嵌套类枚举常量字段，UnitTestFieldsIsConstantWithDefaultValue.TestEnum\npublic const TestEnum NESTED_ENUM_CONST_FIELD = TestEnum.Value3;\n</code></pre> 解析后的字段完整签名 <code>public const long LONG_CONST_FIELD = 9223372036854775807L;</code> <code>public const ulong ULONG_CONST_FIELD = 18446744073709551615ul;</code> <code>public const uint UINT_CONST_FIELD = 4294967295u;</code> <code>public const double DOUBLE_CONST_FIELD = 2.71828182845904d;</code> <code>public const decimal DECIMAL_CONST_FIELD = 123.456m;</code> <code>public const ScriptDocGeneratorTestEnum ENUM_CONST_FIELD = ScriptDocGeneratorTestEnum.Value1;</code> <code>public const UnitTestFieldsIsConstantWithDefaultValue.TestEnum NESTED_ENUM_CONST_FIELD = TestEnum.Value3;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#静态字段","level":3,"title":"静态字段","text":"<p>静态字段单元测试须知</p> <ol> <li> <p>静态字段自定义设置默认值的解析测试只包括基础值类型、枚举类型、特殊的 string 引用类型。</p> </li> <li> <p>静态字段部分类型解析限制和常量一致</p> </li> </ol> 16 个测试用例 <pre><code>public static string StringStaticField = \"Hello, World!\";\npublic static int INTStaticField = 2147483647;\npublic static float FloatStaticField = 3.14159f;\npublic static bool BooleanStaticField = true;\npublic static char CharStaticField = 'A';\npublic static byte ByteStaticField = 255;\npublic static sbyte SbyteStaticField = -128;\npublic static short ShortStaticField = 32767;\npublic static ushort UshortStaticField = 65535;\n</code></pre> 解析后的字段完整签名 <code>public static string StringStaticField = \"Hello, World!\";</code> <code>public static int INTStaticField = 2147483647;</code> <code>public static float FloatStaticField = 3.14159f;</code> <code>public static bool BooleanStaticField = true;</code> <code>public static char CharStaticField = 'A';</code> <code>public static byte ByteStaticField = 255;</code> <code>public static sbyte SbyteStaticField = -128;</code> <code>public static short ShortStaticField = 32767;</code> <code>public static ushort UshortStaticField = 65535;</code> <pre><code>public static long LongStaticField = 9223372036854775807L;\npublic static ulong UlongStaticField = 18446744073709551615ul;\npublic static uint UintStaticField = 4294967295u;\npublic static double DoubleStaticField = 2.71828182845904d;\npublic static decimal DecimalStaticField = 123.456m;\npublic static ScriptDocGeneratorTestEnum EnumStaticField = ScriptDocGeneratorTestEnum.Value2;\npublic static TestEnum NestedEnumStaticField = TestEnum.Value3;\n</code></pre> 解析后的字段完整签名 <code>public static long LongStaticField = 9223372036854775807L;</code> <code>public static ulong UlongStaticField = 18446744073709551615ul;</code> <code>public static uint UintStaticField = 4294967295u;</code> <code>public static double DoubleStaticField = 2.71828182845904d;</code> <code>public static decimal DecimalStaticField = 123.456m;</code> <code>public static ScriptDocGeneratorTestEnum EnumStaticField = ScriptDocGeneratorTestEnum.Value2;</code> <code>public static UnitTestFieldsIsStaticWithDefaultValue.TestEnum NestedEnumStaticField = TestEnum.Value3;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#实例字段","level":3,"title":"实例字段","text":"<p>实例字段单元测试须知</p> <ol> <li>普通实例字段若成功解析，则只读实例字段也可以成功解析，不做另外测试。</li> </ol> 16 个测试用例 <pre><code>class TestClass\n{\n    public string StringField;\n    public int IntField;\n    public float FloatField;\n    public bool BooleanField;\n    public char CharField;\n    public byte ByteField;\n    public sbyte SbyteField;\n    public short ShortField;\n    public ushort UshortField;\n    public long LongField;\n    public ulong UlongField;\n    public uint UintField;\n    public double DoubleField;\n    public decimal DecimalField;\n    public ScriptDocGeneratorTestEnum EnumField;\n    public TestEnum NestedEnumField;\n}\n\nenum TestEnum\n{\n    Value1,\n    Value2,\n}\n</code></pre> 解析后的字段完整签名 <code>public string StringField;</code> <code>public int IntField;</code> <code>public float FloatField;</code> <code>public bool BooleanField;</code> <code>public char CharField;</code> <code>public byte ByteField;</code> <code>public sbyte SbyteField;</code> <code>public short ShortField;</code> <code>public ushort UshortField;</code> <code>public long LongField;</code> <code>public ulong UlongField;</code> <code>public uint UintField;</code> <code>public double DoubleField;</code> <code>public decimal DecimalField;</code> <code>public ScriptDocGeneratorTestEnum EnumField;</code> <code>public TestEnum NestedEnumField;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#集合字段","level":3,"title":"集合字段","text":"16 个测试用例 <pre><code>public int[] ArrayField;\npublic int[,] MultiArrayField;\npublic int[][] JaggedArrayField;\npublic List&lt;string&gt; ListField;\npublic Dictionary&lt;string, int&gt; DictionaryField;\npublic HashSet&lt;string&gt; HashSetField;\npublic SortedDictionary&lt;string, int&gt; SortedDictionaryField;\npublic SortedList&lt;string, int&gt; SortedListField;\npublic Stack&lt;string&gt; StackField;\npublic Queue&lt;int&gt; QueueField;\npublic LinkedList&lt;string&gt; LinkedListField;\npublic System.Collections.ArrayList ArrayListField;\npublic System.Collections.Hashtable HashtableField;\npublic IReadOnlyList&lt;string&gt; ReadOnlyListField;\npublic IReadOnlyDictionary&lt;string, int&gt; ReadOnlyDictionaryField;\npublic ConcurrentDictionary&lt;string, int&gt; ConcurrentDictionaryField;\n</code></pre> 解析后的字段完整签名 <code>public int[] ArrayField;</code> <code>public int[,] MultiArrayField;</code> <code>public int[][] JaggedArrayField;</code> <code>public List&lt;string&gt; ListField;</code> <code>public Dictionary&lt;string, int&gt; DictionaryField;</code> <code>public HashSet&lt;string&gt; HashSetField;</code> <code>public SortedDictionary&lt;string, int&gt; SortedDictionaryField;</code> <code>public SortedList&lt;string, int&gt; SortedListField;</code> <code>public Stack&lt;string&gt; StackField;</code> <code>public Queue&lt;int&gt; QueueField;</code> <code>public LinkedList&lt;string&gt; LinkedListField;</code> <code>public System.Collections.ArrayList ArrayListField;</code> <code>public System.Collections.Hashtable HashtableField;</code> <code>public IReadOnlyList&lt;string&gt; ReadOnlyListField;</code> <code>public IReadOnlyDictionary&lt;string, int&gt; ReadOnlyDictionaryField;</code> <code>public ConcurrentDictionary&lt;string, int&gt; ConcurrentDictionaryField;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#unity-特有字段","level":3,"title":"Unity 特有字段","text":"7 个测试用例 <pre><code>public GameObject gameObjectField;\npublic Transform transformField;\npublic Rigidbody rigidbodyField;\npublic Vector3 vector3Field;\n</code></pre> 完整声明为单行的字段，包含特性 <code>public GameObject gameObjectField;</code> <code>public Transform transformField;</code> <code>public Rigidbody rigidbodyField;</code> <code>public Vector3 vector3Field;</code> Quaternion 字段源码声明<pre><code>[SerializeField]\n[Tooltip(\"This is a tooltip\")]\n[UnityEngine.Range(0, 100)]\npublic Quaternion quaternionField;\n</code></pre> 解析结果<pre><code>[SerializeField]\n[UnityEngine.Tooltip(\"This is a tooltip\")]\n[UnityEngine.Range(0, 100)]\npublic Quaternion quaternionField;\n</code></pre> Color 字段源码声明<pre><code>[ColorUsage(true, true)]\npublic Color colorField = Color.white;\n</code></pre> 解析结果<pre><code>[UnityEngine.ColorUsage(true, true)]\npublic Color colorField;\n</code></pre> LayerMask 字段源码声明<pre><code>[Obsolete(\"Use newField instead\")]\npublic LayerMask layerMaskField;\n</code></pre> 解析结果<pre><code>[Obsolete(\"Use newField instead\")]\npublic LayerMask layerMaskField;\n</code></pre>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#杂项","level":3,"title":"杂项","text":"4 个测试用例 <pre><code>public TestAbstractClass AbstractField;\npublic dynamic DynamicField;\npublic ITestInterface InterfaceField;\npublic int? NullableField;\n</code></pre> 解析后的字段完整签名 <code>public TestAbstractClass AbstractField;</code> <code>public dynamic DynamicField;</code> <code>public ITestInterface InterfaceField;</code> <code>public int? NullableField;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"OdinInspector/AboutOdinInspector/","level":1,"title":"关于 Odin Inspector 必读","text":"<p>Note</p> <p>在购买 Odin Inspector 前，阅读本文档，了解更多关于 Odin Inspector 的信息。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector/AboutOdinInspector/#许可证","level":2,"title":"许可证","text":"","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector/AboutOdinInspector/#官网可以免费试用-90-天","level":3,"title":"官网可以免费试用 90 天","text":"<p>在你确定要购买 Odin Inspector 插件前，可以先在 Odin Inspector 官网 创建一个新账号，免费试用 90 天，你觉得不错后，再进行购买。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector/AboutOdinInspector/#官网可以免费获取-special-许可证","level":3,"title":"官网可以免费获取 Special 许可证","text":"<p>点击 Odin Inspector 价格页面，选择 <code>Special</code>，查看是否满足相关条件。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector/AboutOdinInspector/#unity-学生计划可以免费获取许可证","level":3,"title":"Unity 学生计划可以免费获取许可证","text":"<p>此方式有特定网页，首先要获得 Unity 学生计划资格，然后点击 Unity 官方支持页面，进入特殊页面验证资格。</p> <p>Warning</p> <p>中国大陆地区目前不可以获取 Unity 学生计划。Unity 学生计划申请表单的 Country 没有 China，Chinese，Hong Kong 的选项。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector/AboutOdinInspector/#个人或者小团队使用-personal-许可证","level":3,"title":"个人或者小团队使用 Personal 许可证","text":"<ul> <li> <p>Odin Inspector 官网价格页包含常见问题解答</p> </li> <li> <p>过去 12 个月的收入或财务规模小于 20 万美元。原文：Revenue or funding is less than $200K in the last 12 months.</p> </li> <li> <p>使用 Personal 许可证，一次性付费，买断制。官网原价 50 美元，打折 25 美元，资源商店原价 55 美元，打折 27.5 美元。直接在官网购买更便宜，同一时间打折，且经常打折，建议折扣价入手。</p> </li> <li> <p>Unity 资源商店销售的版本为 Personal</p> </li> <li> <p>只包含 Odin Inspector and Serializer 插件 的 DLL 版本。</p> </li> </ul> <p>Note</p> <p>如果超过了限制则需要购买商业版。商业版在个人版的基础上，增加了 Validator 插件（个人需要额外购买），Sirenix 公司三个产品的源代码，以及产品的永久回退许可证。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector/AboutOdinInspector/#超过限制的团队使用-enterprise-许可证","level":3,"title":"超过限制的团队使用 Enterprise 许可证","text":"<ul> <li> <p>Odin Inspector 官网价格页包含常见问题解答</p> </li> <li> <p>过去 12 个月的财务规模或收入大于 20 万美元。原文：Required if revenue or funding is greater than $200K in the last 12 months.</p> </li> <li> <p>按年付费，席位订阅制。价格为 235 美元一年一席位。原则上，一个项目中任何一个席位都需要付费，包括美术工作人员。</p> </li> <li> <p>包含 Odin Inspector and Serializer DLL 版本、Odin Validator，以及 Odin Inspector and Serializer 源代码。</p> </li> <li> <p>拥有永久回退许可证。如果你觉得 Odin Inspector 的后续更新不值得付费，那么使用永久回退许可证即可。</p> </li> </ul>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector/AboutOdinInspector/#在-unity-资源商店购买后通过订单号获取官网许可证","level":2,"title":"在 Unity 资源商店购买后，通过订单号获取官网许可证","text":"<p>在资源商店购买插件后，使用订单号在官网进行验证，以后可以在官网获取独立的插件包。</p> <p>官网版本会比资源商店版本更新稍快，且目前只有官网才可以下载 Beta 版本。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector/AboutOdinInspector/#odin-inspector-和-rider-达成合作","level":2,"title":"Odin Inspector 和 Rider 达成合作","text":"<p>Odin Inspector 的使用过程中会使用字符串，有时候没有引用标识很容易出错，Rider 针对此项问题和 Odin Inspector 的开发团队 Sirenix 达成合作，在 Rider 2024.1 版本中开始实装。</p> <p>所以如果你进行 Unity 开发，使用 Odin Inspector，且几乎不进行其他语言的工作，那么非常推荐使用 Rider。</p> <p>Rider 2024.1 的版本变化</p> <p>Rider 关于 Odin Inspector 合作的博客</p> <p>Rider 简单入门指南2.0-知乎</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector/AboutOdinInspector/#odin-inspector-宣布支持团结引擎tuanjie","level":2,"title":"Odin Inspector 宣布支持团结引擎（Tuanjie）","text":"<p>团结引擎是基于 Unity 2022 LTS 版本的特供版，未来中国开发者可以继续使用 Odin Inspector。</p> <p>Unity 中国 Unite 2025 B站-录播 可以了解到 Odin Inspector 官方安排了工作人员参加 Unite 2025。</p> <p>Odin Inspector Patch Notes 4.0 可以看到针对 Tuanjie 的更新。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/","level":1,"title":"<code>ConstructorData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class ConstructorData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IConstructorData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#注释","level":3,"title":"注释","text":"<ul> <li>构造方法解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public ConstructorData(ConstructorInfo constructorInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 构造方法的访问修饰符类型 <code>public MemberTypes MemberType { get; }</code> 构造方法的成员类型 <code>public bool IsStatic { get; }</code> 是否为静态构造方法 <code>public string AccessModifierName { get; }</code> 构造方法的访问修饰符名称字符串 <code>public string FullDeclarationWithAttributes { get; }</code> 包含特性和签名的完整构造方法声明 <code>public string MemberTypeName { get; }</code> 构造方法的成员类型名称字符串 <code>public string ParametersDeclaration { get; }</code> 构造方法的参数声明字符串，包含参数名称和类型 <code>public string Signature { get; }</code> 构造方法的完整签名 <code>public string SignatureWithoutParameters { get; }</code> 不包含参数的简单构造方法签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/","level":1,"title":"<code>DefaultAttributeFilter</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public class DefaultAttributeFilter : Yuumix.OdinToolkits.ScriptDocGenerator.IAttributeFilter\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#注释","level":3,"title":"注释","text":"<ul> <li>默认特性过滤器，构造函数中传入需要排除的 Attribute 类型</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public DefaultAttributeFilter(Type[] excludeTypes)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public bool ShouldFilterOut(Type type)</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public bool ShouldFilterOut</code> 判断传入的特性类型是否应该被过滤掉","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type[] ExcludeTypes { get; }</code> 排除的特性类型","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/","level":1,"title":"<code>DerivedMemberDataComparer</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public class DerivedMemberDataComparer : System.Collections.Generic.IComparer&lt;IDerivedMemberData&gt;\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#注释","level":3,"title":"注释","text":"<ul> <li>IDerivedMemberData 比较类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public DerivedMemberDataComparer()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public int Compare(IDerivedMemberData x, IDerivedMemberData y)</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public int Compare</code> 比较两个继承 IDerivedMemberData 的数据类的实例，用于排序","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/","level":1,"title":"<code>EventData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class EventData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IEventData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#注释","level":3,"title":"注释","text":"<ul> <li>事件解析数据类，用于存储事件的解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public EventData(EventInfo eventInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 访问修饰符类型 <code>public MemberTypes MemberType { get; }</code> 成员类型 <code>public Type EventType { get; }</code> 事件类型 <code>public bool IsStatic { get; }</code> 是否为静态事件 <code>public string AccessModifierName { get; }</code> 访问修饰符名称 <code>public string EventTypeFullName { get; }</code> 事件类型的完整名称，包括命名空间 <code>public string EventTypeName { get; }</code> 事件类型名称 <code>public string FullDeclarationWithAttributes { get; }</code> 包含特性和签名的完整事件声明 <code>public string MemberTypeName { get; }</code> 成员类型名称 <code>public string Signature { get; private set; }</code> 事件的完整签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/","level":1,"title":"<code>FieldData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class FieldData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IFieldData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#注释","level":3,"title":"注释","text":"<ul> <li>字段解析数据类，用于存储字段的解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public FieldData(FieldInfo fieldInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 访问修饰符类型 <code>public MemberTypes MemberType { get; }</code> 成员类型，指示该成员的类型 <code>public Type FieldType { get; }</code> 字段的类型 <code>public bool IsConstant { get; }</code> 是否为常量字段 <code>public bool IsDynamic { get; }</code> 是否为动态类型字段 <code>public bool IsReadOnly { get; }</code> 是否为只读字段 <code>public bool IsStatic { get; }</code> 指示该字段是否为静态字段 <code>public object DefaultValue { get; }</code> 字段的默认值，没有默认值返回 null <code>public string AccessModifierName { get; }</code> 访问修饰符名称 <code>public string FieldTypeFullName { get; }</code> 字段类型的完整名称 <code>public string FieldTypeName { get; }</code> 字段类型的名称 <code>public string FullDeclarationWithAttributes { get; }</code> 完整字段声明，包含特性和签名，默认剔除 Summary 特性 <code>public string MemberTypeName { get; }</code> 成员类型名称 <code>public string Signature { get; private set; }</code> 字段签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/","level":1,"title":"<code>IAnalysisDataFactory</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IAnalysisDataFactory\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#注释","level":3,"title":"注释","text":"<ul> <li>解析数据工厂接口，自定义扩展解析数据工厂</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public abstract IConstructorData CreateConstructorData(ConstructorInfo constructorInfo, IAttributeFilter filter = null)</code> <code>public abstract IEventData CreateEventData(EventInfo eventInfo, IAttributeFilter filter = null)</code> <code>public abstract IFieldData CreateFieldData(FieldInfo fieldInfo, IAttributeFilter filter = null)</code> <code>public abstract IMethodData CreateMethodData(MethodInfo methodInfo, IAttributeFilter filter = null)</code> <code>public abstract IPropertyData CreatePropertyData(PropertyInfo propertyInfo, IAttributeFilter filter = null)</code> <code>public abstract ITypeData CreateTypeData(Type type, IAnalysisDataFactory factory = null, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public abstract IConstructorData CreateConstructorData</code> 创建构造函数数据 <code>public abstract IEventData CreateEventData</code> 创建事件数据 <code>public abstract IFieldData CreateFieldData</code> 创建字段数据 <code>public abstract IMethodData CreateMethodData</code> 创建方法数据 <code>public abstract IPropertyData CreatePropertyData</code> 创建属性数据 <code>public abstract ITypeData CreateTypeData</code> 创建类型数据","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/","level":1,"title":"<code>IAttributeFilter</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IAttributeFilter\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#注释","level":3,"title":"注释","text":"<ul> <li>特性过滤器接口，用于过滤掉不需要的特性</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type[] ExcludeTypes { get; }</code> 排除的特性类型","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/","level":1,"title":"<code>IConstructorData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IConstructorData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#注释","level":3,"title":"注释","text":"<ul> <li>构造方法数据接口，继承自 IDerivedMemberData</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public string ParametersDeclaration { get; }</code> 方法的参数声明字符串，包含参数名称和类型 <code>public string SignatureWithoutParameters { get; }</code> 不包含参数的简单方法签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/","level":1,"title":"<code>IEventData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IEventData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#注释","level":3,"title":"注释","text":"<ul> <li>事件数据接口，继承自 IDerivedMemberData</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type EventType { get; }</code> 事件类型 <code>public string EventTypeFullName { get; }</code> 事件类型的完整名称，包括命名空间 <code>public string EventTypeName { get; }</code> 事件类型名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/","level":1,"title":"<code>IFieldData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IFieldData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#注释","level":3,"title":"注释","text":"<ul> <li>字段数据接口，继承自 IDerivedMemberData</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type FieldType { get; }</code> 字段的类型 <code>public bool IsConstant { get; }</code> 是否为常量字段（const） <code>public bool IsDynamic { get; }</code> 是否为动态字段（dynamic） <code>public bool IsReadOnly { get; }</code> 是否为只读字段（readonly） <code>public object DefaultValue { get; }</code> 字段的默认值 <code>public string FieldTypeFullName { get; }</code> 这个字段的类型的完整名称 <code>public string FieldTypeName { get; }</code> 这个字段的类型的名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/","level":1,"title":"<code>IMethodData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IMethodData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#注释","level":3,"title":"注释","text":"<ul> <li>方法数据接口，继承自 IDerivedMemberData</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type ReturnType { get; }</code> 方法的返回类型 <code>public bool IsAbstract { get; }</code> 是否带有抽象属性，不一定声明时带有 abstract 关键字 <code>public bool IsAsync { get; }</code> 是否为异步方法 <code>public bool IsFromAncestor { get; }</code> 此方法继承自祖先（不是直接的基类，而是基类的上层） <code>public bool IsFromInterfaceImplement { get; }</code> 此方法继承自接口，在该类中实现 <code>public bool IsOperator { get; }</code> 是否为运算符方法 <code>public bool IsOverloadMethodInDeclaringType { get; set; }</code> 此方法在当前类中存在重载方法，需要在 Type 解析时进行处理 <code>public bool IsOverride { get; }</code> 是否属于重写的方法，不一定带有 override 关键字 <code>public bool IsVirtual { get; }</code> 是否带有虚方法属性，不一定声明时带有 virtual 关键字 <code>public string ParametersDeclaration { get; }</code> 方法的参数声明字符串，包含参数名称和类型 <code>public string ReturnTypeFullName { get; }</code> 方法的返回类型的完整名称 <code>public string ReturnTypeName { get; }</code> 方法的返回类型名称 <code>public string SignatureWithoutParameters { get; }</code> 不包含参数的简单方法签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/","level":1,"title":"<code>IParameterData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IParameterData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#注释","level":3,"title":"注释","text":"<ul> <li>参数信息解析数据接口</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public ParameterDirection Direction { get; }</code> 参数方向（in/out/ref） <code>public Type ParameterType { get; }</code> 参数类型 <code>public bool HasDefaultValue { get; }</code> 是否有默认值 <code>public bool IsParams { get; }</code> 是否为 params 参数 <code>public object DefaultValue { get; }</code> 默认值 <code>public string Name { get; }</code> 参数名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/","level":1,"title":"<code>IPropertyData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IPropertyData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#注释","level":3,"title":"注释","text":"<ul> <li>属性数据接口，继承自 IDerivedMemberData，包含属性特有的数据信息和方法，派生类的通用数据信息和方法</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type PropertyType { get; }</code> 属性类型 <code>public object DefaultValue { get; }</code> 自定义默认值，如果没有自定义默认值，则为 null <code>public string PropertyTypeFullName { get; }</code> 属性类型的完整名称，包括命名空间 <code>public string PropertyTypeName { get; }</code> 属性类型名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/","level":1,"title":"<code>ITypeData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface ITypeData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#注释","level":3,"title":"注释","text":"<ul> <li>类型解析数据接口，继承自 IDerivedMemberData 接口</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Assembly Assembly { get; }</code> 类型所在的程序集 <code>public IAnalysisDataFactory DataFactory { get; }</code> 分析数据工厂实例对象 <code>public IConstructorData[] RuntimeReflectedConstructorsData { get; }</code> 类型的构造函数解析数据数组，只包含公共构造函数，GetConstructors() 方法 <code>public IEventData[] RuntimeReflectedEventsData { get; }</code> 类型的事件解析数据数组，GetRuntimeEvents() 方法 <code>public IFieldData[] RuntimeReflectedFieldsData { get; }</code> 类型的字段解析数据数组，GetUserDefinedFields() 方法 <code>public IMethodData[] RuntimeReflectedMethodsData { get; }</code> 类型的方法解析数据数组，GetRuntimeMethods() 方法 <code>public IPropertyData[] RuntimeReflectedPropertiesData { get; }</code> 类型的属性解析数据数组，GetRuntimeProperties() 方法 <code>public TypeCategory TypeCategory { get; }</code> Type 种类 <code>public bool IsAbstract { get; }</code> 是否为抽象类型 <code>public bool IsGenericType { get; }</code> 是否为泛型类型 <code>public bool IsSealed { get; }</code> 是否为密封类型 <code>public string AssemblyName { get; }</code> 类型所在的程序集名称 <code>public string NamespaceName { get; }</code> 类型所在的命名空间 <code>public string[] InheritanceChain { get; }</code> 类型的继承链数组 <code>public string[] InterfaceArray { get; }</code> 类型的接口数组 <code>public string[] ReferenceWebLinkArray { get; }</code> 类型的引用链接数组","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/","level":1,"title":"<code>MethodData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class MethodData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMethodData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#注释","level":3,"title":"注释","text":"<ul> <li>方法解析数据类，用于存储 MethodInfo 的解析结果</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public MethodData(MethodInfo memberInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>public void AddOverloadPrefix()</code> <code>public static string GetMethodKeywordSnippet(MethodInfo methodInfo)</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public void AddOverloadPrefix</code> 为方法添加重载前缀（[Overload]） <code>public static string GetMethodKeywordSnippet</code> 获取方法的关键字片段字符串","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 方法的访问修饰符类型 <code>public MemberTypes MemberType { get; }</code> 方法的成员类型 <code>public Type ReturnType { get; }</code> 方法的返回类型 <code>public bool IsAbstract { get; }</code> 是否为抽象方法（abstract） <code>public bool IsAsync { get; }</code> 是否为异步方法（async） <code>public bool IsFromAncestor { get; }</code> 是否从祖先类继承的重写方法，在该子类的方法签名中不一定带有 override 关键字 <code>public bool IsFromInterfaceImplement { get; }</code> 是否从接口实现的方法 <code>public bool IsOperator { get; }</code> 是否为运算符方法（operator） <code>public bool IsOverloadMethodInDeclaringType { get; set; }</code> 是否为声明类型中的重载方法 <code>public bool IsOverride { get; }</code> 是否有重写方法（override）的特性，方法签名中不一定带有 override 关键字 <code>public bool IsStatic { get; }</code> 是否为静态方法（static） <code>public bool IsVirtual { get; }</code> 是否有虚拟方法（virtual）的特性，方法签名中不一定带有 virtual 关键字 <code>public string AccessModifierName { get; }</code> 方法的访问修饰符名称字符串 <code>public string FullDeclarationWithAttributes { get; }</code> 包含特性的完整方法声明字符串，包含特性声明和方法签名 <code>public string MemberTypeName { get; }</code> 方法的成员类型名称字符串 <code>public string ParametersDeclaration { get; }</code> 方法的参数声明字符串，包含参数名称和类型 <code>public string ReturnTypeFullName { get; }</code> 方法的返回值完整类型名称字符串 <code>public string ReturnTypeName { get; }</code> 方法的返回类型名称字符串 <code>public string Signature { get; private set; }</code> 方法的签名字符串 <code>public string SignatureWithoutParameters { get; }</code> 不包含参数的简单方法签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/","level":1,"title":"<code>ParameterData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class ParameterData : Yuumix.OdinToolkits.ScriptDocGenerator.IParameterData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#注释","level":3,"title":"注释","text":"<ul> <li>参数信息解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public ParameterData(ParameterInfo parameterInfo)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public string GetFormattedString()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public string GetFormattedString</code> 生成格式化的参数字符串","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public ParameterDirection Direction { get; }</code> 参数方向（in/out/ref） <code>public Type ParameterType { get; }</code> 参数类型 <code>public bool HasDefaultValue { get; }</code> 是否有默认值 <code>public bool IsParams { get; }</code> 是否为 params 参数 <code>public object DefaultValue { get; }</code> 默认值 <code>public string Name { get; }</code> 参数名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/","level":1,"title":"<code>PropertyData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class PropertyData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IPropertyData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#注释","level":3,"title":"注释","text":"<ul> <li>解析成员数据的基类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public PropertyData(PropertyInfo propertyInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 访问修饰符 <code>public MemberTypes MemberType { get; }</code> 成员类型 <code>public Type PropertyType { get; }</code> 属性类型 <code>public bool IsStatic { get; }</code> 是否为静态属性 <code>public object DefaultValue { get; }</code> 属性类型 <code>public string AccessModifierName { get; }</code> 访问修饰符名称 <code>public string FullDeclarationWithAttributes { get; }</code> 完整属性声明 - 包含特性和签名 - 默认剔除 [Summary] 特性 <code>public string MemberTypeName { get; }</code> <code>public string PropertyTypeFullName { get; }</code> 属性类型的完整名称 <code>public string PropertyTypeName { get; }</code> 属性类型名称 <code>public string Signature { get; private set; }</code> 属性签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/","level":1,"title":"<code>TypeAnalyzerStaticExtensions</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>static class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Extension]\npublic static class TypeAnalyzerStaticExtensions\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#注释","level":3,"title":"注释","text":"<ul> <li>类型分析器静态扩展类，统一管理类型分析器有关的静态扩展方法</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>[Ext] public static AccessModifierType GetEventAccessModifierType(this EventInfo eventInfo)</code> <code>[Ext] public static AccessModifierType GetFieldAccessModifier(this FieldInfo fieldInfo)</code> <code>[Ext] public static AccessModifierType GetMethodAccessModifierType(this MethodBase method)</code> <code>[Ext] public static AccessModifierType GetPropertyAccessModifierType(this PropertyInfo propertyInfo)</code> <code>[Ext] public static AccessModifierType GetTypeAccessModifier(this Type type)</code> <code>[Ext] public static FieldInfo[] GetUserDefinedFields(this Type type)</code> <code>[Ext] public static TypeCategory GetTypeCategory(this Type type)</code> <code>[Ext] public static bool IsAbstractOrInterface(this Type type)</code> <code>[Ext] public static bool IsApiMember(this IDerivedMemberData derivedMemberData)</code> <code>[Ext] public static bool IsAsyncMethod(this MethodBase methodBase)</code> <code>[Ext] public static bool IsDelegate(this Type type)</code> <code>[Ext] public static bool IsDynamicField(this FieldInfo fieldInfo)</code> <code>[Ext] public static bool IsFromInheritance(this MemberInfo member)</code> <code>[Ext] public static bool IsFromInterfaceImplementMethod(this MethodBase method)</code> <code>[Ext] public static bool IsInheritedOverrideFromAncestor(this MethodInfo method, Type currentType)</code> <code>[Ext] public static bool IsOperatorMethod(this MethodBase methodInfo)</code> <code>[Ext] public static bool IsOverrideMethod(this MethodInfo methodInfo)</code> <code>[Ext] public static bool IsRecord(this Type type)</code> <code>[Ext] public static bool IsRecordStruct(this Type type)</code> <code>[Ext] public static bool IsReferenceTypeExcludeString(this Type type)</code> <code>[Ext] public static bool IsStaticProperty(this PropertyInfo propertyInfo)</code> <code>[Ext] public static bool TryAsIMemberData(this IDerivedMemberData derivedMemberData, out ref IMemberData memberData)</code> <code>[Ext] public static bool TryGetFieldCustomDefaultValue(this FieldInfo fieldInfo, out ref Object defaultValue)</code> <code>[Ext] public static bool TryGetPropertyCustomDefaultValue(this PropertyInfo propertyInfo, out ref Object defaultValue)</code> <code>[Ext] public static string GetAttributesDeclarationWithMultiLine(this MemberInfo member, IAttributeFilter filter = null)</code> <code>[Ext] public static string GetMethodNameAndParameters(this MethodBase method)</code> <code>[Ext] public static string GetParametersNameWithDefaultValue(this MethodBase method)</code> <code>[Ext] public static string GetReadableTypeName(this Type type, bool useFullName = false)</code> <code>[Ext] public static string GetTypeDeclaration(this Type type)</code> <code>[Ext] public static string[] GetInheritanceChain(this Type type)</code> <code>[Ext] public static string[] GetInterfaceArray(this Type type)</code> <code>[Ext] public static string[] GetReferenceLinks(this Type type)</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>[Ext] public static AccessModifierType GetEventAccessModifierType</code> 获取事件的访问修饰符类型 <code>[Ext] public static AccessModifierType GetFieldAccessModifier</code> 获取字段访问修饰符 <code>[Ext] public static AccessModifierType GetMethodAccessModifierType</code> 获取方法的访问修饰符类型 <code>[Ext] public static AccessModifierType GetPropertyAccessModifierType</code> 获取属性的访问修饰符类型 <code>[Ext] public static AccessModifierType GetTypeAccessModifier</code> 获取类型的访问修饰符 <code>[Ext] public static FieldInfo[] GetUserDefinedFields</code> 获取开发者声明的字段，剔除自动属性生成的字段 <code>[Ext] public static TypeCategory GetTypeCategory</code> 获取类型的种类 <code>[Ext] public static bool IsAbstractOrInterface</code> 判断一个类型是否为抽象类或接口 <code>[Ext] public static bool IsApiMember</code> 判断是否为 API 成员，返回 true 表示是 API 成员，返回 false 表示不是。API 成员指的是公共成员或受保护成员。 <code>[Ext] public static bool IsAsyncMethod</code> 判断方法是否是异步方法 <code>[Ext] public static bool IsDelegate</code> 判断指定类型是否为委托类型 <code>[Ext] public static bool IsDynamicField</code> 判断是否为动态字段 <code>[Ext] public static bool IsFromInheritance</code> 判断成员是否从继承中获取，这里的成员不包括 Type 类型 <code>[Ext] public static bool IsFromInterfaceImplementMethod</code> 判断是否为接口的实现方法 <code>[Ext] public static bool IsInheritedOverrideFromAncestor</code> 判断方法是否为从祖先类继承的重写方法，重写声明不是在当前类中 <code>[Ext] public static bool IsOperatorMethod</code> 判断方法是否是运算符方法 <code>[Ext] public static bool IsOverrideMethod</code> 方法是否具有 override 的特性 <code>[Ext] public static bool IsRecord</code> 判断指定类型是否为 record（包括 record class 和 record struct） <code>[Ext] public static bool IsRecordStruct</code> 判断类型是否为 record struct（值类型 record） <code>[Ext] public static bool IsReferenceTypeExcludeString</code> 判断一个类型是否为非字符串的引用类型（非值类型） <code>[Ext] public static bool IsStaticProperty</code> 判断是否为静态属性 <code>[Ext] public static bool TryAsIMemberData</code> 将 IDerivedMemberData 转换为 IMemberData，转换成功返回 true，转换失败返回 false <code>[Ext] public static bool TryGetFieldCustomDefaultValue</code> 获取字段的自定义默认值，不能获取到值则返回 null。只获取静态字段和常量字段的默认值。 <code>[Ext] public static bool TryGetPropertyCustomDefaultValue</code> 获取属性的自定义默认值，不能获取到值则返回 null，只获取静态属性的默认值。 <code>[Ext] public static string GetAttributesDeclarationWithMultiLine</code> 获取特性声明字符串，多行显示 <code>[Ext] public static string GetMethodNameAndParameters</code> 获取方法名称和参数列表，不包含返回值和修饰符 <code>[Ext] public static string GetParametersNameWithDefaultValue</code> 获取方法的参数签名，包含默认值 <code>[Ext] public static string GetReadableTypeName</code> 将反射获取到的系统类型名称转换为人类可读的 C# 风格类型名称 <code>[Ext] public static string GetTypeDeclaration</code> 获取类型声明字符串 <code>[Ext] public static string[] GetInheritanceChain</code> 获取一个类型的继承链，不包括接口 <code>[Ext] public static string[] GetInterfaceArray</code> 获取一个类型继承的所有接口 <code>[Ext] public static string[] GetReferenceLinks</code> 获取一个数组，内容是所有的 ReferenceLinkURL 特性中的网页链接字符串","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/","level":1,"title":"<code>TypeAnalyzerUtility</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>static class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public static class TypeAnalyzerUtility\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#注释","level":3,"title":"注释","text":"<ul> <li>类型分析器工具类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>public static bool TreatedAsTypeDefaultValue(object value, Type type)</code> <code>public static bool TryGetFormatedAttributeWithFullParameter(object attrInstance, out ref string attributeFullSignature)</code> <code>public static string GetAttributeNameWithoutSuffix(string attributeName)</code> <code>public static string GetFieldKeywordSnippet(bool isConst, bool isStatic, bool isReadOnly)</code> <code>public static string GetFormattedDefaultValue(Type memberType, object value)</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public static bool TreatedAsTypeDefaultValue</code> 提供的值被视为类型的默认值，返回 true 表示被视为类型的默认值，返回 false 表示不是。 <code>public static bool TryGetFormatedAttributeWithFullParameter</code> 获取格式化的完整特性签名字符串，返回 true 表示该特性支持格式化为完整特性签名字符串，返回 false 表示不支持。 <code>public static string GetAttributeNameWithoutSuffix</code> 获取没有后缀的 Attribute 名称 <code>public static string GetFieldKeywordSnippet</code> 获取字段的关键字片段字符串 <code>public static string GetFormattedDefaultValue</code> 获取格式化的默认值字符串，用于生成签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#字段","level":2,"title":"字段","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#声明的普通字段","level":3,"title":"声明的普通字段","text":"字段名称 注释 <code>public static readonly IReadOnlyDictionary&lt;Type, string&gt; TypeAliasMap;</code> 将系统类型名称映射到其 C# 别名的字典","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/","level":1,"title":"<code>TypeCategory</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>enum</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public enum TypeCategory : System.Enum, \nSystem.IFormattable, \nSystem.IComparable, \nSystem.IConvertible\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public bool HasFlag(Enum flag)</code> <code>public override bool Equals(object obj)</code> <code>public override int GetHashCode()</code> <code>public override string ToString()</code> <code>public string ToString(string format)</code> <code>public virtual TypeCode GetTypeCode()</code> <code>public virtual int CompareTo(object target)</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code> <code>[Overload] [Overload] public virtual string ToString(IFormatProvider provider)</code> <code>[Overload] [Overload] public virtual string ToString(string format, IFormatProvider provider)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public bool HasFlag</code> <code>System.Enum</code> <code>public override bool Equals</code> <code>System.Enum</code> <code>public override int GetHashCode</code> <code>System.Enum</code> <code>public override string ToString</code> <code>System.Enum</code> <code>public string ToString</code> <code>System.Enum</code> <code>public virtual TypeCode GetTypeCode</code> <code>System.Enum</code> <code>public virtual int CompareTo</code> <code>System.Enum</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Enum</code> <code>public virtual string ToString</code> <code>System.Enum</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#字段","level":2,"title":"字段","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#常量字段","level":3,"title":"常量字段","text":"字段完整签名 注释 <code>public const TypeCategory Class;</code> <code>public const TypeCategory Delegate;</code> <code>public const TypeCategory Enum;</code> <code>public const TypeCategory Interface;</code> <code>public const TypeCategory Record;</code> <code>public const TypeCategory Struct;</code> <code>public const TypeCategory Unknown;</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/","level":1,"title":"<code>TypeData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class TypeData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.ITypeData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#注释","level":3,"title":"注释","text":"<ul> <li>类型解析数据类，存储类型的各种成员的解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public TypeData(Type type, IAttributeFilter filter = null, IAnalysisDataFactory factory = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 访问修饰符 <code>public Assembly Assembly { get; }</code> 类型所在的程序集 <code>public IAnalysisDataFactory DataFactory { get; }</code> 分析数据工厂实例对象 <code>public IConstructorData[] RuntimeReflectedConstructorsData { get; }</code> 声明的构造方法解析数据数组，只包含公共构造函数，GetConstructors() 方法 <code>public IEventData[] RuntimeReflectedEventsData { get; }</code> 声明的事件解析数据数组，GetRuntimeEvents() 方法 <code>public IFieldData[] RuntimeReflectedFieldsData { get; }</code> 类型的字段解析数据数组，GetUserDefinedFields() 方法 <code>public IMethodData[] RuntimeReflectedMethodsData { get; }</code> 声明的方法解析数据数组，GetRuntimeMethods() 方法 <code>public IPropertyData[] RuntimeReflectedPropertiesData { get; }</code> 声明的属性解析数据数组，GetRuntimeProperties() 方法 <code>public MemberTypes MemberType { get; }</code> 成员类型 <code>public TypeCategory TypeCategory { get; }</code> Type 种类 <code>public bool IsAbstract { get; }</code> 是否为抽象类 <code>public bool IsGenericType { get; }</code> 是否为泛型类型 <code>public bool IsSealed { get; }</code> 是否为密封类 <code>public bool IsStatic { get; }</code> 是否为静态类型 <code>public string AccessModifierName { get; }</code> 访问修饰符名称 <code>public string AssemblyName { get; }</code> 程序集名称 <code>public string FullDeclarationWithAttributes { get; }</code> 完整类型声明 - 包含特性和签名 - 默认剔除 [Summary] 特性 <code>public string MemberTypeName { get; }</code> 成员类型名称 <code>public string NamespaceName { get; }</code> 命名空间名称 <code>public string Signature { get; }</code> 类型签名，不包含特性声明 <code>public string[] InheritanceChain { get; }</code> 继承链数组 <code>public string[] InterfaceArray { get; }</code> 接口列表数组 <code>public string[] ReferenceWebLinkArray { get; }</code> 引用链接数组","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/","level":1,"title":"<code>YuumixDefaultAnalysisDataFactory</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class YuumixDefaultAnalysisDataFactory : Yuumix.OdinToolkits.ScriptDocGenerator.IAnalysisDataFactory\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#注释","level":3,"title":"注释","text":"<ul> <li>Yuumix 默认提供的解析数据工厂实现类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public YuumixDefaultAnalysisDataFactory()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public IConstructorData CreateConstructorData(ConstructorInfo constructorInfo, IAttributeFilter filter = null)</code> <code>public IEventData CreateEventData(EventInfo eventInfo, IAttributeFilter filter = null)</code> <code>public IFieldData CreateFieldData(FieldInfo fieldInfo, IAttributeFilter filter = null)</code> <code>public IMethodData CreateMethodData(MethodInfo methodInfo, IAttributeFilter filter = null)</code> <code>public IPropertyData CreatePropertyData(PropertyInfo propertyInfo, IAttributeFilter filter = null)</code> <code>public ITypeData CreateTypeData(Type type, IAnalysisDataFactory factory = null, IAttributeFilter filter = null)</code> <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public IConstructorData CreateConstructorData</code> 创建构造函数数据 <code>public IEventData CreateEventData</code> 创建事件数据 <code>public IFieldData CreateFieldData</code> 创建字段数据 <code>public IMethodData CreateMethodData</code> 创建方法数据 <code>public IPropertyData CreatePropertyData</code> 创建属性数据 <code>public ITypeData CreateTypeData</code> 创建类型数据","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/","level":1,"title":"<code>DocGeneratorSettingSO</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>abstract class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Editor</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator.Editor</code></li> </ul> <pre><code>public abstract class DocGeneratorSettingSO : UnityEngine.ScriptableObject, \nYuumix.OdinToolkits.Core.IOdinToolkitsEditorReset\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#注释","level":3,"title":"注释","text":"<ul> <li>文档生成器设置抽象类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public abstract string GetGeneratedDoc(ITypeData data)</code> <code>public int GetInstanceID()</code> <code>public override bool Equals(object other)</code> <code>public override int GetHashCode()</code> <code>public override string ToString()</code> <code>public void EditorReset()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code> <code>public void SetDirty()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public abstract string GetGeneratedDoc</code> 通过 TypeData 实例对象，生成文档内容。注意：不要在此方法中添加增量生成标识符 <code>public void EditorReset</code> 重置文档生成器设置","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public int GetInstanceID</code> <code>UnityEngine.Object</code> <code>public override bool Equals</code> <code>UnityEngine.Object</code> <code>public override int GetHashCode</code> <code>UnityEngine.Object</code> <code>public override string ToString</code> <code>UnityEngine.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code> <code>public void SetDirty</code> <code>UnityEngine.ScriptableObject</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public HideFlags hideFlags { get; set; }</code> <code>UnityEngine.Object</code> <code>public string name { get; set; }</code> <code>UnityEngine.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#字段","level":2,"title":"字段","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#声明的普通字段","level":3,"title":"声明的普通字段","text":"字段名称 注释 <code>public bool customizeDocFileExtensionName;</code> 是否自定义文档扩展名 <code>public bool generateIdentifier;</code> 是否自动生成增量标识符 <code>public bool generateNamespaceFolder;</code> 是否按命名空间生成文件夹 <code>public string docFileExtensionName;</code> 设置的文档扩展名","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/","level":1,"title":"<code>TypesCacheSO</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Editor</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator.Editor</code></li> </ul> <pre><code>public class TypesCacheSO : Sirenix.OdinInspector.SerializedScriptableObject, \nUnityEngine.ISerializationCallbackReceiver\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#注释","level":3,"title":"注释","text":"<ul> <li>存储 Type 的资源文件，提供给脚本文档生成工具复用，用户无需每次重新选择 Type</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public TypesCacheSO()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public int GetInstanceID()</code> <code>public override bool Equals(object other)</code> <code>public override int GetHashCode()</code> <code>public override string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code> <code>protected virtual void OnAfterDeserialize()</code> <code>protected virtual void OnBeforeSerialize()</code> <code>public void SetDirty()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public int GetInstanceID</code> <code>UnityEngine.Object</code> <code>public override bool Equals</code> <code>UnityEngine.Object</code> <code>public override int GetHashCode</code> <code>UnityEngine.Object</code> <code>public override string ToString</code> <code>UnityEngine.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code> <code>protected virtual void OnAfterDeserialize</code> <code>Sirenix.OdinInspector.SerializedScriptableObject</code> <code>protected virtual void OnBeforeSerialize</code> <code>Sirenix.OdinInspector.SerializedScriptableObject</code> <code>public void SetDirty</code> <code>UnityEngine.ScriptableObject</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public HideFlags hideFlags { get; set; }</code> <code>UnityEngine.Object</code> <code>public string name { get; set; }</code> <code>UnityEngine.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#字段","level":2,"title":"字段","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#声明的普通字段","level":3,"title":"声明的普通字段","text":"字段名称 注释 <code>public List&lt;Type&gt; Types;</code> 存储 Type 的列表","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]}]}