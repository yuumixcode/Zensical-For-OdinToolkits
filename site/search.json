{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"README","text":"<p>探索 Odin Inspector 进阶功能、整合优质资源、优化游戏开发流程</p> <p> </p> <p> </p>","path":["README"],"tags":["readme"]},{"location":"#-重要声明","level":2,"title":"⚠️ 重要声明","text":"<ul> <li><code>Odin Toolkits</code> 是开源的、第三方扩展工具集，主要面向 <code>Odin Inspector and Serializer</code> 的中文用户。</li> <li><code>Odin Toolkits</code> 提供了英文界面解决方案，欢迎贡献完善英文界面。</li> <li>本项目与 Sirenix 公司及官方产品 <code>Odin Inspector and Serializer</code> 无任何隶属、合作关系，并非官方衍生产品。</li> <li>本项目不包含 <code>Odin Inspector and Serializer</code> 的发行版本。</li> <li>本文中的 <code>Odin Inspector</code> 为 <code>Odin Inspector and Serializer</code> 的简称。</li> </ul>","path":["README"],"tags":["readme"]},{"location":"#项目愿景","level":2,"title":"项目愿景","text":"<ul> <li>成为使用 <code>Odin Inspector and Serializer</code> 的开发者的必备扩展工具集。</li> </ul>","path":["README"],"tags":["readme"]},{"location":"#主要模块","level":2,"title":"主要模块","text":"<ol> <li><code>Script Doc Generator</code> ：脚本文档生成工具，一键生成 <code>API</code> 文档，也可以自定义文档格式。</li> <li><code>Attribute Overview Pro</code> ：Odin 特性总览窗口 Pro 版，在官方的 <code>Attribute Overview</code> 内容上进行扩展。</li> <li><code>Tool Packages</code> ：工具箱模块，提供一些简单的编辑器工具。</li> <li><code>Community</code> ：社区模块，收集、整理、分享使用 <code>Odin Inspector</code> 制作的工具以及其他优质资源。</li> <li>原生多语言特性，在构造函数层面直接添加多语言参数。</li> </ol>","path":["README"],"tags":["readme"]},{"location":"#安装","level":2,"title":"安装","text":"","path":["README"],"tags":["readme"]},{"location":"#前提条件","level":3,"title":"前提条件","text":"<ul> <li><code>Tuanjie 1.6.7 LTS</code> 或 <code>Unity 2021.3.45f2c1 LTS</code> 或对应引擎的更高版本</li> <li><code>Odin Inspector And Serializer</code> 最新版本。本项目最初基于 <code>3.3.1.14</code> 开发。</li> </ul>","path":["README"],"tags":["readme"]},{"location":"#具体步骤","level":3,"title":"具体步骤","text":"<p><code>Odin Toolkits</code> 依赖 <code>Odin Inspector</code> 插件，请先自行导入 <code>Odin Inspector</code> 插件到项目。</p> <p>从 Unity Global AssetStore 和 Sirenix 官网 上购买 <code>Odin Inspector</code> 或其他方式获取。</p> <ol> <li>确保项目中已安装 <code>Odin Inspector</code></li> <li>下载最新发布包</li> <li>将包导入到 <code>Unity</code> 项目中</li> <li>通过 <code>Tools/Odin Toolkits</code> 菜单访问工具</li> </ol>","path":["README"],"tags":["readme"]},{"location":"#开始使用","level":2,"title":"开始使用","text":"<p>导入后，您可以通过 Unity 编辑器菜单访问 <code>Odin Toolkits</code>：</p> <ul> <li><code>Tools/Odin Toolkits/Getting Started</code> - 开始菜单</li> <li><code>Tools/Odin Toolkits/Editor Settings</code> - 配置编辑器阶段设置</li> <li><code>Tools/Odin Toolkits/Runtime Config</code> - 配置运行时设置</li> <li><code>Tools/Odin Toolkits/Attribute Overview Pro</code> - Odin 特性总览窗口 Pro 版</li> <li><code>Tools/Odin Toolkits/Script Doc Generator</code> - 脚本文档生成工具</li> <li><code>Tools/Odin Toolkits/Tool Packages</code> - 工具箱</li> <li><code>Tools/Odin Toolkits/Community</code> - 社区模块</li> </ul>","path":["README"],"tags":["readme"]},{"location":"#项目结构","level":2,"title":"项目结构","text":"<pre><code>Plugins/\n├─ Yuumix/\n│  ├─ Community/\n│  │  ├─ Editor/\n│  │  ├─ Modules/\n│  ├─ OdinToolkits/\n│  │  ├─ AttributeOverviewPro/\n│  │  ├─ Core/\n│  │  │  ├─ Editor/\n│  │  │  ├─ Resources/\n│  │  │  ├─ Runtime/\n│  │  ├─ Modules/\n│  │  ├─ ScriptDocGenerator/\n│  │  ├─ Tests/\n</code></pre>","path":["README"],"tags":["readme"]},{"location":"#相关链接","level":2,"title":"相关链接","text":"<p>推荐 - Odin Toolkits 主网站</p> <p>Odin Toolkits 备用网站</p> <p>Odin Inspector 官方网站</p> <p>Odin Inspector 许可信息</p>","path":["README"],"tags":["readme"]},{"location":"#许可证","level":2,"title":"许可证","text":"<p>本项目基于 MIT 许可证授权。</p>","path":["README"],"tags":["readme"]},{"location":"#logo-许可证","level":3,"title":"Logo 许可证","text":"<p>查看 <code>LOGO-LICENSE.md</code> 文档。</p>","path":["README"],"tags":["readme"]},{"location":"#更新日志","level":2,"title":"更新日志","text":"<p>详细版本历史和变更请查看网站 <code>Information/CHANGELOG</code> 章节或项目中的 <code>CHANGELOG.md</code>。</p>","path":["README"],"tags":["readme"]},{"location":"#贡献指南","level":2,"title":"贡献指南","text":"<p>Note</p> <p>暂不推荐，因为目前 API 可能随时改变。查看 <code>CONTRIBUTING.md</code> 文档。</p>","path":["README"],"tags":["readme"]},{"location":"#支持与反馈","level":2,"title":"支持与反馈","text":"<p>zeriying@gmail.com，发送邮箱时，请添加 <code>[Odin Toolkits - xxx]</code> 前缀，例如 <code>[Odin Toolkits - BUG]</code>，这样更便于接收反馈，避免遗漏。</p> <p>感谢你看到这里，如果 <code>Odin Toolkits</code> 在你的 <code>Unity</code> 开发过程中切实提供了帮助，恳请为项目点亮一颗 ★ Star！</p> <p>如果 <code>Odin Toolkits</code> 打包出现错误，请提 issue，或者联系我，我会尽快处理，业余时间开发，无法即时回复，请优先邮件联系。</p>","path":["README"],"tags":["readme"]},{"location":"#项目及友链推荐","level":2,"title":"项目及友链推荐","text":"<p>QFramework - Unity 开发框架</p> <p>ES Framework - Unity 开发框架</p> <p>Wcowin 的 MkDocs 博客</p> <p>Aaron 的博客</p> <p></p> <p></p>","path":["README"],"tags":["readme"]},{"location":"OdinInspector-license/","level":1,"title":"关于 Odin Inspector 必读","text":"<p>Note</p> <p>在购买 Odin Inspector 前，阅读本文档，了解更多关于 Odin Inspector 的信息。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector-license/#许可证","level":2,"title":"许可证","text":"","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector-license/#官网可以免费试用-90-天","level":3,"title":"官网可以免费试用 90 天","text":"<p>在你确定要购买 Odin Inspector 插件前，可以先在 Odin Inspector 官网 创建一个新账号，免费试用 90 天，你觉得不错后，再进行购买。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector-license/#官网可以免费获取-special-许可证","level":3,"title":"官网可以免费获取 Special 许可证","text":"<p>点击 Odin Inspector 价格页面，选择 <code>Special</code>，查看是否满足相关条件。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector-license/#unity-学生计划可以免费获取许可证","level":3,"title":"Unity 学生计划可以免费获取许可证","text":"<p>此方式有特定网页，首先要获得 Unity 学生计划资格，然后点击 Unity 官方支持页面，进入特殊页面验证资格。</p> <p>Warning</p> <p>中国大陆地区目前不可以获取 Unity 学生计划。Unity 学生计划申请表单的 Country 没有 China，Chinese，Hong Kong 的选项。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector-license/#个人或者小团队使用-personal-许可证","level":3,"title":"个人或者小团队使用 Personal 许可证","text":"<ul> <li> <p>Odin Inspector 官网价格页包含常见问题解答</p> </li> <li> <p>过去 12 个月的收入或财务规模小于 20 万美元。原文：Revenue or funding is less than $200K in the last 12 months.</p> </li> <li> <p>使用 Personal 许可证，一次性付费，买断制。官网原价 50 美元，打折 25 美元，资源商店原价 55 美元，打折 27.5 美元。直接在官网购买更便宜，同一时间打折，且经常打折，建议折扣价入手。</p> </li> <li> <p>Unity 资源商店销售的版本为 Personal</p> </li> <li> <p>只包含 Odin Inspector and Serializer 插件 的 DLL 版本。</p> </li> </ul> <p>Note</p> <p>如果超过了限制则需要购买商业版。商业版在个人版的基础上，增加了 Validator 插件（个人需要额外购买），Sirenix 公司三个产品的源代码，以及产品的永久回退许可证。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector-license/#超过限制的团队使用-enterprise-许可证","level":3,"title":"超过限制的团队使用 Enterprise 许可证","text":"<ul> <li> <p>Odin Inspector 官网价格页包含常见问题解答</p> </li> <li> <p>过去 12 个月的财务规模或收入大于 20 万美元。原文：Required if revenue or funding is greater than $200K in the last 12 months.</p> </li> <li> <p>按年付费，席位订阅制。价格为 235 美元一年一席位。原则上，一个项目中任何一个席位都需要付费，包括美术工作人员。</p> </li> <li> <p>包含 Odin Inspector and Serializer DLL 版本、Odin Validator，以及 Odin Inspector and Serializer 源代码。</p> </li> <li> <p>拥有永久回退许可证。如果你觉得 Odin Inspector 的后续更新不值得付费，那么使用永久回退许可证即可。</p> </li> </ul>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector-license/#在-unity-资源商店购买后通过订单号获取官网许可证","level":2,"title":"在 Unity 资源商店购买后，通过订单号获取官网许可证","text":"<p>在资源商店购买插件后，使用订单号在官网进行验证，以后可以在官网获取独立的插件包。</p> <p>官网版本会比资源商店版本更新稍快，且目前只有官网才可以下载 Beta 版本。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector-license/#odin-inspector-和-rider-达成合作","level":2,"title":"Odin Inspector 和 Rider 达成合作","text":"<p>Odin Inspector 的使用过程中会使用字符串，有时候没有引用标识很容易出错，Rider 针对此项问题和 Odin Inspector 的开发团队 Sirenix 达成合作，在 Rider 2024.1 版本中开始实装。</p> <p>所以如果你进行 Unity 开发，使用 Odin Inspector，且几乎不进行其他语言的工作，那么非常推荐使用 Rider。</p> <p>Rider 2024.1 的版本变化</p> <p>Rider 关于 Odin Inspector 合作的博客</p> <p>Rider 简单入门指南2.0-知乎</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"OdinInspector-license/#odin-inspector-宣布支持团结引擎tuanjie","level":2,"title":"Odin Inspector 宣布支持团结引擎（Tuanjie）","text":"<p>团结引擎是基于 Unity 2022 LTS 版本的特供版，未来中国开发者可以继续使用 Odin Inspector。</p> <p>Unity 中国 Unite 2025 B站-录播 可以了解到 Odin Inspector 官方安排了工作人员参加 Unite 2025。</p> <p>Odin Inspector Patch Notes 4.0 可以看到针对 Tuanjie 的更新。</p>","path":["关于 Odin Inspector 必读"],"tags":[]},{"location":"Artical/csharp-SOLID/","level":1,"title":"C# SOLID 原则","text":"<p>在 Unity 游戏开发中，随着项目规模的扩大，代码的可维护性、可扩展性和可测试性变得至关重要。SOLID 原则作为面向对象设计的五大基石，为我们提供了构建高质量代码的指导方针。本文将结合 Unity 开发实践和 Odin Inspector 工具，深入探讨如何在 C# 项目中应用这些原则。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#引言为什么需要-solid-原则","level":2,"title":"引言：为什么需要 SOLID 原则？","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#传统-unity-开发中的常见问题","level":3,"title":"传统 Unity 开发中的常见问题","text":"<p>在许多 Unity 项目中，我们经常会遇到以下问题：</p> <ol> <li>神类问题：一个 MonoBehaviour 脚本承担了太多职责</li> <li>修改困难：添加新功能时需要修改大量现有代码</li> <li>测试困难：组件之间耦合度高，难以进行单元测试</li> <li>代码重复：相似的功能在多个地方重复实现</li> </ol> <pre><code>// ❌ 违反多个 SOLID 原则的示例\npublic class PlayerController : MonoBehaviour\n{\n    public float health = 100f;\n    public float speed = 5f;\n    public GameObject bulletPrefab;\n    public AudioSource audioSource;\n\n    void Update()\n    {\n        // 处理移动\n        HandleMovement();\n        // 处理射击\n        HandleShooting();\n        // 处理血量显示\n        UpdateHealthUI();\n        // 处理音效\n        PlaySounds();\n        // 处理动画\n        UpdateAnimations();\n    }\n\n    // ... 大量混杂的功能代码\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#solid-原则如何解决这些问题","level":3,"title":"SOLID 原则如何解决这些问题","text":"<p>SOLID 原则通过以下方式改善代码质量：</p> <ul> <li>职责分离：每个类只负责一个特定的功能</li> <li>扩展友好：新功能可以通过扩展而非修改现有代码来实现</li> <li>接口规范：通过抽象和接口降低模块间的耦合</li> <li>依赖管理：高层模块不直接依赖低层实现细节</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#solid-原则概览","level":2,"title":"SOLID 原则概览","text":"<p>SOLID 是五个设计原则的首字母缩写：</p> 原则 英文名称 中文名称 核心理念 S Single Responsibility Principle 单一职责原则 一个类应该只有一个引起它变化的原因 O Open-Closed Principle 开闭原则 软件实体应对扩展开放，对修改封闭 L Liskov Substitution Principle 里氏替换原则 子类对象必须能够替换基类对象 I Interface Segregation Principle 接口隔离原则 不应强迫客户依赖于它们不使用的接口 D Dependency Inversion Principle 依赖倒置原则 高层模块不应依赖低层模块，都应依赖抽象 <p>这些原则相互补充，共同构建了一个健壮的软件架构基础。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#s---单一职责原则-single-responsibility-principle","level":2,"title":"S - 单一职责原则 (Single Responsibility Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#原理阐述","level":3,"title":"原理阐述","text":"<p>单一职责原则是 SOLID 原则中最基础也是最重要的一个。它的核心思想是：一个类应该只有一个引起它变化的原因。换句话说，一个类应该只承担一种职责。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#违反-srp-的问题示例","level":3,"title":"违反 SRP 的问题示例","text":"<p>让我们看一个典型的违反 SRP 的 Unity 脚本：</p> <pre><code>// ❌ 违反单一职责原则的示例\npublic class BadPlayerController : MonoBehaviour\n{\n    [Header(\"健康系统\")]\n    public float maxHealth = 100f;\n    private float currentHealth;\n\n    [Header(\"移动系统\")]\n    public float moveSpeed = 5f;\n    private Rigidbody2D rb;\n\n    [Header(\"武器系统\")]\n    public GameObject bulletPrefab;\n    public Transform firePoint;\n    public float fireRate = 0.5f;\n    private float nextFireTime;\n\n    [Header(\"音效系统\")]\n    public AudioClip shootSound;\n    public AudioClip hurtSound;\n    private AudioSource audioSource;\n\n    [Header(\"UI 显示\")]\n    public Slider healthBar;\n    public Text healthText;\n\n    void Start()\n    {\n        currentHealth = maxHealth;\n        rb = GetComponent&lt;Rigidbody2D&gt;();\n        audioSource = GetComponent&lt;AudioSource&gt;();\n    }\n\n    void Update()\n    {\n        HandleMovement();   // 移动职责\n        HandleShooting();   // 射击职责\n        UpdateHealthUI();   // UI 更新职责\n        CheckHealthStatus(); // 健康状态检查职责\n    }\n\n    // 移动相关代码\n    void HandleMovement()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n        Vector2 movement = new Vector2(horizontal, vertical);\n        rb.velocity = movement * moveSpeed;\n    }\n\n    // 射击相关代码\n    void HandleShooting()\n    {\n        if (Input.GetButton(\"Fire1\") &amp;&amp; Time.time &gt;= nextFireTime)\n        {\n            Shoot();\n            nextFireTime = Time.time + fireRate;\n        }\n    }\n\n    void Shoot()\n    {\n        Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        audioSource.PlayOneShot(shootSound);\n    }\n\n    // 健康系统相关代码\n    public void TakeDamage(float damage)\n    {\n        currentHealth -= damage;\n        audioSource.PlayOneShot(hurtSound);\n        UpdateHealthUI();\n\n        if (currentHealth &lt;= 0)\n        {\n            Die();\n        }\n    }\n\n    void Die()\n    {\n        // 死亡逻辑\n        gameObject.SetActive(false);\n    }\n\n    // UI 更新相关代码\n    void UpdateHealthUI()\n    {\n        if (healthBar != null)\n            healthBar.value = currentHealth / maxHealth;\n        if (healthText != null)\n            healthText.text = $\"{currentHealth:F0}/{maxHealth:F0}\";\n    }\n\n    void CheckHealthStatus()\n    {\n        // 健康状态检查逻辑\n    }\n}\n</code></pre> <p>这个类违反了 SRP，因为它承担了多个职责：</p> <ul> <li>移动控制</li> <li>射击系统</li> <li>健康管理</li> <li>音效播放</li> <li>UI 更新</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#遵循-srp-的重构方案","level":3,"title":"遵循 SRP 的重构方案","text":"<p>让我们将上述代码重构为遵循 SRP 的版本：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#1-健康系统组件","level":4,"title":"1. 健康系统组件","text":"<pre><code>// ✅ 遵循 SRP：只负责健康管理\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class HealthComponent : MonoBehaviour\n{\n    [Title(\"健康配置\")]\n    [SerializeField, Range(1, 1000)] private float maxHealth = 100f;\n\n    [ShowInInspector, ReadOnly, ProgressBar(0, \"maxHealth\", ColorGetter = \"GetHealthColor\")]\n    private float currentHealth;\n\n    [Title(\"事件\")]\n    public UnityEvent&lt;float&gt; OnHealthChanged;\n    public UnityEvent&lt;float&gt; OnDamageTaken;\n    public UnityEvent OnDeath;\n\n    public float CurrentHealth =&gt; currentHealth;\n    public float MaxHealth =&gt; maxHealth;\n    public bool IsAlive =&gt; currentHealth &gt; 0;\n    public float HealthPercentage =&gt; currentHealth / maxHealth;\n\n    void Start()\n    {\n        currentHealth = maxHealth;\n    }\n\n    [Button(\"造成伤害\"), DisableInEditorMode]\n    public void TakeDamage(float damage)\n    {\n        if (!IsAlive) return;\n\n        currentHealth = Mathf.Max(0, currentHealth - damage);\n\n        OnHealthChanged?.Invoke(currentHealth);\n        OnDamageTaken?.Invoke(damage);\n\n        if (!IsAlive)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n\n    [Button(\"恢复血量\"), DisableInEditorMode]\n    public void Heal(float amount)\n    {\n        if (!IsAlive) return;\n\n        currentHealth = Mathf.Min(maxHealth, currentHealth + amount);\n        OnHealthChanged?.Invoke(currentHealth);\n    }\n\n    // Odin Inspector 颜色获取器\n    private Color GetHealthColor()\n    {\n        float percentage = HealthPercentage;\n        if (percentage &gt; 0.6f) return Color.green;\n        if (percentage &gt; 0.3f) return Color.yellow;\n        return Color.red;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#2-移动控制组件","level":4,"title":"2. 移动控制组件","text":"<pre><code>// ✅ 遵循 SRP：只负责移动控制\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class MovementComponent : MonoBehaviour\n{\n    [Title(\"移动配置\")]\n    [SerializeField, Range(1, 20)] private float moveSpeed = 5f;\n\n    [ShowInInspector, ReadOnly]\n    private Vector2 currentVelocity;\n\n    private Rigidbody2D rb;\n\n    void Start()\n    {\n        rb = GetComponent&lt;Rigidbody2D&gt;();\n    }\n\n    void Update()\n    {\n        HandleMovementInput();\n    }\n\n    void HandleMovementInput()\n    {\n        float horizontal = Input.GetAxis(\"Horizontal\");\n        float vertical = Input.GetAxis(\"Vertical\");\n\n        Move(new Vector2(horizontal, vertical));\n    }\n\n    [Button(\"停止移动\")]\n    public void Stop()\n    {\n        Move(Vector2.zero);\n    }\n\n    public void Move(Vector2 direction)\n    {\n        currentVelocity = direction.normalized * moveSpeed;\n        rb.velocity = currentVelocity;\n    }\n\n    public void SetSpeed(float newSpeed)\n    {\n        moveSpeed = Mathf.Max(0, newSpeed);\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#3-武器系统组件","level":4,"title":"3. 武器系统组件","text":"<pre><code>// ✅ 遵循 SRP：只负责武器射击\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class WeaponComponent : MonoBehaviour\n{\n    [Title(\"武器配置\")]\n    [SerializeField] private GameObject bulletPrefab;\n    [SerializeField] private Transform firePoint;\n    [SerializeField, Range(0.1f, 5f)] private float fireRate = 0.5f;\n\n    [ShowInInspector, ReadOnly]\n    private float nextFireTime;\n\n    [Title(\"事件\")]\n    public UnityEvent OnWeaponFired;\n\n    public bool CanFire =&gt; Time.time &gt;= nextFireTime;\n\n    void Update()\n    {\n        if (Input.GetButton(\"Fire1\") &amp;&amp; CanFire)\n        {\n            Fire();\n        }\n    }\n\n    [Button(\"开火\"), DisableInEditorMode]\n    public void Fire()\n    {\n        if (!CanFire) return;\n\n        Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        nextFireTime = Time.time + fireRate;\n\n        OnWeaponFired?.Invoke();\n    }\n\n    public void SetFireRate(float newFireRate)\n    {\n        fireRate = Mathf.Max(0.1f, newFireRate);\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#4-重构后的玩家控制器","level":4,"title":"4. 重构后的玩家控制器","text":"<pre><code>// ✅ 遵循 SRP：只负责组件协调\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    [Title(\"组件引用\")]\n    [SerializeField, Required] private HealthComponent healthComponent;\n    [SerializeField, Required] private MovementComponent movementComponent;\n    [SerializeField, Required] private WeaponComponent weaponComponent;\n    [SerializeField, Required] private AudioSource audioSource;\n\n    [Title(\"音效配置\")]\n    [SerializeField] private AudioClip shootSound;\n    [SerializeField] private AudioClip hurtSound;\n\n    void Start()\n    {\n        SetupEventListeners();\n    }\n\n    void SetupEventListeners()\n    {\n        // 监听健康变化事件\n        healthComponent.OnDamageTaken.AddListener(OnPlayerHurt);\n        healthComponent.OnDeath.AddListener(OnPlayerDeath);\n\n        // 监听武器射击事件\n        weaponComponent.OnWeaponFired.AddListener(OnWeaponFired);\n    }\n\n    void OnPlayerHurt(float damage)\n    {\n        if (hurtSound != null)\n            audioSource.PlayOneShot(hurtSound);\n    }\n\n    void OnPlayerDeath()\n    {\n        // 处理玩家死亡\n        movementComponent.Stop();\n        // 可以触发游戏结束逻辑\n    }\n\n    void OnWeaponFired()\n    {\n        if (shootSound != null)\n            audioSource.PlayOneShot(shootSound);\n    }\n\n    void OnDestroy()\n    {\n        // 清理事件监听\n        if (healthComponent != null)\n        {\n            healthComponent.OnDamageTaken.RemoveListener(OnPlayerHurt);\n            healthComponent.OnDeath.RemoveListener(OnPlayerDeath);\n        }\n\n        if (weaponComponent != null)\n        {\n            weaponComponent.OnWeaponFired.RemoveListener(OnWeaponFired);\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#srp-的优势","level":3,"title":"SRP 的优势","text":"<p>重构后的代码具有以下优势：</p> <ol> <li>职责清晰：每个组件只负责一个特定功能</li> <li>易于测试：可以单独测试每个组件</li> <li>易于维护：修改某个功能不会影响其他功能</li> <li>可重用性高：组件可以在其他地方复用</li> <li>易于扩展：添加新功能只需要添加新组件</li> </ol> <p>Odin Inspector 的 SRP 支持</p> <ul> <li>使用 <code>[Title]</code> 和 <code>[BoxGroup]</code> 来组织单一职责的配置项</li> <li>使用 <code>[Required]</code> 特性确保必要依赖的完整性</li> <li>使用 <code>[Button]</code> 特性提供测试接口</li> <li>使用 <code>[ShowInInspector]</code> 和 <code>[ReadOnly]</code> 显示运行时状态</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#o---开闭原则-open-closed-principle","level":2,"title":"O - 开闭原则 (Open-Closed Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#原理阐述_1","level":3,"title":"原理阐述","text":"<p>开闭原则要求软件实体（类、模块、函数等）对扩展开放，对修改封闭。这意味着当需要添加新功能时，应该通过扩展现有代码来实现，而不是修改现有代码。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#违反-ocp-的问题示例","level":3,"title":"违反 OCP 的问题示例","text":"<p>考虑一个武器系统，如果不遵循开闭原则：</p> <pre><code>// ❌ 违反开闭原则的武器系统\npublic enum WeaponType\n{\n    Pistol,\n    Rifle,\n    Shotgun\n    // 每次添加新武器都需要修改这个枚举\n}\n\npublic class BadWeaponSystem : MonoBehaviour\n{\n    public WeaponType weaponType;\n    public GameObject bulletPrefab;\n    public Transform firePoint;\n\n    public void Fire()\n    {\n        // 每次添加新武器都需要修改这个方法\n        switch (weaponType)\n        {\n            case WeaponType.Pistol:\n                FirePistol();\n                break;\n            case WeaponType.Rifle:\n                FireRifle();\n                break;\n            case WeaponType.Shotgun:\n                FireShotgun();\n                break;\n            // 需要不断添加新的 case\n        }\n    }\n\n    void FirePistol()\n    {\n        // 手枪射击逻辑\n        Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n    }\n\n    void FireRifle()\n    {\n        // 步枪射击逻辑（三连发）\n        for (int i = 0; i &lt; 3; i++)\n        {\n            Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        }\n    }\n\n    void FireShotgun()\n    {\n        // 鸳弹枪射击逻辑（散弹）\n        for (int i = 0; i &lt; 5; i++)\n        {\n            float angle = (i - 2) * 15f;\n            Quaternion rotation = Quaternion.Euler(0, 0, angle) * firePoint.rotation;\n            Instantiate(bulletPrefab, firePoint.position, rotation);\n        }\n    }\n}\n</code></pre> <p>这种设计的问题：</p> <ul> <li>每次添加新武器都需要修改现有代码</li> <li>代码修改可能引入新的 Bug</li> <li>难以进行单元测试</li> <li>不符合开闭原则</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#遵循-ocp-的重构方案","level":3,"title":"遵循 OCP 的重构方案","text":"<p>使用策略模式和接口来遵循开闭原则：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#1-定义武器接口","level":4,"title":"1. 定义武器接口","text":"<pre><code>// ✅ 武器接口：对扩展开放\nusing UnityEngine;\n\npublic interface IWeapon\n{\n    string WeaponName { get; }\n    float Damage { get; }\n    float FireRate { get; }\n    void Fire(Transform firePoint, GameObject bulletPrefab);\n    bool CanFire();\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#2-具体武器实现","level":4,"title":"2. 具体武器实现","text":"<pre><code>// ✅ 手枪实现\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\n[System.Serializable]\npublic class PistolWeapon : IWeapon\n{\n    [Title(\"手枪配置\")]\n    [SerializeField] private string weaponName = \"手枪\";\n    [SerializeField, Range(10, 50)] private float damage = 25f;\n    [SerializeField, Range(0.1f, 2f)] private float fireRate = 0.5f;\n\n    private float lastFireTime;\n\n    public string WeaponName =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n\n    public bool CanFire()\n    {\n        return Time.time &gt;= lastFireTime + fireRate;\n    }\n\n    public void Fire(Transform firePoint, GameObject bulletPrefab)\n    {\n        if (!CanFire()) return;\n\n        GameObject bullet = Object.Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        if (bullet.TryGetComponent&lt;Bullet&gt;(out var bulletComponent))\n        {\n            bulletComponent.SetDamage(damage);\n        }\n\n        lastFireTime = Time.time;\n    }\n}\n\n// ✅ 步枪实现\n[System.Serializable]\npublic class RifleWeapon : IWeapon\n{\n    [Title(\"步枪配置\")]\n    [SerializeField] private string weaponName = \"步枪\";\n    [SerializeField, Range(15, 40)] private float damage = 20f;\n    [SerializeField, Range(0.05f, 0.3f)] private float fireRate = 0.1f;\n    [SerializeField, Range(1, 5)] private int burstCount = 3;\n\n    private float lastFireTime;\n\n    public string WeaponName =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n\n    public bool CanFire()\n    {\n        return Time.time &gt;= lastFireTime + fireRate;\n    }\n\n    public void Fire(Transform firePoint, GameObject bulletPrefab)\n    {\n        if (!CanFire()) return;\n\n        // 三连发射击\n        for (int i = 0; i &lt; burstCount; i++)\n        {\n            GameObject bullet = Object.Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n            if (bullet.TryGetComponent&lt;Bullet&gt;(out var bulletComponent))\n            {\n                bulletComponent.SetDamage(damage);\n            }\n        }\n\n        lastFireTime = Time.time;\n    }\n}\n\n// ✅ 鸳弹枪实现\n[System.Serializable]\npublic class ShotgunWeapon : IWeapon\n{\n    [Title(\"鸳弹枪配置\")]\n    [SerializeField] private string weaponName = \"鸳弹枪\";\n    [SerializeField, Range(5, 15)] private float damage = 8f;\n    [SerializeField, Range(0.5f, 3f)] private float fireRate = 1.2f;\n    [SerializeField, Range(3, 8)] private int pelletCount = 5;\n    [SerializeField, Range(5, 30)] private float spreadAngle = 15f;\n\n    private float lastFireTime;\n\n    public string WeaponName =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n\n    public bool CanFire()\n    {\n        return Time.time &gt;= lastFireTime + fireRate;\n    }\n\n    public void Fire(Transform firePoint, GameObject bulletPrefab)\n    {\n        if (!CanFire()) return;\n\n        // 散弹射击\n        for (int i = 0; i &lt; pelletCount; i++)\n        {\n            float angle = (i - (pelletCount - 1) / 2f) * spreadAngle;\n            Quaternion rotation = Quaternion.Euler(0, 0, angle) * firePoint.rotation;\n\n            GameObject bullet = Object.Instantiate(bulletPrefab, firePoint.position, rotation);\n            if (bullet.TryGetComponent&lt;Bullet&gt;(out var bulletComponent))\n            {\n                bulletComponent.SetDamage(damage);\n            }\n        }\n\n        lastFireTime = Time.time;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#3-武器系统控制器","level":4,"title":"3. 武器系统控制器","text":"<pre><code>// ✅ 遵循开闭原则的武器系统\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class WeaponSystem : MonoBehaviour\n{\n    [Title(\"武器配置\")]\n    [SerializeReference, Sirenix.OdinInspector.LabelText(\"当前武器\")]\n    private IWeapon currentWeapon;\n\n    [SerializeField, Required] private Transform firePoint;\n    [SerializeField, Required] private GameObject bulletPrefab;\n\n    [Title(\"预设武器\")]\n    [SerializeField] private PistolWeapon pistol = new PistolWeapon();\n    [SerializeField] private RifleWeapon rifle = new RifleWeapon();\n    [SerializeField] private ShotgunWeapon shotgun = new ShotgunWeapon();\n\n    [Title(\"事件\")]\n    public UnityEvent&lt;string&gt; OnWeaponChanged;\n    public UnityEvent OnWeaponFired;\n\n    [ShowInInspector, ReadOnly]\n    public string CurrentWeaponName =&gt; currentWeapon?.WeaponName ?? \"无\";\n\n    void Start()\n    {\n        // 默认武器\n        EquipWeapon(pistol);\n    }\n\n    void Update()\n    {\n        HandleInput();\n    }\n\n    void HandleInput()\n    {\n        // 射击\n        if (Input.GetButton(\"Fire1\"))\n        {\n            Fire();\n        }\n\n        // 切换武器\n        if (Input.GetKeyDown(KeyCode.Alpha1)) EquipWeapon(pistol);\n        if (Input.GetKeyDown(KeyCode.Alpha2)) EquipWeapon(rifle);\n        if (Input.GetKeyDown(KeyCode.Alpha3)) EquipWeapon(shotgun);\n    }\n\n    [Button(\"开火\"), DisableInEditorMode]\n    public void Fire()\n    {\n        if (currentWeapon != null &amp;&amp; currentWeapon.CanFire())\n        {\n            currentWeapon.Fire(firePoint, bulletPrefab);\n            OnWeaponFired?.Invoke();\n        }\n    }\n\n    [Button(\"装备手枪\")]\n    public void EquipPistol() =&gt; EquipWeapon(pistol);\n\n    [Button(\"装备步枪\")]\n    public void EquipRifle() =&gt; EquipWeapon(rifle);\n\n    [Button(\"装备鸳弹枪\")]\n    public void EquipShotgun() =&gt; EquipWeapon(shotgun);\n\n    public void EquipWeapon(IWeapon weapon)\n    {\n        currentWeapon = weapon;\n        OnWeaponChanged?.Invoke(weapon.WeaponName);\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#添加新武器对扩展开放","level":3,"title":"添加新武器：对扩展开放","text":"<p>现在添加一个新的激光枪，无需修改现有代码：</p> <pre><code>// ✅ 新武器：激光枪（无需修改现有代码）\n[System.Serializable]\npublic class LaserWeapon : IWeapon\n{\n    [Title(\"激光枪配置\")]\n    [SerializeField] private string weaponName = \"激光枪\";\n    [SerializeField, Range(30, 100)] private float damage = 50f;\n    [SerializeField, Range(0.3f, 1.5f)] private float fireRate = 0.8f;\n    [SerializeField, Range(5, 20)] private float laserDuration = 2f;\n\n    private float lastFireTime;\n\n    public string WeaponName =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n\n    public bool CanFire()\n    {\n        return Time.time &gt;= lastFireTime + fireRate;\n    }\n\n    public void Fire(Transform firePoint, GameObject bulletPrefab)\n    {\n        if (!CanFire()) return;\n\n        // 创建激光束效果\n        GameObject laser = Object.Instantiate(bulletPrefab, firePoint.position, firePoint.rotation);\n        if (laser.TryGetComponent&lt;LaserBeam&gt;(out var laserComponent))\n        {\n            laserComponent.SetDamage(damage);\n            laserComponent.SetDuration(laserDuration);\n        }\n\n        lastFireTime = Time.time;\n    }\n}\n</code></pre> <p>只需要在 <code>WeaponSystem</code> 中添加一个字段：</p> <pre><code>[SerializeField] private LaserWeapon laser = new LaserWeapon();\n\n[Button(\"装备激光枪\")]\npublic void EquipLaser() =&gt; EquipWeapon(laser);\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#ocp-的优势","level":3,"title":"OCP 的优势","text":"<ol> <li>扩展性：添加新功能无需修改现有代码</li> <li>数据稳定性：现有功能不会被新功能影响</li> <li>测试友好：每个武器可以单独测试</li> <li>代码复用：武器实现可以在其他系统中复用</li> </ol> <p>Odin Inspector 的 OCP 支持</p> <ul> <li>使用 <code>[SerializeReference]</code> 实现接口序列化</li> <li>使用 <code>[Button]</code> 提供运行时切换功能</li> <li>使用 <code>[Title]</code> 和 <code>[BoxGroup]</code> 组织不同的武器配置</li> <li>使用 <code>[ShowInInspector]</code> 显示当前状态</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#l---里氏替换原则-liskov-substitution-principle","level":2,"title":"L - 里氏替换原则 (Liskov Substitution Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#原理阐述_2","level":3,"title":"原理阐述","text":"<p>里氏替换原则要求：子类对象必须能够替换其基类对象，而不会影响程序的正确性。这意味着子类应该增强而不是删弱基类的功能。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#违反-lsp-的问题示例","level":3,"title":"违反 LSP 的问题示例","text":"<p>考虑一个飞行物体的继承体系：</p> <pre><code>// ❌ 违反里氏替换原则的设计\npublic abstract class FlyingObject : MonoBehaviour\n{\n    public float speed = 10f;\n\n    public virtual void Fly()\n    {\n        transform.Translate(Vector3.forward * speed * Time.deltaTime);\n    }\n\n    public virtual void Land()\n    {\n        // 默认着陆行为\n        speed = 0;\n    }\n}\n\npublic class Airplane : FlyingObject\n{\n    public override void Fly()\n    {\n        // 飞机正常飞行\n        transform.Translate(Vector3.forward * speed * Time.deltaTime);\n    }\n\n    public override void Land()\n    {\n        // 飞机可以着陆\n        speed = 0;\n        Debug.Log(\"飞机已着陆\");\n    }\n}\n\n// 问题：企鹅不能飞行，违反了 LSP\npublic class Penguin : FlyingObject\n{\n    public override void Fly()\n    {\n        // 企鹅不能飞！\n        throw new System.NotSupportedException(\"企鹅不能飞行！\");\n    }\n\n    public override void Land()\n    {\n        // 企鹅本来就在地上，这个方法没有意义\n        Debug.Log(\"企鹅本来就在地上...\");\n    }\n}\n\n// 使用时会出现问题\npublic class FlightController : MonoBehaviour\n{\n    public FlyingObject[] flyingObjects;\n\n    void Start()\n    {\n        foreach (var obj in flyingObjects)\n        {\n            obj.Fly(); // 如果数组中有企鹅，这里会抛出异常！\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#遵循-lsp-的重构方案","level":3,"title":"遵循 LSP 的重构方案","text":"<p>重新设计类层次结构，使其遵循里氏替换原则：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#1-重新设计基类结构","level":4,"title":"1. 重新设计基类结构","text":"<pre><code>// ✅ 遵循 LSP 的设计：动物基类\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic abstract class Animal : MonoBehaviour\n{\n    [Title(\"动物基本信息\")]\n    [SerializeField, ReadOnly] protected string animalName;\n    [SerializeField, Range(1, 50)] protected float moveSpeed = 5f;\n\n    [ShowInInspector, ReadOnly]\n    public string AnimalName =&gt; animalName;\n\n    [ShowInInspector, ReadOnly]\n    public float MoveSpeed =&gt; moveSpeed;\n\n    protected virtual void Start()\n    {\n        animalName = GetType().Name;\n    }\n\n    // 所有动物都可以移动\n    public abstract void Move(Vector3 direction);\n\n    // 所有动物都可以发出声音\n    public abstract void MakeSound();\n}\n\n// ✅ 可飞行动物接口\npublic interface IFlyable\n{\n    float FlySpeed { get; }\n    void Fly(Vector3 direction);\n    void Land();\n    bool IsFlying { get; }\n}\n\n// ✅ 可游泳动物接口\npublic interface ISwimmable\n{\n    float SwimSpeed { get; }\n    void Swim(Vector3 direction);\n    bool IsSwimming { get; }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#2-具体动物实现","level":4,"title":"2. 具体动物实现","text":"<pre><code>// ✅ 企鹅：只实现它能做的事情\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class Penguin : Animal, ISwimmable\n{\n    [Title(\"企鹅特有属性\")]\n    [SerializeField, Range(1, 20)] private float swimSpeed = 8f;\n    [SerializeField] private bool isSwimming = false;\n\n    public float SwimSpeed =&gt; swimSpeed;\n    public bool IsSwimming =&gt; isSwimming;\n\n    public override void Move(Vector3 direction)\n    {\n        // 企鹅在陆地上走路\n        transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在陆地上行走\");\n    }\n\n    public void Swim(Vector3 direction)\n    {\n        isSwimming = true;\n        transform.Translate(direction.normalized * swimSpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在水中游泳\");\n    }\n\n    public override void MakeSound()\n    {\n        Debug.Log(\"企鹅叫：噖噖噖！\");\n    }\n\n    [Button(\"开始/停止游泳\")]\n    public void ToggleSwimming()\n    {\n        isSwimming = !isSwimming;\n    }\n}\n\n// ✅ 鹰：实现飞行能力\npublic class Eagle : Animal, IFlyable\n{\n    [Title(\"鹰特有属性\")]\n    [SerializeField, Range(5, 30)] private float flySpeed = 15f;\n    [SerializeField] private bool isFlying = false;\n\n    public float FlySpeed =&gt; flySpeed;\n    public bool IsFlying =&gt; isFlying;\n\n    public override void Move(Vector3 direction)\n    {\n        if (isFlying)\n        {\n            Fly(direction);\n        }\n        else\n        {\n            // 在地面行走\n            transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n            Debug.Log($\"{animalName} 在地面行走\");\n        }\n    }\n\n    public void Fly(Vector3 direction)\n    {\n        isFlying = true;\n        transform.Translate(direction.normalized * flySpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在天空飞翔\");\n    }\n\n    public void Land()\n    {\n        isFlying = false;\n        Debug.Log($\"{animalName} 已着陆\");\n    }\n\n    public override void MakeSound()\n    {\n        Debug.Log(\"鹰叫：嘛嘛嘛！\");\n    }\n\n    [Button(\"起飞/着陆\")]\n    public void ToggleFlight()\n    {\n        if (isFlying)\n            Land();\n        else\n            isFlying = true;\n    }\n}\n\n// ✅ 鸭子：实现多种能力\npublic class Duck : Animal, IFlyable, ISwimmable\n{\n    [Title(\"鸭子特有属性\")]\n    [SerializeField, Range(3, 15)] private float flySpeed = 10f;\n    [SerializeField, Range(2, 12)] private float swimSpeed = 6f;\n    [SerializeField] private bool isFlying = false;\n    [SerializeField] private bool isSwimming = false;\n\n    public float FlySpeed =&gt; flySpeed;\n    public float SwimSpeed =&gt; swimSpeed;\n    public bool IsFlying =&gt; isFlying;\n    public bool IsSwimming =&gt; isSwimming;\n\n    public override void Move(Vector3 direction)\n    {\n        if (isFlying)\n        {\n            Fly(direction);\n        }\n        else if (isSwimming)\n        {\n            Swim(direction);\n        }\n        else\n        {\n            // 在陆地行走\n            transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n            Debug.Log($\"{animalName} 在陆地行走\");\n        }\n    }\n\n    public void Fly(Vector3 direction)\n    {\n        isFlying = true;\n        isSwimming = false;\n        transform.Translate(direction.normalized * flySpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在天空飞翔\");\n    }\n\n    public void Land()\n    {\n        isFlying = false;\n        Debug.Log($\"{animalName} 已着陆\");\n    }\n\n    public void Swim(Vector3 direction)\n    {\n        isSwimming = true;\n        isFlying = false;\n        transform.Translate(direction.normalized * swimSpeed * Time.deltaTime);\n        Debug.Log($\"{animalName} 在水中游泳\");\n    }\n\n    public override void MakeSound()\n    {\n        Debug.Log(\"鸭子叫：嘉嘉嘉！\");\n    }\n\n    [Button(\"起飞/着陆\")]\n    public void ToggleFlight()\n    {\n        if (isFlying)\n            Land();\n        else\n        {\n            isFlying = true;\n            isSwimming = false;\n        }\n    }\n\n    [Button(\"开始/停止游泳\")]\n    public void ToggleSwimming()\n    {\n        isSwimming = !isSwimming;\n        if (isSwimming)\n            isFlying = false;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#3-遵循-lsp-的控制器","level":4,"title":"3. 遵循 LSP 的控制器","text":"<pre><code>// ✅ 遵循 LSP 的控制器\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class AnimalController : MonoBehaviour\n{\n    [Title(\"动物集合\")]\n    [SerializeField] private Animal[] allAnimals;\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;IFlyable&gt; flyableAnimals = new List&lt;IFlyable&gt;();\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;ISwimmable&gt; swimmableAnimals = new List&lt;ISwimmable&gt;();\n\n    void Start()\n    {\n        CategorizeAnimals();\n    }\n\n    void CategorizeAnimals()\n    {\n        flyableAnimals.Clear();\n        swimmableAnimals.Clear();\n\n        foreach (var animal in allAnimals)\n        {\n            if (animal is IFlyable flyable)\n                flyableAnimals.Add(flyable);\n\n            if (animal is ISwimmable swimmable)\n                swimmableAnimals.Add(swimmable);\n        }\n    }\n\n    [Button(\"所有动物移动\")]\n    public void MoveAllAnimals()\n    {\n        foreach (var animal in allAnimals)\n        {\n            // 所有动物都能移动，符合 LSP\n            animal.Move(Vector3.forward);\n        }\n    }\n\n    [Button(\"所有动物发声\")]\n    public void MakeAllAnimalsSound()\n    {\n        foreach (var animal in allAnimals)\n        {\n            // 所有动物都能发声，符合 LSP\n            animal.MakeSound();\n        }\n    }\n\n    [Button(\"所有会飞的动物飞行\")]\n    public void MakeAllFlyableAnimalsFly()\n    {\n        foreach (var flyable in flyableAnimals)\n        {\n            flyable.Fly(Vector3.up);\n        }\n    }\n\n    [Button(\"所有会游泳的动物游泳\")]\n    public void MakeAllSwimmableAnimalsSwim()\n    {\n        foreach (var swimmable in swimmableAnimals)\n        {\n            swimmable.Swim(Vector3.forward);\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#lsp-的关键原则","level":3,"title":"LSP 的关键原则","text":"<ol> <li>子类必须能替换基类：在任何使用基类的地方，都可以使用子类</li> <li>不能弱化基类的功能：子类不能抛出基类不会抛出的异常</li> <li>保持行为一致性：子类的行为应该与基类的期望一致</li> <li>子类可以增强功能：但不能删弱原有功能</li> </ol> <p>Odin Inspector 的 LSP 支持</p> <ul> <li>使用 <code>[ShowInInspector]</code> 显示类型信息和状态</li> <li>使用 <code>[Button]</code> 提供不同行为的测试接口</li> <li>使用 <code>[ReadOnly]</code> 防止意外修改关键属性</li> <li>使用 <code>[Title]</code> 清晰区分不同类型的功能</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#i---接口隔离原则-interface-segregation-principle","level":2,"title":"I - 接口隔离原则 (Interface Segregation Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#原理阐述_3","level":3,"title":"原理阐述","text":"<p>接口隔离原则要求：不应该强迫客户端依赖于它们不使用的接口。接口应该细粒度且专门针对特定的客户端需求。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#违反-isp-的问题示例","level":3,"title":"违反 ISP 的问题示例","text":"<p>考虑一个臃胖的游戏对象接口：</p> <pre><code>// ❌ 违反接口隔离原则的臃胖接口\npublic interface IBloatedGameObject\n{\n    // 移动相关\n    void Move(Vector3 direction);\n    void Stop();\n    float GetSpeed();\n\n    // 战斗相关\n    void Attack(GameObject target);\n    void TakeDamage(float damage);\n    float GetHealth();\n\n    // 道具相关\n    void UseItem(int itemId);\n    void PickupItem(GameObject item);\n    void DropItem(int itemId);\n\n    // NPC 对话相关\n    void StartDialogue();\n    void EndDialogue();\n    string GetDialogueText();\n\n    // 商店相关\n    void OpenShop();\n    void BuyItem(int itemId);\n    void SellItem(int itemId);\n\n    // 任务相关\n    void AcceptQuest(int questId);\n    void CompleteQuest(int questId);\n    void GetQuestProgress(int questId);\n}\n\n// 问题：武器物品不需要对话和商店功能\npublic class Weapon : MonoBehaviour, IBloatedGameObject\n{\n    public void Move(Vector3 direction) { /* 正常实现 */ }\n    public void Stop() { /* 正常实现 */ }\n    public float GetSpeed() { return 0; }\n\n    public void Attack(GameObject target) { /* 正常实现 */ }\n    public void TakeDamage(float damage) { /* 正常实现 */ }\n    public float GetHealth() { return 100; }\n\n    // 不需要的方法，但被迫实现\n    public void UseItem(int itemId) { throw new System.NotImplementedException(); }\n    public void PickupItem(GameObject item) { throw new System.NotImplementedException(); }\n    public void DropItem(int itemId) { throw new System.NotImplementedException(); }\n\n    public void StartDialogue() { throw new System.NotImplementedException(); }\n    public void EndDialogue() { throw new System.NotImplementedException(); }\n    public string GetDialogueText() { throw new System.NotImplementedException(); }\n\n    public void OpenShop() { throw new System.NotImplementedException(); }\n    public void BuyItem(int itemId) { throw new System.NotImplementedException(); }\n    public void SellItem(int itemId) { throw new System.NotImplementedException(); }\n\n    public void AcceptQuest(int questId) { throw new System.NotImplementedException(); }\n    public void CompleteQuest(int questId) { throw new System.NotImplementedException(); }\n    public void GetQuestProgress(int questId) { throw new System.NotImplementedException(); }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#遵循-isp-的重构方案","level":3,"title":"遵循 ISP 的重构方案","text":"<p>将臃胖接口拆分为多个细粒度的接口：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#1-细粒度接口定义","level":4,"title":"1. 细粒度接口定义","text":"<pre><code>// ✅ 移动能力接口\npublic interface IMoveable\n{\n    void Move(Vector3 direction);\n    void Stop();\n    float Speed { get; set; }\n}\n\n// ✅ 战斗能力接口\npublic interface ICombatable\n{\n    void Attack(GameObject target);\n    void TakeDamage(float damage);\n    float Health { get; }\n    float MaxHealth { get; }\n    bool IsAlive { get; }\n}\n\n// ✅ 道具使用接口\npublic interface IItemUser\n{\n    void UseItem(int itemId);\n    void PickupItem(GameObject item);\n    void DropItem(int itemId);\n    int[] GetInventory();\n}\n\n// ✅ 对话能力接口\npublic interface IDialogable\n{\n    void StartDialogue();\n    void EndDialogue();\n    string GetDialogueText();\n    bool IsInDialogue { get; }\n}\n\n// ✅ 商店接口\npublic interface IShopkeeper\n{\n    void OpenShop();\n    void BuyItem(int itemId, int quantity);\n    void SellItem(int itemId, int quantity);\n    bool HasItem(int itemId);\n    int GetItemPrice(int itemId);\n}\n\n// ✅ 任务系统接口\npublic interface IQuestGiver\n{\n    void GiveQuest(int questId);\n    bool CanGiveQuest(int questId);\n}\n\npublic interface IQuestReceiver\n{\n    void AcceptQuest(int questId);\n    void CompleteQuest(int questId);\n    float GetQuestProgress(int questId);\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#2-精简的实现类","level":4,"title":"2. 精简的实现类","text":"<pre><code>// ✅ 武器：只实现需要的接口\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class Weapon : MonoBehaviour, IMoveable, ICombatable\n{\n    [Title(\"武器属性\")]\n    [SerializeField, Range(1, 20)] private float speed = 5f;\n    [SerializeField, Range(10, 100)] private float health = 50f;\n    [SerializeField, Range(10, 100)] private float maxHealth = 50f;\n    [SerializeField, Range(10, 50)] private float damage = 25f;\n\n    public float Speed \n    { \n        get =&gt; speed; \n        set =&gt; speed = Mathf.Max(0, value); \n    }\n\n    public float Health =&gt; health;\n    public float MaxHealth =&gt; maxHealth;\n    public bool IsAlive =&gt; health &gt; 0;\n\n    public void Move(Vector3 direction)\n    {\n        transform.Translate(direction.normalized * speed * Time.deltaTime);\n    }\n\n    public void Stop()\n    {\n        // 停止移动逻辑\n    }\n\n    public void Attack(GameObject target)\n    {\n        if (target.TryGetComponent&lt;ICombatable&gt;(out var combatable))\n        {\n            combatable.TakeDamage(damage);\n        }\n    }\n\n    public void TakeDamage(float damage)\n    {\n        health = Mathf.Max(0, health - damage);\n        if (!IsAlive)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n\n// ✅ NPC：实现多个相关接口\npublic class NPC : MonoBehaviour, IMoveable, ICombatable, IDialogable, IShopkeeper\n{\n    [Title(\"NPC 基本属性\")]\n    [SerializeField, Range(1, 10)] private float speed = 3f;\n    [SerializeField, Range(50, 200)] private float health = 100f;\n    [SerializeField, Range(50, 200)] private float maxHealth = 100f;\n\n    [Title(\"对话系统\")]\n    [SerializeField] private string[] dialogueLines;\n    [SerializeField] private bool isInDialogue = false;\n\n    [Title(\"商店系统\")]\n    [SerializeField] private int[] shopItems;\n    [SerializeField] private int[] itemPrices;\n\n    // IMoveable 实现\n    public float Speed \n    { \n        get =&gt; speed; \n        set =&gt; speed = Mathf.Max(0, value); \n    }\n\n    public void Move(Vector3 direction)\n    {\n        if (!isInDialogue)\n            transform.Translate(direction.normalized * speed * Time.deltaTime);\n    }\n\n    public void Stop() { }\n\n    // ICombatable 实现\n    public float Health =&gt; health;\n    public float MaxHealth =&gt; maxHealth;\n    public bool IsAlive =&gt; health &gt; 0;\n\n    public void Attack(GameObject target)\n    {\n        // NPC 攻击逻辑\n    }\n\n    public void TakeDamage(float damage)\n    {\n        health = Mathf.Max(0, health - damage);\n    }\n\n    // IDialogable 实现\n    public bool IsInDialogue =&gt; isInDialogue;\n\n    public void StartDialogue()\n    {\n        isInDialogue = true;\n        Stop();\n    }\n\n    public void EndDialogue()\n    {\n        isInDialogue = false;\n    }\n\n    public string GetDialogueText()\n    {\n        return dialogueLines[Random.Range(0, dialogueLines.Length)];\n    }\n\n    // IShopkeeper 实现\n    public void OpenShop()\n    {\n        Debug.Log(\"NPC 商店开启\");\n    }\n\n    public void BuyItem(int itemId, int quantity)\n    {\n        // 购买逻辑\n    }\n\n    public void SellItem(int itemId, int quantity)\n    {\n        // 出售逻辑\n    }\n\n    public bool HasItem(int itemId)\n    {\n        return System.Array.Exists(shopItems, item =&gt; item == itemId);\n    }\n\n    public int GetItemPrice(int itemId)\n    {\n        int index = System.Array.IndexOf(shopItems, itemId);\n        return index &gt;= 0 ? itemPrices[index] : 0;\n    }\n}\n\n// ✅ 玩家：实现与玩家相关的接口\npublic class Player : MonoBehaviour, IMoveable, ICombatable, IItemUser, IQuestReceiver\n{\n    [Title(\"玩家属性\")]\n    [SerializeField] private float speed = 8f;\n    [SerializeField] private float health = 100f;\n    [SerializeField] private float maxHealth = 100f;\n\n    [Title(\"道具系统\")]\n    [SerializeField] private int[] inventory = new int[10];\n\n    [Title(\"任务系统\")]\n    [SerializeField] private int[] activeQuests = new int[5];\n\n    // 实现所有需要的接口方法...\n    public float Speed { get =&gt; speed; set =&gt; speed = value; }\n    public float Health =&gt; health;\n    public float MaxHealth =&gt; maxHealth;\n    public bool IsAlive =&gt; health &gt; 0;\n\n    public void Move(Vector3 direction)\n    {\n        transform.Translate(direction.normalized * speed * Time.deltaTime);\n    }\n\n    public void Stop() { }\n\n    public void Attack(GameObject target) \n    {\n        // 玩家攻击逻辑\n    }\n\n    public void TakeDamage(float damage)\n    {\n        health = Mathf.Max(0, health - damage);\n    }\n\n    public void UseItem(int itemId) { /* 使用道具 */ }\n    public void PickupItem(GameObject item) { /* 拾取道具 */ }\n    public void DropItem(int itemId) { /* 丢弃道具 */ }\n    public int[] GetInventory() =&gt; inventory;\n\n    public void AcceptQuest(int questId) { /* 接受任务 */ }\n    public void CompleteQuest(int questId) { /* 完成任务 */ }\n    public float GetQuestProgress(int questId) { return 0f; }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#isp-的优势","level":3,"title":"ISP 的优势","text":"<ol> <li>接口精简：每个接口只包含相关的方法</li> <li>降低耦合：类只依赖于它们实际使用的接口</li> <li>易于维护：修改一个接口不会影响不相关的类</li> <li>提高单元测试效率：可以单独模拟每个细粒度接口</li> </ol> <p>Odin Inspector 的 ISP 支持</p> <ul> <li>使用 <code>[Title]</code> 将不同接口的功能分组显示</li> <li>使用 <code>[ShowInInspector]</code> 适度暴露接口状态</li> <li>使用 <code>[Required]</code> 确保接口依赖的完整性</li> <li>使用 <code>[Button]</code> 为每个接口提供测试入口</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#d---依赖倒置原则-dependency-inversion-principle","level":2,"title":"D - 依赖倒置原则 (Dependency Inversion Principle)","text":"","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#原理阐述_4","level":3,"title":"原理阐述","text":"<p>依赖倒置原则包含两个重要概念：</p> <ol> <li>高层模块不应该依赖于低层模块，两者都应该依赖于抽象</li> <li>抽象不应该依赖于实现，实现应该依赖于抽象</li> </ol> <p>这个原则的核心是通过抽象（接口或抽象类）来降低模块间的耦合度。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#违反-dip-的问题示例","level":3,"title":"违反 DIP 的问题示例","text":"<p>考虑一个游戏保存系统：</p> <pre><code>// ❌ 违反依赖倒置原则的设计\npublic class FileDataStorage\n{\n    public void SaveData(string data, string filename)\n    {\n        System.IO.File.WriteAllText(filename, data);\n        Debug.Log(\"数据已保存到文件: \" + filename);\n    }\n\n    public string LoadData(string filename)\n    {\n        if (System.IO.File.Exists(filename))\n        {\n            return System.IO.File.ReadAllText(filename);\n        }\n        return string.Empty;\n    }\n}\n\n// 问题：高层的 GameManager 直接依赖于低层的 FileDataStorage\npublic class BadGameManager : MonoBehaviour\n{\n    private FileDataStorage fileStorage; // 直接依赖具体实现\n\n    void Start()\n    {\n        fileStorage = new FileDataStorage(); // 紧耦合\n    }\n\n    public void SaveGame()\n    {\n        string gameData = GetGameData();\n        fileStorage.SaveData(gameData, \"savegame.json\"); // 直接调用具体实现\n    }\n\n    public void LoadGame()\n    {\n        string gameData = fileStorage.LoadData(\"savegame.json\");\n        ApplyGameData(gameData);\n    }\n\n    // 要更换为云存储，必须修改这个类\n    // 要支持多种存储方式，需要大量修改\n\n    private string GetGameData() { return \"{}\"; }\n    private void ApplyGameData(string data) { }\n}\n</code></pre> <p>这种设计的问题：</p> <ul> <li><code>GameManager</code>（高层）直接依赖于 <code>FileDataStorage</code>（低层）</li> <li>难以扩展为云存储或其他存储方式</li> <li>难以进行单元测试（无法模拟存储）</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#遵循-dip-的重构方案","level":3,"title":"遵循 DIP 的重构方案","text":"<p>通过抽象接口和依赖注入来解决问题：</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#1-定义抽象接口","level":4,"title":"1. 定义抽象接口","text":"<pre><code>// ✅ 存储系统抽象接口\npublic interface IDataStorage\n{\n    void SaveData(string data, string key);\n    string LoadData(string key);\n    bool HasData(string key);\n    void DeleteData(string key);\n}\n\n// ✅ 事件系统抽象接口\npublic interface IEventSystem\n{\n    void Subscribe&lt;T&gt;(System.Action&lt;T&gt; handler) where T : class;\n    void Unsubscribe&lt;T&gt;(System.Action&lt;T&gt; handler) where T : class;\n    void Publish&lt;T&gt;(T eventData) where T : class;\n}\n\n// ✅ 日志系统抽象接口\npublic interface ILogger\n{\n    void Log(string message);\n    void LogWarning(string message);\n    void LogError(string message);\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#2-具体实现低层模块","level":4,"title":"2. 具体实现（低层模块）","text":"<pre><code>// ✅ 文件存储实现\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing System.IO;\n\npublic class FileDataStorage : IDataStorage\n{\n    [Title(\"文件存储配置\")]\n    [SerializeField, FolderPath] private string saveDirectory = \"SaveData\";\n    [SerializeField] private string fileExtension = \".json\";\n\n    public void SaveData(string data, string key)\n    {\n        string fullPath = GetFullPath(key);\n        Directory.CreateDirectory(Path.GetDirectoryName(fullPath));\n        File.WriteAllText(fullPath, data);\n        Debug.Log($\"数据已保存到: {fullPath}\");\n    }\n\n    public string LoadData(string key)\n    {\n        string fullPath = GetFullPath(key);\n        if (File.Exists(fullPath))\n        {\n            return File.ReadAllText(fullPath);\n        }\n        Debug.LogWarning($\"文件不存在: {fullPath}\");\n        return string.Empty;\n    }\n\n    public bool HasData(string key)\n    {\n        return File.Exists(GetFullPath(key));\n    }\n\n    public void DeleteData(string key)\n    {\n        string fullPath = GetFullPath(key);\n        if (File.Exists(fullPath))\n        {\n            File.Delete(fullPath);\n            Debug.Log($\"文件已删除: {fullPath}\");\n        }\n    }\n\n    private string GetFullPath(string key)\n    {\n        return Path.Combine(Application.persistentDataPath, saveDirectory, key + fileExtension);\n    }\n}\n\n// ✅ PlayerPrefs 存储实现\npublic class PlayerPrefsDataStorage : IDataStorage\n{\n    public void SaveData(string data, string key)\n    {\n        PlayerPrefs.SetString(key, data);\n        PlayerPrefs.Save();\n        Debug.Log($\"数据已保存到 PlayerPrefs: {key}\");\n    }\n\n    public string LoadData(string key)\n    {\n        return PlayerPrefs.GetString(key, string.Empty);\n    }\n\n    public bool HasData(string key)\n    {\n        return PlayerPrefs.HasKey(key);\n    }\n\n    public void DeleteData(string key)\n    {\n        PlayerPrefs.DeleteKey(key);\n        PlayerPrefs.Save();\n        Debug.Log($\"PlayerPrefs 键已删除: {key}\");\n    }\n}\n\n// ✅ Unity 日志实现\npublic class UnityLogger : ILogger\n{\n    public void Log(string message)\n    {\n        Debug.Log($\"[INFO] {message}\");\n    }\n\n    public void LogWarning(string message)\n    {\n        Debug.LogWarning($\"[WARNING] {message}\");\n    }\n\n    public void LogError(string message)\n    {\n        Debug.LogError($\"[ERROR] {message}\");\n    }\n}\n\n// ✅ 简单事件系统实现\nusing System.Collections.Generic;\nusing System;\n\npublic class SimpleEventSystem : IEventSystem\n{\n    private Dictionary&lt;Type, List&lt;Delegate&gt;&gt; eventHandlers = new Dictionary&lt;Type, List&lt;Delegate&gt;&gt;();\n\n    public void Subscribe&lt;T&gt;(Action&lt;T&gt; handler) where T : class\n    {\n        Type eventType = typeof(T);\n        if (!eventHandlers.ContainsKey(eventType))\n        {\n            eventHandlers[eventType] = new List&lt;Delegate&gt;();\n        }\n        eventHandlers[eventType].Add(handler);\n    }\n\n    public void Unsubscribe&lt;T&gt;(Action&lt;T&gt; handler) where T : class\n    {\n        Type eventType = typeof(T);\n        if (eventHandlers.ContainsKey(eventType))\n        {\n            eventHandlers[eventType].Remove(handler);\n        }\n    }\n\n    public void Publish&lt;T&gt;(T eventData) where T : class\n    {\n        Type eventType = typeof(T);\n        if (eventHandlers.ContainsKey(eventType))\n        {\n            foreach (var handler in eventHandlers[eventType])\n            {\n                (handler as Action&lt;T&gt;)?.Invoke(eventData);\n            }\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#3-依赖注入容器","level":4,"title":"3. 依赖注入容器","text":"<pre><code>// ✅ 简单的依赖注入容器\nusing System;\nusing System.Collections.Generic;\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic class ServiceContainer : MonoBehaviour\n{\n    private static ServiceContainer instance;\n    public static ServiceContainer Instance \n    { \n        get\n        {\n            if (instance == null)\n            {\n                instance = FindObjectOfType&lt;ServiceContainer&gt;();\n                if (instance == null)\n                {\n                    GameObject go = new GameObject(\"ServiceContainer\");\n                    instance = go.AddComponent&lt;ServiceContainer&gt;();\n                    DontDestroyOnLoad(go);\n                }\n            }\n            return instance;\n        }\n    }\n\n    [Title(\"服务配置\")]\n    [SerializeField] private bool useFileStorage = true;\n    [SerializeField] private bool useUnityLogger = true;\n\n    private Dictionary&lt;Type, object&gt; services = new Dictionary&lt;Type, object&gt;();\n\n    void Awake()\n    {\n        if (instance == null)\n        {\n            instance = this;\n            DontDestroyOnLoad(gameObject);\n            RegisterServices();\n        }\n        else if (instance != this)\n        {\n            Destroy(gameObject);\n        }\n    }\n\n    void RegisterServices()\n    {\n        // 注册存储服务\n        if (useFileStorage)\n        {\n            Register&lt;IDataStorage&gt;(new FileDataStorage());\n        }\n        else\n        {\n            Register&lt;IDataStorage&gt;(new PlayerPrefsDataStorage());\n        }\n\n        // 注册日志服务\n        if (useUnityLogger)\n        {\n            Register&lt;ILogger&gt;(new UnityLogger());\n        }\n\n        // 注册事件系统\n        Register&lt;IEventSystem&gt;(new SimpleEventSystem());\n    }\n\n    public void Register&lt;T&gt;(T service)\n    {\n        services[typeof(T)] = service;\n    }\n\n    public T Get&lt;T&gt;()\n    {\n        Type serviceType = typeof(T);\n        if (services.ContainsKey(serviceType))\n        {\n            return (T)services[serviceType];\n        }\n        throw new InvalidOperationException($\"服务 {serviceType.Name} 未注册\");\n    }\n\n    [Button(\"显示所有已注册的服务\")]\n    public void ShowRegisteredServices()\n    {\n        Debug.Log(\"已注册的服务:\");\n        foreach (var service in services)\n        {\n            Debug.Log($\"- {service.Key.Name}: {service.Value.GetType().Name}\");\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#4-遵循-dip-的高层模块","level":4,"title":"4. 遵循 DIP 的高层模块","text":"<pre><code>// ✅ 遵循依赖倒置原则的 GameManager\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing System;\n\npublic class GameManager : MonoBehaviour\n{\n    [Title(\"依赖服务\")]\n    [ShowInInspector, ReadOnly] private IDataStorage dataStorage;\n    [ShowInInspector, ReadOnly] private ILogger logger;\n    [ShowInInspector, ReadOnly] private IEventSystem eventSystem;\n\n    [Title(\"游戏状态\")]\n    [SerializeField] private int playerLevel = 1;\n    [SerializeField] private float playerHealth = 100f;\n    [SerializeField] private int playerScore = 0;\n\n    void Start()\n    {\n        // 依赖注入：通过抽象接口获取服务\n        InjectDependencies();\n\n        // 设置事件监听\n        SetupEventListeners();\n\n        logger.Log(\"GameManager 已初始化\");\n    }\n\n    void InjectDependencies()\n    {\n        try\n        {\n            dataStorage = ServiceContainer.Instance.Get&lt;IDataStorage&gt;();\n            logger = ServiceContainer.Instance.Get&lt;ILogger&gt;();\n            eventSystem = ServiceContainer.Instance.Get&lt;IEventSystem&gt;();\n        }\n        catch (Exception ex)\n        {\n            Debug.LogError($\"依赖注入失败: {ex.Message}\");\n        }\n    }\n\n    void SetupEventListeners()\n    {\n        eventSystem.Subscribe&lt;PlayerLevelUpEvent&gt;(OnPlayerLevelUp);\n        eventSystem.Subscribe&lt;PlayerHealthChangedEvent&gt;(OnPlayerHealthChanged);\n    }\n\n    [Button(\"保存游戏\")]\n    public void SaveGame()\n    {\n        try\n        {\n            var gameData = new GameData\n            {\n                level = playerLevel,\n                health = playerHealth,\n                score = playerScore,\n                saveTime = DateTime.Now.ToString()\n            };\n\n            string jsonData = JsonUtility.ToJson(gameData, true);\n            dataStorage.SaveData(jsonData, \"savegame\");\n\n            logger.Log(\"游戏已保存\");\n        }\n        catch (Exception ex)\n        {\n            logger.LogError($\"保存游戏失败: {ex.Message}\");\n        }\n    }\n\n    [Button(\"加载游戏\")]\n    public void LoadGame()\n    {\n        try\n        {\n            if (dataStorage.HasData(\"savegame\"))\n            {\n                string jsonData = dataStorage.LoadData(\"savegame\");\n                var gameData = JsonUtility.FromJson&lt;GameData&gt;(jsonData);\n\n                playerLevel = gameData.level;\n                playerHealth = gameData.health;\n                playerScore = gameData.score;\n\n                logger.Log($\"游戏已加载（保存时间: {gameData.saveTime}）\");\n            }\n            else\n            {\n                logger.LogWarning(\"未找到存档文件\");\n            }\n        }\n        catch (Exception ex)\n        {\n            logger.LogError($\"加载游戏失败: {ex.Message}\");\n        }\n    }\n\n    [Button(\"玩家升级\")]\n    public void LevelUp()\n    {\n        playerLevel++;\n        eventSystem.Publish(new PlayerLevelUpEvent { NewLevel = playerLevel });\n    }\n\n    void OnPlayerLevelUp(PlayerLevelUpEvent eventData)\n    {\n        logger.Log($\"玩家升级到 {eventData.NewLevel} 级！\");\n    }\n\n    void OnPlayerHealthChanged(PlayerHealthChangedEvent eventData)\n    {\n        logger.Log($\"玩家血量变为 {eventData.NewHealth}\");\n    }\n\n    void OnDestroy()\n    {\n        if (eventSystem != null)\n        {\n            eventSystem.Unsubscribe&lt;PlayerLevelUpEvent&gt;(OnPlayerLevelUp);\n            eventSystem.Unsubscribe&lt;PlayerHealthChangedEvent&gt;(OnPlayerHealthChanged);\n        }\n    }\n}\n\n// ✅ 事件数据类\n[System.Serializable]\npublic class GameData\n{\n    public int level;\n    public float health;\n    public int score;\n    public string saveTime;\n}\n\npublic class PlayerLevelUpEvent\n{\n    public int NewLevel { get; set; }\n}\n\npublic class PlayerHealthChangedEvent\n{\n    public float NewHealth { get; set; }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#dip-的优势","level":3,"title":"DIP 的优势","text":"<ol> <li>降低耦合度：高层模块不直接依赖低层实现</li> <li>提高灵活性：可以轻松替换不同的实现</li> <li>便于测试：可以轻松模拟依赖的服务</li> <li>易于扔展：添加新的实现无需修改高层代码</li> </ol> <p>Odin Inspector 的 DIP 支持</p> <ul> <li>使用 <code>[ShowInInspector]</code> 显示注入的依赖服务<ul> <li>使用 <code>[Button]</code> 提供服务测试功能</li> <li>使用 <code>[ReadOnly]</code> 防止意外修改注入的服务</li> <li>使用 <code>[Title]</code> 组织不同类型的依赖关系</li> </ul> </li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#unity-实战应用案例角色系统重构","level":2,"title":"Unity 实战应用案例：角色系统重构","text":"<p>让我们通过一个完整的案例来看看如何将 SOLID 原则应用到 Unity 项目中。我们将重构一个传统的角色系统，使其遵循所有 SOLID 原则。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#原始设计违反-solid-原则","level":3,"title":"原始设计：违反 SOLID 原则","text":"<p>这是一个典型的“神类”设计：</p> <pre><code>// ❌ 违反多个 SOLID 原则的角色系统\npublic class BadCharacter : MonoBehaviour\n{\n    // 违反 SRP：一个类承担太多职责\n    public float health = 100f;\n    public float maxHealth = 100f;\n    public float moveSpeed = 5f;\n    public float attackDamage = 25f;\n    public float attackRange = 2f;\n    public string[] inventory = new string[10];\n    public int level = 1;\n    public int experience = 0;\n\n    // 各种系统混在一起\n    void Update()\n    {\n        HandleMovement();\n        HandleCombat();\n        HandleLevelUp();\n        UpdateUI();\n        HandleInventory();\n    }\n\n    // 违反 OCP：添加新角色类型需要修改这个方法\n    void HandleMovement()\n    {\n        // 处理不同类型的移动\n        if (gameObject.name.Contains(\"Warrior\"))\n        {\n            // 战士移动逻辑\n        }\n        else if (gameObject.name.Contains(\"Mage\"))\n        {\n            // 法师移动逻辑\n        }\n        // ... 更多类型\n    }\n\n    // 其他方法...\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#重构后遵循-solid-原则的设计","level":3,"title":"重构后：遵循 SOLID 原则的设计","text":"<p>让我们将这个系统重构为遵循 SOLID 原则的架构。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#1-应用-srp职责分离","level":4,"title":"1. 应用 SRP：职责分离","text":"<pre><code>// ✅ 健康系统（单一职责）\nusing Sirenix.OdinInspector;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class HealthSystem : MonoBehaviour\n{\n    [Title(\"健康配置\")]\n    [SerializeField, Range(1, 1000)] private float maxHealth = 100f;\n    [SerializeField] private bool regenerateHealth = true;\n    [SerializeField, ShowIf(\"regenerateHealth\")] private float regenRate = 5f;\n\n    [ShowInInspector, ReadOnly, ProgressBar(0, \"maxHealth\", ColorGetter = \"GetHealthColor\")]\n    private float currentHealth;\n\n    [Title(\"事件\")]\n    public UnityEvent&lt;float&gt; OnHealthChanged;\n    public UnityEvent&lt;float, float&gt; OnDamageTaken; // damage, remaining health\n    public UnityEvent OnDeath;\n    public UnityEvent OnFullyHealed;\n\n    public float CurrentHealth =&gt; currentHealth;\n    public float MaxHealth =&gt; maxHealth;\n    public float HealthPercentage =&gt; currentHealth / maxHealth;\n    public bool IsAlive =&gt; currentHealth &gt; 0;\n    public bool IsAtFullHealth =&gt; Mathf.Approximately(currentHealth, maxHealth);\n\n    void Start()\n    {\n        currentHealth = maxHealth;\n    }\n\n    void Update()\n    {\n        if (regenerateHealth &amp;&amp; !IsAtFullHealth &amp;&amp; IsAlive)\n        {\n            Heal(regenRate * Time.deltaTime);\n        }\n    }\n\n    public void TakeDamage(float damage)\n    {\n        if (!IsAlive || damage &lt;= 0) return;\n\n        float previousHealth = currentHealth;\n        currentHealth = Mathf.Max(0, currentHealth - damage);\n\n        OnHealthChanged?.Invoke(currentHealth);\n        OnDamageTaken?.Invoke(damage, currentHealth);\n\n        if (!IsAlive)\n        {\n            OnDeath?.Invoke();\n        }\n    }\n\n    public void Heal(float amount)\n    {\n        if (!IsAlive || amount &lt;= 0 || IsAtFullHealth) return;\n\n        currentHealth = Mathf.Min(maxHealth, currentHealth + amount);\n        OnHealthChanged?.Invoke(currentHealth);\n\n        if (IsAtFullHealth)\n        {\n            OnFullyHealed?.Invoke();\n        }\n    }\n\n    public void SetMaxHealth(float newMaxHealth)\n    {\n        float ratio = HealthPercentage;\n        maxHealth = Mathf.Max(1, newMaxHealth);\n        currentHealth = maxHealth * ratio;\n        OnHealthChanged?.Invoke(currentHealth);\n    }\n\n    private Color GetHealthColor()\n    {\n        float percentage = HealthPercentage;\n        if (percentage &gt; 0.6f) return Color.green;\n        if (percentage &gt; 0.3f) return Color.yellow;\n        return Color.red;\n    }\n}\n\n// ✅ 经验系统（单一职责）\npublic class ExperienceSystem : MonoBehaviour\n{\n    [Title(\"经验配置\")]\n    [SerializeField] private int currentLevel = 1;\n    [SerializeField] private int currentExperience = 0;\n    [SerializeField] private int baseExperienceToNext = 100;\n    [SerializeField, Range(1.1f, 2f)] private float experienceMultiplier = 1.5f;\n\n    [ShowInInspector, ReadOnly]\n    private int experienceToNextLevel;\n\n    [Title(\"事件\")]\n    public UnityEvent&lt;int&gt; OnLevelUp;\n    public UnityEvent&lt;int&gt; OnExperienceGained;\n\n    public int Level =&gt; currentLevel;\n    public int Experience =&gt; currentExperience;\n    public int ExperienceToNext =&gt; experienceToNextLevel;\n    public float ExperienceProgress =&gt; (float)currentExperience / experienceToNextLevel;\n\n    void Start()\n    {\n        CalculateExperienceToNext();\n    }\n\n    public void GainExperience(int amount)\n    {\n        if (amount &lt;= 0) return;\n\n        currentExperience += amount;\n        OnExperienceGained?.Invoke(amount);\n\n        while (currentExperience &gt;= experienceToNextLevel)\n        {\n            LevelUp();\n        }\n    }\n\n    void LevelUp()\n    {\n        currentExperience -= experienceToNextLevel;\n        currentLevel++;\n        CalculateExperienceToNext();\n        OnLevelUp?.Invoke(currentLevel);\n    }\n\n    void CalculateExperienceToNext()\n    {\n        experienceToNextLevel = Mathf.RoundToInt(baseExperienceToNext * Mathf.Pow(experienceMultiplier, currentLevel - 1));\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#2-应用-ocp角色类型的可扩展设计","level":4,"title":"2. 应用 OCP：角色类型的可扩展设计","text":"<pre><code>// ✅ 角色能力接口（对扩展开放）\npublic interface IMoveable\n{\n    float MoveSpeed { get; set; }\n    void Move(Vector3 direction);\n    void Stop();\n}\n\npublic interface IAttacker\n{\n    float AttackDamage { get; }\n    float AttackRange { get; }\n    void Attack(GameObject target);\n    bool CanAttack(GameObject target);\n}\n\npublic interface ICaster\n{\n    float ManaPoints { get; }\n    float MaxMana { get; }\n    void CastSpell(string spellName, Vector3 target);\n    bool HasEnoughMana(float cost);\n}\n\n// ✅ 基础角色类定义抽象行为\nusing Sirenix.OdinInspector;\nusing UnityEngine;\n\npublic abstract class Character : MonoBehaviour\n{\n    [Title(\"角色基础信息\")]\n    [SerializeField] protected string characterName;\n    [SerializeField] protected int characterLevel = 1;\n\n    [Title(\"组件引用\")]\n    [SerializeField, Required] protected HealthSystem healthSystem;\n    [SerializeField, Required] protected ExperienceSystem experienceSystem;\n\n    [ShowInInspector, ReadOnly]\n    public string CharacterName =&gt; characterName;\n\n    [ShowInInspector, ReadOnly]\n    public int Level =&gt; experienceSystem ? experienceSystem.Level : characterLevel;\n\n    protected virtual void Start()\n    {\n        InitializeCharacter();\n        SetupEventListeners();\n    }\n\n    protected virtual void InitializeCharacter()\n    {\n        if (string.IsNullOrEmpty(characterName))\n            characterName = GetType().Name;\n    }\n\n    protected virtual void SetupEventListeners()\n    {\n        if (healthSystem != null)\n        {\n            healthSystem.OnDeath.AddListener(OnCharacterDeath);\n        }\n\n        if (experienceSystem != null)\n        {\n            experienceSystem.OnLevelUp.AddListener(OnCharacterLevelUp);\n        }\n    }\n\n    protected virtual void OnCharacterDeath()\n    {\n        Debug.Log($\"{characterName} 已死亡\");\n    }\n\n    protected virtual void OnCharacterLevelUp(int newLevel)\n    {\n        Debug.Log($\"{characterName} 升级到 {newLevel} 级！\");\n    }\n\n    protected virtual void OnDestroy()\n    {\n        if (healthSystem != null)\n        {\n            healthSystem.OnDeath.RemoveListener(OnCharacterDeath);\n        }\n\n        if (experienceSystem != null)\n        {\n            experienceSystem.OnLevelUp.RemoveListener(OnCharacterLevelUp);\n        }\n    }\n}\n\n// ✅ 战士类：扩展而非修改\npublic class Warrior : Character, IMoveable, IAttacker\n{\n    [Title(\"战士属性\")]\n    [SerializeField, Range(1, 20)] private float moveSpeed = 5f;\n    [SerializeField, Range(10, 100)] private float attackDamage = 30f;\n    [SerializeField, Range(1, 5)] private float attackRange = 2.5f;\n    [SerializeField, Range(0.5f, 3f)] private float attackCooldown = 1.2f;\n\n    private float lastAttackTime;\n\n    public float MoveSpeed \n    { \n        get =&gt; moveSpeed; \n        set =&gt; moveSpeed = Mathf.Max(0, value); \n    }\n\n    public float AttackDamage =&gt; attackDamage;\n    public float AttackRange =&gt; attackRange;\n\n    public void Move(Vector3 direction)\n    {\n        if (healthSystem &amp;&amp; healthSystem.IsAlive)\n        {\n            transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n        }\n    }\n\n    public void Stop()\n    {\n        // 停止移动逻辑\n    }\n\n    public bool CanAttack(GameObject target)\n    {\n        if (!healthSystem || !healthSystem.IsAlive) return false;\n        if (Time.time &lt; lastAttackTime + attackCooldown) return false;\n\n        float distance = Vector3.Distance(transform.position, target.transform.position);\n        return distance &lt;= attackRange;\n    }\n\n    public void Attack(GameObject target)\n    {\n        if (!CanAttack(target)) return;\n\n        var targetHealth = target.GetComponent&lt;HealthSystem&gt;();\n        if (targetHealth != null)\n        {\n            targetHealth.TakeDamage(attackDamage);\n            lastAttackTime = Time.time;\n            Debug.Log($\"{characterName} 攻击了 {target.name}，造成 {attackDamage} 点伤害\");\n        }\n    }\n}\n\n// ✅ 法师类：新的角色类型，无需修改现有代码\npublic class Mage : Character, IMoveable, ICaster\n{\n    [Title(\"法师属性\")]\n    [SerializeField, Range(1, 15)] private float moveSpeed = 3f;\n    [SerializeField, Range(20, 200)] private float maxMana = 100f;\n    [SerializeField, Range(1, 10)] private float manaRegenRate = 5f;\n\n    [ShowInInspector, ReadOnly, ProgressBar(0, \"maxMana\", r: 0.2f, g: 0.5f, b: 1f)]\n    private float currentMana;\n\n    public float MoveSpeed \n    { \n        get =&gt; moveSpeed; \n        set =&gt; moveSpeed = Mathf.Max(0, value); \n    }\n\n    public float ManaPoints =&gt; currentMana;\n    public float MaxMana =&gt; maxMana;\n\n    protected override void Start()\n    {\n        base.Start();\n        currentMana = maxMana;\n    }\n\n    void Update()\n    {\n        RegenerateMana();\n    }\n\n    public void Move(Vector3 direction)\n    {\n        if (healthSystem &amp;&amp; healthSystem.IsAlive)\n        {\n            transform.Translate(direction.normalized * moveSpeed * Time.deltaTime);\n        }\n    }\n\n    public bool HasEnoughMana(float cost)\n    {\n        return currentMana &gt;= cost;\n    }\n\n    public void CastSpell(string spellName, Vector3 target)\n    {\n        float manaCost = GetSpellCost(spellName);\n        if (!HasEnoughMana(manaCost)) return;\n\n        currentMana -= manaCost;\n\n        switch (spellName.ToLower())\n        {\n            case \"fireball\":\n                CastFireball(target);\n                break;\n            case \"heal\":\n                CastHeal();\n                break;\n            default:\n                Debug.LogWarning($\"未知法术: {spellName}\");\n                break;\n        }\n    }\n\n    void RegenerateMana()\n    {\n        if (currentMana &lt; maxMana)\n        {\n            currentMana = Mathf.Min(maxMana, currentMana + manaRegenRate * Time.deltaTime);\n        }\n    }\n\n    float GetSpellCost(string spellName)\n    {\n        return spellName.ToLower() switch\n        {\n            \"fireball\" =&gt; 20f,\n            \"heal\" =&gt; 30f,\n            _ =&gt; 10f\n        };\n    }\n\n    void CastFireball(Vector3 target)\n    {\n        Debug.Log($\"{characterName} 释放了火球术！\");\n        // 火球法术逻辑\n    }\n\n    void CastHeal()\n    {\n        if (healthSystem != null)\n        {\n            healthSystem.Heal(50f);\n            Debug.Log($\"{characterName} 使用了治疗法术！\");\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#3-应用-lsp-和-isp正确的继承和接口设计","level":4,"title":"3. 应用 LSP 和 ISP：正确的继承和接口设计","text":"<pre><code>// ✅ 遵循 LSP：所有子类都可以替换基类\n// 遵循 ISP：接口精简且不强制依赖\n\npublic class CharacterManager : MonoBehaviour\n{\n    [Title(\"角色管理\")]\n    [SerializeField] private Character[] allCharacters;\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;IMoveable&gt; moveableCharacters = new List&lt;IMoveable&gt;();\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;IAttacker&gt; attackerCharacters = new List&lt;IAttacker&gt;();\n\n    [ShowInInspector, ReadOnly]\n    private List&lt;ICaster&gt; casterCharacters = new List&lt;ICaster&gt;();\n\n    void Start()\n    {\n        CategorizeCharacters();\n    }\n\n    void CategorizeCharacters()\n    {\n        moveableCharacters.Clear();\n        attackerCharacters.Clear();\n        casterCharacters.Clear();\n\n        foreach (var character in allCharacters)\n        {\n            if (character is IMoveable moveable)\n                moveableCharacters.Add(moveable);\n\n            if (character is IAttacker attacker)\n                attackerCharacters.Add(attacker);\n\n            if (character is ICaster caster)\n                casterCharacters.Add(caster);\n        }\n    }\n\n    [Button(\"所有角色向前移动\")]\n    public void MoveAllCharactersForward()\n    {\n        foreach (var moveable in moveableCharacters)\n        {\n            moveable.Move(Vector3.forward);\n        }\n    }\n\n    [Button(\"所有攻击型角色攻击目标\")]\n    public void AllAttackersAttackTarget()\n    {\n        GameObject target = GameObject.FindWithTag(\"Enemy\");\n        if (target != null)\n        {\n            foreach (var attacker in attackerCharacters)\n            {\n                attacker.Attack(target);\n            }\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#总结","level":2,"title":"总结","text":"<p>SOLID 原则是建设高质量 Unity 项目的基石。通过本文的学习，你应该掌握了：</p> <ul> <li>SOLID 五大原则的核心概念和实用方法</li> <li>在 Unity 中的具体应用，从简单的组件分离到复杂的架构设计</li> <li>Odin Inspector 的强大支持，提升开发效率和代码质量</li> <li>实战经验和最佳实践，避免常见陷阱</li> </ul>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#下一步学习建议","level":3,"title":"下一步学习建议","text":"<ol> <li>实践练习：找一个小项目尝试应用所学原则</li> <li>深入学习：研究设计模式如何体现 SOLID 原则</li> <li>工具掌握：学习更多 Odin Inspector 高级特性</li> <li>团队分享：将所学知识分享给团队成员</li> </ol>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-SOLID/#参考资源","level":3,"title":"参考资源","text":"<ul> <li>Unity 官方文档</li> <li>Odin Inspector 文档</li> <li>Unity 官方 Clean Code 电子书：C# 代码风格指南</li> <li>Unity 官方设计模式和 SOLID 原则电子书</li> <li>Martin Fowler 的设计文章</li> </ul> <p>希望这篇文章能帮助你在 Unity 开发中更好地应用 SOLID 原则！如果你有任何问题或建议，欢迎在评论区交流讨论。</p>","path":["Artical","2025 年 11 月","C# SOLID 原则"],"tags":["SOLID"]},{"location":"Artical/csharp-architecture-design/","level":1,"title":"C# 架构设计","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#设计概述","level":2,"title":"设计概述","text":"<p>本文档深入探讨 Unity 中 C# 代码设计的核心理念和实践经验，重点关注代码架构的内功修炼，包括数据容器设计、接口驱动开发、组件化架构等关键方面。通过系统性的设计原则和实战案例，帮助开发者构建高质量、可维护的 Unity 项目。</p>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#核心设计理念","level":2,"title":"核心设计理念","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#数据与行为分离原则","level":3,"title":"数据与行为分离原则","text":"<p>在 Unity 开发中，一个类应该明确其主要职责是作为数据容器还是行为载体。这种分离带来的好处包括：</p> 设计模式 职责定义 优势 适用场景 数据容器类 主要存储状态数据，最小化方法数量 序列化友好、易于调试、数据流清晰 配置数据、游戏状态、持久化对象 行为载体类 主要包含业务逻辑，通过接口暴露能力 职责清晰、易于测试、解耦合度高 系统控制器、服务类、管理器 混合型类 数据与行为并重，通过设计平衡两者 使用便捷、适合小型项目 简单组件、工具类","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#接口驱动的架构设计","level":3,"title":"接口驱动的架构设计","text":"<p>接口在 Unity 开发中扮演着架构契约的重要角色，通过接口可以快速理解类的能力而无需深入实现细节。</p>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#接口设计的核心价值","level":4,"title":"接口设计的核心价值","text":"<pre><code>graph TD\n    A[接口契约] --&gt; B[能力发现]\n    A --&gt; C[依赖解耦]\n    A --&gt; D[测试友好]\n    A --&gt; E[扩展性强]\n    B --&gt; F[快速了解类的职责]\n    C --&gt; G[降低模块间耦合]\n    D --&gt; H[便于单元测试和模拟]\n    E --&gt; I[支持多种实现方式]</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#接口分层策略","level":4,"title":"接口分层策略","text":"<p>Unity 项目中的接口设计应该遵循分层架构：</p> 接口层级 抽象级别 设计目标 示例 核心能力接口 高抽象 定义基础行为契约 <code>IMoveable</code>, <code>IDamageable</code>, <code>IInteractable</code> 系统功能接口 中抽象 定义子系统职责 <code>IInventorySystem</code>, <code>ISaveSystem</code>, <code>IAudioManager</code> 具体实现接口 低抽象 定义特定实现细节 <code>IWeaponController</code>, <code>IPlayerInput</code>, <code>IEnemyAI</code>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#unity-组件化架构设计","level":2,"title":"Unity 组件化架构设计","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#组件化的核心思想","level":3,"title":"组件化的核心思想","text":"<p>Unity 的 Component 系统天然支持组件化开发，应该充分利用这一特性构建松耦合的架构。</p>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#主控制器模式","level":4,"title":"主控制器模式","text":"<p>每个游戏对象应该有一个主要的控制组件，负责协调其他功能组件：</p> <pre><code>graph TD\n    A[主控制器组件] --&gt; B[健康系统组件]\n    A --&gt; C[移动系统组件] \n    A --&gt; D[武器系统组件]\n    A --&gt; E[音效系统组件]\n    A --&gt; F[动画系统组件]\n    A --&gt; G[事件协调]\n    A --&gt; H[状态管理]\n    A --&gt; I[组件通信]</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#组件职责分工表","level":4,"title":"组件职责分工表","text":"组件类型 职责范围 设计特点 通信方式 主控制器 组件协调、状态管理、事件分发 轻量级、接口丰富 UnityEvent、接口调用 功能组件 单一功能实现、状态维护 高内聚、低耦合 事件通知、直接调用 数据组件 配置存储、状态持久化 序列化友好、只读属性 属性访问、配置注入 服务组件 全局服务、跨对象通信 单例模式、生命周期管理 服务定位、依赖注入","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#组件间通信策略","level":3,"title":"组件间通信策略","text":"<p>Unity 组件间通信应该遵循清晰的层次结构：</p>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#通信方式优先级","level":4,"title":"通信方式优先级","text":"<ol> <li>接口调用（推荐）- 强类型、编译时检查</li> <li>UnityEvent（适中）- 松耦合、Inspector 可配置</li> <li>事件系统（谨慎）- 全局通信、需要良好的事件管理</li> <li>静态引用（避免）- 紧耦合、难以测试</li> </ol>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#solid-原则在-unity-中的实践","level":2,"title":"SOLID 原则在 Unity 中的实践","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#单一职责原则srp在组件设计中的应用","level":3,"title":"单一职责原则（SRP）在组件设计中的应用","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#组件职责划分矩阵","level":4,"title":"组件职责划分矩阵","text":"功能领域 组件名称 核心职责 避免职责 生命值管理 HealthComponent 血量计算、伤害处理、死亡状态 UI 更新、音效播放、动画控制 移动控制 MovementComponent 位置变换、速度控制、物理交互 输入处理、AI 决策、动画同步 武器系统 WeaponComponent 武器逻辑、射击机制、弹药管理 伤害计算、目标搜索、特效播放 输入处理 InputComponent 输入采集、命令转换、输入状态 移动执行、技能释放、界面操作","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#开闭原则ocp在扩展性设计中的体现","level":3,"title":"开闭原则（OCP）在扩展性设计中的体现","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#策略模式的游戏应用","level":4,"title":"策略模式的游戏应用","text":"<p>通过接口和策略模式实现对扩展开放、对修改封闭：</p> <pre><code>classDiagram\n    class IWeaponStrategy {\n        +Fire(firePoint, bulletPrefab)\n        +CanFire() bool\n        +GetDamage() float\n    }\n\n    class WeaponSystem {\n        -IWeaponStrategy currentWeapon\n        +EquipWeapon(IWeaponStrategy)\n        +Fire()\n    }\n\n    class PistolStrategy {\n        +Fire()\n        +CanFire()\n        +GetDamage()\n    }\n\n    class RifleStrategy {\n        +Fire()\n        +CanFire()\n        +GetDamage()\n    }\n\n    class ShotgunStrategy {\n        +Fire()\n        +CanFire()\n        +GetDamage()\n    }\n\n    IWeaponStrategy &lt;|-- PistolStrategy\n    IWeaponStrategy &lt;|-- RifleStrategy\n    IWeaponStrategy &lt;|-- ShotgunStrategy\n    WeaponSystem --&gt; IWeaponStrategy</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#依赖倒置原则dip在服务架构中的实现","level":3,"title":"依赖倒置原则（DIP）在服务架构中的实现","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#服务定位器模式","level":4,"title":"服务定位器模式","text":"<p>通过抽象接口和服务容器实现依赖倒置：</p> <pre><code>graph TD\n    A[GameManager&lt;br/&gt;高层模块] --&gt; B[IDataStorage&lt;br/&gt;抽象接口]\n    A --&gt; C[ILogger&lt;br/&gt;抽象接口]\n    A --&gt; D[IAudioManager&lt;br/&gt;抽象接口]\n\n    B --&gt; E[FileDataStorage&lt;br/&gt;具体实现]\n    B --&gt; F[CloudDataStorage&lt;br/&gt;具体实现]\n\n    C --&gt; G[UnityLogger&lt;br/&gt;具体实现]\n    C --&gt; H[FileLogger&lt;br/&gt;具体实现]\n\n    D --&gt; I[UnityAudioManager&lt;br/&gt;具体实现]\n    D --&gt; J[FMODAudioManager&lt;br/&gt;具体实现]</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#数据驱动的架构设计","level":2,"title":"数据驱动的架构设计","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#scriptableobject-作为数据容器","level":3,"title":"ScriptableObject 作为数据容器","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#数据容器设计原则","level":4,"title":"数据容器设计原则","text":"<ol> <li>纯数据存储 - 最小化方法，专注于数据序列化</li> <li>配置驱动 - 通过配置文件控制游戏行为</li> <li>版本兼容 - 考虑数据结构的向后兼容性</li> <li>类型安全 - 使用强类型而非字符串键值</li> </ol>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#数据容器分类策略","level":4,"title":"数据容器分类策略","text":"数据类型 设计模式 序列化方式 使用场景 配置数据 ScriptableObject Unity 原生序列化 游戏平衡性参数、系统配置 状态数据 普通类 + <code>[Serializable]</code> JsonUtility 或第三方 存档数据、运行时状态 临时数据 结构体或简单类 内存存储 帧间传递、计算缓存 引用数据 资源引用 + 配置 AssetReference 预制体配置、资源管理","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#配置与逻辑分离","level":3,"title":"配置与逻辑分离","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#数据驱动的武器系统设计","level":4,"title":"数据驱动的武器系统设计","text":"<pre><code>graph TB\n    A[WeaponConfigSO&lt;br/&gt;武器配置数据] --&gt; B[WeaponController&lt;br/&gt;武器逻辑控制]\n    C[BulletConfigSO&lt;br/&gt;子弹配置数据] --&gt; D[BulletBehaviour&lt;br/&gt;子弹行为逻辑]\n    E[AudioConfigSO&lt;br/&gt;音效配置数据] --&gt; F[AudioManager&lt;br/&gt;音效管理器]\n\n    B --&gt; G[IWeapon&lt;br/&gt;武器接口]\n    D --&gt; H[IBullet&lt;br/&gt;子弹接口]\n    F --&gt; I[IAudioSource&lt;br/&gt;音频接口]</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#事件驱动的通信架构","level":2,"title":"事件驱动的通信架构","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#事件系统的层次设计","level":3,"title":"事件系统的层次设计","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#事件分类与应用场景","level":4,"title":"事件分类与应用场景","text":"事件类型 作用域 生命周期 适用场景 本地事件 组件内部 组件生命周期 状态变化通知、内部逻辑处理 对象事件 GameObject 范围 对象生命周期 组件间通信、功能协调 系统事件 场景或全局 场景或应用生命周期 系统级通知、跨对象通信 业务事件 游戏逻辑 游戏会话 游戏机制、业务流程","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#事件命名和组织规范","level":4,"title":"事件命名和组织规范","text":"<pre><code>graph TD\n    A[事件命名空间] --&gt; B[系统前缀]\n    A --&gt; C[动作描述]\n    A --&gt; D[时态标识]\n\n    B --&gt; E[Player&lt;br/&gt;玩家系统]\n    B --&gt; F[Weapon&lt;br/&gt;武器系统]\n    B --&gt; G[UI&lt;br/&gt;界面系统]\n\n    C --&gt; H[Health&lt;br/&gt;生命相关]\n    C --&gt; I[Level&lt;br/&gt;等级相关]\n    C --&gt; J[Inventory&lt;br/&gt;道具相关]\n\n    D --&gt; K[Changed&lt;br/&gt;已变化]\n    D --&gt; L[ing&lt;br/&gt;正在进行]\n    D --&gt; M[Requested&lt;br/&gt;请求状态]</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#性能优化的设计考量","level":2,"title":"性能优化的设计考量","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#对象池模式在-unity-中的应用","level":3,"title":"对象池模式在 Unity 中的应用","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#池化策略设计","level":4,"title":"池化策略设计","text":"对象类型 池化方式 池大小策略 生命周期管理 频繁创建对象 专用对象池 动态扩展 引用计数 相似对象族 通用对象池 固定大小 时间过期 大型对象 懒加载池 小容量 主动回收 临时对象 栈式池 预分配 作用域回收","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#内存管理和垃圾回收优化","level":3,"title":"内存管理和垃圾回收优化","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#gc-友好的代码设计原则","level":4,"title":"GC 友好的代码设计原则","text":"<ol> <li>减少装箱拆箱 - 使用泛型而非 object 类型</li> <li>避免频繁字符串操作 - 使用 StringBuilder 或对象池</li> <li>缓存频繁计算结果 - 避免每帧重复计算</li> <li>使用结构体存储简单数据 - 减少堆内存分配</li> <li>谨慎使用 LINQ - 在性能关键路径避免使用</li> </ol>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#测试驱动的设计方法","level":2,"title":"测试驱动的设计方法","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#可测试性设计原则","level":3,"title":"可测试性设计原则","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#测试友好的架构特征","level":4,"title":"测试友好的架构特征","text":"<pre><code>graph TD\n    A[可测试架构] --&gt; B[依赖注入]\n    A --&gt; C[接口抽象]\n    A --&gt; D[纯函数设计]\n    A --&gt; E[状态隔离]\n\n    B --&gt; F[模拟依赖]\n    C --&gt; G[契约测试]\n    D --&gt; H[单元测试]\n    E --&gt; I[集成测试]</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#测试分层策略","level":3,"title":"测试分层策略","text":"测试层级 测试对象 测试工具 测试重点 单元测试 单个类或方法 NUnit + NSubstitute 逻辑正确性、边界条件 组件测试 Unity 组件 Unity Test Framework 组件交互、生命周期 集成测试 系统模块 自定义测试框架 模块协作、数据流 端到端测试 完整功能 自动化测试工具 用户体验、性能表现","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#代码组织和模块化","level":2,"title":"代码组织和模块化","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#命名空间和程序集设计","level":3,"title":"命名空间和程序集设计","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#模块划分策略","level":4,"title":"模块划分策略","text":"<pre><code>graph TD\n    A[项目根命名空间] --&gt; B[Core&lt;br/&gt;核心模块]\n    A --&gt; C[Systems&lt;br/&gt;系统模块]\n    A --&gt; D[Components&lt;br/&gt;组件模块]\n    A --&gt; E[Data&lt;br/&gt;数据模块]\n    A --&gt; F[Utils&lt;br/&gt;工具模块]\n\n    B --&gt; G[Interfaces&lt;br/&gt;核心接口]\n    B --&gt; H[Base&lt;br/&gt;基础类]\n    B --&gt; I[Constants&lt;br/&gt;常量定义]\n\n    C --&gt; J[Audio&lt;br/&gt;音频系统]\n    C --&gt; K[Input&lt;br/&gt;输入系统]\n    C --&gt; L[Save&lt;br/&gt;存档系统]</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#文件夹结构和代码组织","level":3,"title":"文件夹结构和代码组织","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#推荐的项目结构","level":4,"title":"推荐的项目结构","text":"目录层级 组织原则 包含内容 命名规范 功能模块 按业务功能划分 相关的类、接口、配置 业务名称 + 模块类型 技术层次 按技术职责划分 相同抽象级别的代码 技术类型 + 功能描述 生命周期 按使用阶段划分 相同生命周期的资源 阶段名称 + 资源类型 依赖关系 按依赖方向划分 低耦合的模块 依赖层级 + 功能名称","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#版本控制和代码维护","level":2,"title":"版本控制和代码维护","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#重构策略和时机","level":3,"title":"重构策略和时机","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#重构决策矩阵","level":4,"title":"重构决策矩阵","text":"重构类型 触发条件 重构范围 风险评估 结构重构 架构腐化、性能问题 模块级别 高风险、需要充分测试 功能重构 需求变更、设计缺陷 功能级别 中风险、影响相关功能 代码重构 代码异味、可读性差 类或方法级别 低风险、局部改进 性能重构 性能瓶颈、资源浪费 算法或数据结构 中风险、需要性能测试","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#代码质量监控","level":3,"title":"代码质量监控","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#质量指标体系","level":4,"title":"质量指标体系","text":"<pre><code>graph TD\n    A[代码质量] --&gt; B[可读性指标]\n    A --&gt; C[可维护性指标]\n    A --&gt; D[可测试性指标]\n    A --&gt; E[性能指标]\n\n    B --&gt; F[代码复杂度]\n    B --&gt; G[命名规范]\n    B --&gt; H[注释质量]\n\n    C --&gt; I[耦合度]\n    C --&gt; J[内聚度]\n    C --&gt; K[重复代码]\n\n    D --&gt; L[测试覆盖率]\n    D --&gt; M[Mock 友好度]\n    D --&gt; N[依赖注入率]\n\n    E --&gt; O[内存使用]\n    E --&gt; P[CPU 占用]\n    E --&gt; Q[GC 压力]</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-架构设计案例分析","level":2,"title":"QFramework 架构设计案例分析","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-的核心设计理念","level":3,"title":"QFramework 的核心设计理念","text":"<p>QFramework 是一个优秀的 Unity 架构框架，其设计充分体现了本文档所述的各项设计原则。通过分析 QFramework 的架构设计，可以更好地理解 Unity 中 C# 代码设计的最佳实践。</p>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-四层架构模型","level":4,"title":"QFramework 四层架构模型","text":"<p>QFramework 采用了清晰的分层架构，完美诠释了职责分离和依赖管理的重要性：</p> <pre><code>graph TD\n    A[IController 表现层] --&gt; B[ISystem 系统层]\n    A --&gt; C[IModel 数据层]\n    B --&gt; C\n    B --&gt; D[IUtility 工具层]\n    C --&gt; D\n\n    E[Command/Query] --&gt; B\n    E --&gt; C\n\n    F[Event/BindableProperty] --&gt; A\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0</code></pre> 层级 职责 依赖关系 通信方式 IController (表现层) 接收输入、状态表现、UI 控制 可获取 System、Model 发送 Command/Query，监听 Event ISystem (系统层) 业务逻辑、跨 Controller 共享逻辑 可获取 System、Model、Utility 监听/发送 Event IModel (数据层) 数据存储、数据操作 可获取 Utility 发送 Event IUtility (工具层) 基础设施、第三方封装 无依赖 纯工具方法","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-中的-solid-原则实践","level":3,"title":"QFramework 中的 SOLID 原则实践","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#单一职责原则的体现","level":4,"title":"单一职责原则的体现","text":"<p>QFramework 通过分层设计确保每个层级都有明确的职责：</p> <pre><code>// ✅ 数据层：只负责数据管理\npublic interface ICounterModel : IModel\n{\n    BindableProperty&lt;int&gt; Count { get; }\n    void IncrementCount();\n    void DecrementCount();\n}\n\n// ✅ 系统层：只负责业务逻辑\npublic interface ICounterSystem : ISystem\n{\n    void ProcessCounterLogic();\n    bool CanIncrement();\n}\n\n// ✅ 表现层：只负责 UI 表现\npublic class CounterController : MonoBehaviour, IController\n{\n    [SerializeField] private Button incrementBtn;\n    [SerializeField] private Button decrementBtn;\n    [SerializeField] private Text countText;\n\n    private ICounterModel counterModel;\n\n    void Start()\n    {\n        counterModel = this.GetModel&lt;ICounterModel&gt;();\n\n        // 数据绑定\n        counterModel.Count.RegisterWithInitValue(OnCountChanged);\n\n        // 事件绑定\n        incrementBtn.onClick.AddListener(() =&gt; \n        {\n            this.SendCommand&lt;IncrementCountCommand&gt;();\n        });\n    }\n\n    void OnCountChanged(int newCount)\n    {\n        countText.text = newCount.ToString();\n    }\n\n    public IArchitecture GetArchitecture() =&gt; CounterApp.Interface;\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#开闭原则的实现","level":4,"title":"开闭原则的实现","text":"<p>QFramework 通过接口和 Command 模式实现对扩展开放、对修改封闭：</p> <pre><code>// ✅ Command 模式：新增功能无需修改现有代码\npublic class IncrementCountCommand : AbstractCommand\n{\n    protected override void OnExecute()\n    {\n        var model = this.GetModel&lt;ICounterModel&gt;();\n        var system = this.GetSystem&lt;ICounterSystem&gt;();\n\n        if (system.CanIncrement())\n        {\n            model.IncrementCount();\n        }\n    }\n}\n\n// 添加新功能：批量增加\npublic class BatchIncrementCommand : AbstractCommand\n{\n    private int amount;\n\n    public BatchIncrementCommand(int amount)\n    {\n        this.amount = amount;\n    }\n\n    protected override void OnExecute()\n    {\n        for (int i = 0; i &lt; amount; i++)\n        {\n            this.SendCommand&lt;IncrementCountCommand&gt;();\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#依赖倒置原则的应用","level":4,"title":"依赖倒置原则的应用","text":"<p>QFramework 通过 Architecture 模式和接口实现依赖倒置：</p> <pre><code>// ✅ Architecture 作为依赖注入容器\npublic class CounterApp : Architecture&lt;CounterApp&gt;\n{\n    protected override void Init()\n    {\n        // 注册 Model\n        this.RegisterModel&lt;ICounterModel&gt;(new CounterModel());\n\n        // 注册 System\n        this.RegisterSystem&lt;ICounterSystem&gt;(new CounterSystem());\n\n        // 注册 Utility\n        this.RegisterUtility&lt;IStorageUtility&gt;(new PlayerPrefsStorage());\n    }\n}\n\n// ✅ 高层模块不依赖具体实现\npublic class CounterModel : AbstractModel, ICounterModel\n{\n    public BindableProperty&lt;int&gt; Count { get; private set; }\n\n    protected override void OnInit()\n    {\n        var storage = this.GetUtility&lt;IStorageUtility&gt;();\n        var savedCount = storage.LoadInt(\"counter\", 0);\n        Count = new BindableProperty&lt;int&gt;(savedCount);\n\n        Count.Register(count =&gt; \n        {\n            storage.SaveInt(\"counter\", count);\n        });\n    }\n\n    public void IncrementCount()\n    {\n        Count.Value++;\n        this.SendEvent&lt;CountChangedEvent&gt;(new CountChangedEvent(Count.Value));\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-的事件驱动设计","level":3,"title":"QFramework 的事件驱动设计","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#类型安全的事件系统","level":4,"title":"类型安全的事件系统","text":"<p>QFramework 提供了类型安全的事件系统，避免了字符串事件的弊端：</p> <pre><code>// ✅ 类型安全的事件定义\npublic struct CountChangedEvent\n{\n    public int NewCount { get; }\n\n    public CountChangedEvent(int newCount)\n    {\n        NewCount = newCount;\n    }\n}\n\n// ✅ 事件的发送和监听\npublic class CounterModel : AbstractModel, ICounterModel\n{\n    public void IncrementCount()\n    {\n        Count.Value++;\n        // 发送强类型事件\n        this.SendEvent&lt;CountChangedEvent&gt;(new CountChangedEvent(Count.Value));\n    }\n}\n\npublic class AchievementSystem : AbstractSystem, IAchievementSystem\n{\n    protected override void OnInit()\n    {\n        // 监听强类型事件\n        this.RegisterEvent&lt;CountChangedEvent&gt;(OnCountChanged);\n    }\n\n    private void OnCountChanged(CountChangedEvent e)\n    {\n        if (e.NewCount &gt;= 100)\n        {\n            UnlockAchievement(\"Master Counter\");\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#bindableproperty-的数据绑定","level":4,"title":"BindableProperty 的数据绑定","text":"<p>QFramework 的 BindableProperty 提供了响应式的数据绑定机制：</p> <pre><code>// ✅ 响应式数据绑定\npublic class PlayerHealthUI : MonoBehaviour, IController\n{\n    [SerializeField] private Slider healthSlider;\n    [SerializeField] private Text healthText;\n\n    private IPlayerModel playerModel;\n\n    void Start()\n    {\n        playerModel = this.GetModel&lt;IPlayerModel&gt;();\n\n        // 数据绑定：自动同步 UI\n        playerModel.Health.RegisterWithInitValue(health =&gt; \n        {\n            healthSlider.value = health / playerModel.MaxHealth.Value;\n            healthText.text = $\"{health}/{playerModel.MaxHealth.Value}\";\n        }).UnRegisterWhenGameObjectDestroyed(gameObject);\n\n        // 多个属性组合绑定\n        playerModel.Health.CombineLatest(playerModel.MaxHealth, (h, max) =&gt; \n        {\n            return new { Health = h, MaxHealth = max };\n        }).Register(data =&gt; \n        {\n            healthSlider.value = (float)data.Health / data.MaxHealth;\n            healthText.text = $\"{data.Health}/{data.MaxHealth}\";\n        }).UnRegisterWhenGameObjectDestroyed(gameObject);\n    }\n\n    public IArchitecture GetArchitecture() =&gt; GameApp.Interface;\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-模块化设计实践","level":3,"title":"QFramework 模块化设计实践","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#可插拔的模块系统","level":4,"title":"可插拔的模块系统","text":"<p>QFramework 支持模块化的系统设计，每个系统都可以独立开发和测试：</p> <pre><code>// ✅ 模块化的系统设计\npublic interface IInventorySystem : ISystem\n{\n    void AddItem(string itemId, int count);\n    void RemoveItem(string itemId, int count);\n    int GetItemCount(string itemId);\n    event System.Action&lt;string, int&gt; OnItemAdded;\n    event System.Action&lt;string, int&gt; OnItemRemoved;\n}\n\npublic class InventorySystem : AbstractSystem, IInventorySystem\n{\n    private Dictionary&lt;string, int&gt; items = new Dictionary&lt;string, int&gt;();\n\n    public event System.Action&lt;string, int&gt; OnItemAdded;\n    public event System.Action&lt;string, int&gt; OnItemRemoved;\n\n    protected override void OnInit()\n    {\n        // 从存储中加载物品数据\n        var storage = this.GetUtility&lt;IStorageUtility&gt;();\n        LoadItemsFromStorage(storage);\n    }\n\n    public void AddItem(string itemId, int count)\n    {\n        if (!items.ContainsKey(itemId))\n            items[itemId] = 0;\n\n        items[itemId] += count;\n        OnItemAdded?.Invoke(itemId, count);\n\n        // 发送事件给其他系统\n        this.SendEvent&lt;ItemAddedEvent&gt;(new ItemAddedEvent(itemId, count));\n    }\n\n    // ... 其他方法实现\n}\n\n// ✅ 系统间的协作\npublic class ShopSystem : AbstractSystem, IShopSystem\n{\n    protected override void OnInit()\n    {\n        // 监听库存变化\n        this.RegisterEvent&lt;ItemAddedEvent&gt;(OnItemAdded);\n    }\n\n    private void OnItemAdded(ItemAddedEvent e)\n    {\n        // 检查是否解锁新商品\n        CheckUnlockNewItems(e.ItemId);\n    }\n\n    public bool PurchaseItem(string itemId, int price)\n    {\n        var playerModel = this.GetModel&lt;IPlayerModel&gt;();\n        var inventorySystem = this.GetSystem&lt;IInventorySystem&gt;();\n\n        if (playerModel.Coins.Value &gt;= price)\n        {\n            // 通过 Command 执行购买逻辑\n            this.SendCommand&lt;PurchaseItemCommand&gt;(new PurchaseItemCommand(itemId, price));\n            return true;\n        }\n\n        return false;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-设计模式的应用","level":3,"title":"QFramework 设计模式的应用","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#command-模式的深度应用","level":4,"title":"Command 模式的深度应用","text":"<p>QFramework 的 Command 不仅仅是简单的命令模式，还支持撤销、重做等高级功能：</p> <pre><code>// ✅ 支持撤销的 Command\npublic interface IUndoableCommand : ICommand\n{\n    void Undo();\n    bool CanUndo { get; }\n}\n\npublic class MovePlayerCommand : AbstractCommand, IUndoableCommand\n{\n    private Vector3 fromPosition;\n    private Vector3 toPosition;\n    private Transform playerTransform;\n\n    public bool CanUndo =&gt; true;\n\n    public MovePlayerCommand(Vector3 to)\n    {\n        toPosition = to;\n    }\n\n    protected override void OnExecute()\n    {\n        var playerModel = this.GetModel&lt;IPlayerModel&gt;();\n        playerTransform = playerModel.PlayerTransform;\n        fromPosition = playerTransform.position;\n\n        playerTransform.position = toPosition;\n        playerModel.Position.Value = toPosition;\n    }\n\n    public void Undo()\n    {\n        if (playerTransform != null)\n        {\n            playerTransform.position = fromPosition;\n            var playerModel = this.GetModel&lt;IPlayerModel&gt;();\n            playerModel.Position.Value = fromPosition;\n        }\n    }\n}\n\n// ✅ Command 历史管理\npublic class CommandHistory : IUtility\n{\n    private Stack&lt;IUndoableCommand&gt; undoStack = new Stack&lt;IUndoableCommand&gt;();\n    private Stack&lt;IUndoableCommand&gt; redoStack = new Stack&lt;IUndoableCommand&gt;();\n\n    public void ExecuteCommand(IUndoableCommand command)\n    {\n        command.Execute();\n        undoStack.Push(command);\n        redoStack.Clear(); // 执行新命令时清空重做栈\n    }\n\n    public bool CanUndo =&gt; undoStack.Count &gt; 0;\n    public bool CanRedo =&gt; redoStack.Count &gt; 0;\n\n    public void Undo()\n    {\n        if (CanUndo)\n        {\n            var command = undoStack.Pop();\n            command.Undo();\n            redoStack.Push(command);\n        }\n    }\n\n    public void Redo()\n    {\n        if (CanRedo)\n        {\n            var command = redoStack.Pop();\n            command.Execute();\n            undoStack.Push(command);\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#组合模式在-qframework-中的应用","level":4,"title":"组合模式在 QFramework 中的应用","text":"<p>QFramework 支持 Command 的组合，可以构建复杂的命令序列：</p> <pre><code>// ✅ 复合 Command\npublic class CompositeCommand : AbstractCommand\n{\n    private List&lt;ICommand&gt; commands = new List&lt;ICommand&gt;();\n\n    public CompositeCommand Add(ICommand command)\n    {\n        commands.Add(command);\n        return this;\n    }\n\n    protected override void OnExecute()\n    {\n        foreach (var command in commands)\n        {\n            command.Execute();\n        }\n    }\n}\n\n// 使用示例：玩家升级的复合操作\npublic class PlayerLevelUpCommand : AbstractCommand\n{\n    protected override void OnExecute()\n    {\n        var compositeCommand = new CompositeCommand()\n            .Add(new IncreaseLevelCommand())\n            .Add(new AddAttributePointsCommand(5))\n            .Add(new PlayLevelUpEffectCommand())\n            .Add(new SavePlayerDataCommand());\n\n        compositeCommand.Execute();\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-的性能优化设计","level":3,"title":"QFramework 的性能优化设计","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#对象池在-qframework-中的应用","level":4,"title":"对象池在 QFramework 中的应用","text":"<p>QFramework 内置了对象池机制，减少 GC 压力：</p> <pre><code>// ✅ QFramework 的对象池设计\npublic class PoolableCommand : AbstractCommand, IPoolable\n{\n    private bool isRecycled = false;\n\n    public bool IsRecycled { get =&gt; isRecycled; set =&gt; isRecycled = value; }\n\n    protected override void OnExecute()\n    {\n        // 执行命令逻辑\n        DoExecute();\n\n        // 自动回收到对象池\n        this.Recycle2Cache();\n    }\n\n    protected virtual void DoExecute() { }\n\n    public void OnRecycled()\n    {\n        // 重置状态\n        ResetState();\n    }\n\n    protected virtual void ResetState() { }\n}\n\n// 使用对象池的 Command\npublic class DamageCommand : PoolableCommand\n{\n    private GameObject target;\n    private float damage;\n\n    public static DamageCommand Allocate(GameObject target, float damage)\n    {\n        var command = SafeObjectPool&lt;DamageCommand&gt;.Instance.Allocate();\n        command.target = target;\n        command.damage = damage;\n        return command;\n    }\n\n    protected override void DoExecute()\n    {\n        var health = target.GetComponent&lt;HealthComponent&gt;();\n        health?.TakeDamage(damage);\n    }\n\n    protected override void ResetState()\n    {\n        target = null;\n        damage = 0;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#实践建议和经验总结","level":2,"title":"实践建议和经验总结","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#渐进式架构演进","level":3,"title":"渐进式架构演进","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-渐进式引入策略","level":4,"title":"QFramework 渐进式引入策略","text":"<p>QFramework 的一个突出优势是支持渐进式引入，不需要一次性重构整个项目：</p> 引入阶段 引入内容 改动成本 获得效益 第一阶段 BindableProperty + 事件系统 小 数据绑定、响应式 UI 第二阶段 IModel + IController 中 数据层分离、架构清晰 第三阶段 Command 模式 中 交互逻辑解耦、可撤销操作 第四阶段 ISystem + 全套架构 大 完整架构体系、模块化开发 <pre><code>// ✅ 阶段一：只使用 BindableProperty\npublic class SimpleCounterController : MonoBehaviour\n{\n    [SerializeField] private Button incrementBtn;\n    [SerializeField] private Text countText;\n\n    // 直接使用 BindableProperty，无需架构\n    private BindableProperty&lt;int&gt; count = new BindableProperty&lt;int&gt;(0);\n\n    void Start()\n    {\n        // 数据绑定\n        count.RegisterWithInitValue(value =&gt; \n        {\n            countText.text = value.ToString();\n        });\n\n        incrementBtn.onClick.AddListener(() =&gt; \n        {\n            count.Value++;\n        });\n    }\n}\n\n// ✅ 阶段二：引入 Model 和 Controller\npublic class CounterModel\n{\n    public BindableProperty&lt;int&gt; Count { get; } = new BindableProperty&lt;int&gt;(0);\n\n    public void Increment() =&gt; Count.Value++;\n    public void Decrement() =&gt; Count.Value--;\n}\n\npublic class CounterController : MonoBehaviour\n{\n    [SerializeField] private Button incrementBtn;\n    [SerializeField] private Button decrementBtn;\n    [SerializeField] private Text countText;\n\n    private CounterModel model;\n\n    void Start()\n    {\n        model = new CounterModel();\n\n        model.Count.RegisterWithInitValue(OnCountChanged);\n\n        incrementBtn.onClick.AddListener(model.Increment);\n        decrementBtn.onClick.AddListener(model.Decrement);\n    }\n\n    void OnCountChanged(int newCount)\n    {\n        countText.text = newCount.ToString();\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-在大型项目中的应用案例","level":3,"title":"QFramework 在大型项目中的应用案例","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#复杂游戏系统架构设计","level":4,"title":"复杂游戏系统架构设计","text":"<p>以一个 RPG 游戏为例，展示 QFramework 如何支持复杂的游戏系统：</p> <pre><code>graph TD\n    A[RPGGameApp&lt;br/&gt;游戏架构] --&gt; B[IPlayerModel&lt;br/&gt;玩家数据]\n    A --&gt; C[IInventoryModel&lt;br/&gt;背包数据]\n    A --&gt; D[IQuestModel&lt;br/&gt;任务数据]\n\n    A --&gt; E[IBattleSystem&lt;br/&gt;战斗系统]\n    A --&gt; F[IQuestSystem&lt;br/&gt;任务系统]\n    A --&gt; G[IAchievementSystem&lt;br/&gt;成就系统]\n\n    A --&gt; H[IGameplayController&lt;br/&gt;游戏控制]\n    A --&gt; I[IUIController&lt;br/&gt;界面控制]\n    A --&gt; J[IInputController&lt;br/&gt;输入控制]</code></pre> <pre><code>// ✅ RPG 游戏的模块化架构\npublic class RPGGameApp : Architecture&lt;RPGGameApp&gt;\n{\n    protected override void Init()\n    {\n        // 数据层\n        this.RegisterModel&lt;IPlayerModel&gt;(new PlayerModel());\n        this.RegisterModel&lt;IInventoryModel&gt;(new InventoryModel());\n        this.RegisterModel&lt;IQuestModel&gt;(new QuestModel());\n        this.RegisterModel&lt;ISkillModel&gt;(new SkillModel());\n\n        // 系统层\n        this.RegisterSystem&lt;IBattleSystem&gt;(new BattleSystem());\n        this.RegisterSystem&lt;IQuestSystem&gt;(new QuestSystem());\n        this.RegisterSystem&lt;IAchievementSystem&gt;(new AchievementSystem());\n        this.RegisterSystem&lt;ISaveSystem&gt;(new SaveSystem());\n\n        // 工具层\n        this.RegisterUtility&lt;IStorageUtility&gt;(new JsonStorageUtility());\n        this.RegisterUtility&lt;ITimeUtility&gt;(new UnityTimeUtility());\n        this.RegisterUtility&lt;IRandomUtility&gt;(new SystemRandomUtility());\n    }\n}\n\n// ✅ 系统间的协作示例：战斗系统\npublic class BattleSystem : AbstractSystem, IBattleSystem\n{\n    private IPlayerModel playerModel;\n    private IInventoryModel inventoryModel;\n    private IQuestSystem questSystem;\n\n    protected override void OnInit()\n    {\n        playerModel = this.GetModel&lt;IPlayerModel&gt;();\n        inventoryModel = this.GetModel&lt;IInventoryModel&gt;();\n        questSystem = this.GetSystem&lt;IQuestSystem&gt;();\n\n        // 监听敌人死亡事件\n        this.RegisterEvent&lt;EnemyDefeatedEvent&gt;(OnEnemyDefeated);\n    }\n\n    public void AttackEnemy(EnemyData enemy)\n    {\n        var damage = CalculateDamage(playerModel, enemy);\n\n        // 执行攻击命令\n        this.SendCommand&lt;DealDamageCommand&gt;(new DealDamageCommand(enemy, damage));\n    }\n\n    private void OnEnemyDefeated(EnemyDefeatedEvent e)\n    {\n        // 获得经验值\n        var expGained = e.Enemy.ExperienceReward;\n        this.SendCommand&lt;GainExperienceCommand&gt;(new GainExperienceCommand(expGained));\n\n        // 获得战利品\n        var loot = GenerateLoot(e.Enemy);\n        foreach (var item in loot)\n        {\n            this.SendCommand&lt;AddItemCommand&gt;(new AddItemCommand(item.Id, item.Quantity));\n        }\n\n        // 通知任务系统\n        questSystem.OnEnemyKilled(e.Enemy.Type);\n    }\n\n    private float CalculateDamage(IPlayerModel player, EnemyData enemy)\n    {\n        var baseDamage = player.Attack.Value;\n        var weaponDamage = GetEquippedWeaponDamage();\n        var skillMultiplier = GetSkillMultiplier();\n\n        return (baseDamage + weaponDamage) * skillMultiplier;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#复杂-ui-系统的架构设计","level":4,"title":"复杂 UI 系统的架构设计","text":"<p>QFramework 在 UI 系统中的应用展示了其在复杂界面管理中的优势：</p> <pre><code>// ✅ 数据驱动的 UI 设计\npublic class InventoryPanel : UIPanel, IController\n{\n    [Header(\"UI 引用\")]\n    [SerializeField] private Transform itemContainer;\n    [SerializeField] private InventoryItemView itemPrefab;\n    [SerializeField] private Button sortButton;\n    [SerializeField] private Text capacityText;\n\n    private IInventoryModel inventoryModel;\n    private List&lt;InventoryItemView&gt; itemViews = new List&lt;InventoryItemView&gt;();\n\n    void Start()\n    {\n        inventoryModel = this.GetModel&lt;IInventoryModel&gt;();\n\n        // 监听数据变化\n        inventoryModel.Items.RegisterWithInitValue(OnItemsChanged)\n            .UnRegisterWhenGameObjectDestroyed(gameObject);\n\n        inventoryModel.Capacity.RegisterWithInitValue(OnCapacityChanged)\n            .UnRegisterWhenGameObjectDestroyed(gameObject);\n\n        // UI 事件绑定\n        sortButton.onClick.AddListener(() =&gt; \n        {\n            this.SendCommand&lt;SortInventoryCommand&gt;();\n        });\n\n        // 监听物品变化事件\n        this.RegisterEvent&lt;ItemUsedEvent&gt;(OnItemUsed);\n    }\n\n    private void OnItemsChanged(List&lt;ItemData&gt; items)\n    {\n        // 清理旧的 UI\n        foreach (var view in itemViews)\n        {\n            if (view != null)\n                Destroy(view.gameObject);\n        }\n        itemViews.Clear();\n\n        // 创建新的 UI\n        foreach (var item in items)\n        {\n            var itemView = Instantiate(itemPrefab, itemContainer);\n            itemView.SetData(item);\n            itemView.OnItemClicked += (clickedItem) =&gt; \n            {\n                this.SendCommand&lt;UseItemCommand&gt;(new UseItemCommand(clickedItem.Id));\n            };\n            itemViews.Add(itemView);\n        }\n    }\n\n    private void OnCapacityChanged(int capacity)\n    {\n        var currentCount = inventoryModel.Items.Value.Count;\n        capacityText.text = $\"{currentCount}/{capacity}\";\n\n        // 容量警告\n        if (currentCount &gt;= capacity * 0.9f)\n        {\n            capacityText.color = Color.red;\n        }\n        else if (currentCount &gt;= capacity * 0.7f)\n        {\n            capacityText.color = Color.yellow;\n        }\n        else\n        {\n            capacityText.color = Color.white;\n        }\n    }\n\n    private void OnItemUsed(ItemUsedEvent e)\n    {\n        // 播放使用物品的特效\n        PlayItemUseEffect(e.ItemId);\n    }\n\n    public IArchitecture GetArchitecture() =&gt; RPGGameApp.Interface;\n}\n\n// ✅ 可复用的物品视图组件\npublic class InventoryItemView : MonoBehaviour\n{\n    [SerializeField] private Image iconImage;\n    [SerializeField] private Text nameText;\n    [SerializeField] private Text quantityText;\n    [SerializeField] private Button useButton;\n\n    public event System.Action&lt;ItemData&gt; OnItemClicked;\n\n    private ItemData itemData;\n\n    void Start()\n    {\n        useButton.onClick.AddListener(() =&gt; \n        {\n            OnItemClicked?.Invoke(itemData);\n        });\n    }\n\n    public void SetData(ItemData data)\n    {\n        itemData = data;\n        iconImage.sprite = data.Icon;\n        nameText.text = data.Name;\n        quantityText.text = data.Quantity &gt; 1 ? data.Quantity.ToString() : \"\";\n\n        // 根据物品类型设置不同的显示状态\n        useButton.interactable = data.IsUsable;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-的性能优化最佳实践","level":3,"title":"QFramework 的性能优化最佳实践","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#事件系统的性能优化","level":4,"title":"事件系统的性能优化","text":"<p>QFramework 的事件系统在大量事件监听和发送时的性能优化：</p> <pre><code>// ✅ 优化的事件处理\npublic class OptimizedEventSystem : MonoBehaviour\n{\n    // 使用对象池减少 GC\n    private static readonly ObjectPool&lt;List&lt;System.Action&gt;&gt; ActionListPool = \n        new ObjectPool&lt;List&lt;System.Action&gt;&gt;(() =&gt; new List&lt;System.Action&gt;(), null, l =&gt; l.Clear());\n\n    void Start()\n    {\n        // 批量事件处理\n        var actions = ActionListPool.Get();\n\n        // 收集所有需要执行的事件\n        CollectPendingEvents(actions);\n\n        // 批量执行\n        foreach (var action in actions)\n        {\n            action?.Invoke();\n        }\n\n        // 回收对象\n        ActionListPool.Release(actions);\n    }\n\n    // ✅ 按需加载的事件监听\n    private readonly Dictionary&lt;System.Type, bool&gt; eventSubscriptions = new Dictionary&lt;System.Type, bool&gt;();\n\n    private void RegisterEventOnDemand&lt;T&gt;(System.Action&lt;T&gt; handler) where T : struct\n    {\n        var eventType = typeof(T);\n\n        if (!eventSubscriptions.ContainsKey(eventType))\n        {\n            this.RegisterEvent&lt;T&gt;(handler);\n            eventSubscriptions[eventType] = true;\n        }\n    }\n\n    // ✅ 按区域的事件管理\n    public class RegionalEventManager : IUtility\n    {\n        private readonly Dictionary&lt;string, HashSet&lt;IController&gt;&gt; regionControllers = new Dictionary&lt;string, HashSet&lt;IController&gt;&gt;();\n\n        public void RegisterControllerToRegion(string region, IController controller)\n        {\n            if (!regionControllers.ContainsKey(region))\n                regionControllers[region] = new HashSet&lt;IController&gt;();\n\n            regionControllers[region].Add(controller);\n        }\n\n        public void SendEventToRegion&lt;T&gt;(string region, T eventData) where T : struct\n        {\n            if (regionControllers.TryGetValue(region, out var controllers))\n            {\n                foreach (var controller in controllers)\n                {\n                    // 只向特定区域的控制器发送事件\n                    if (controller is MonoBehaviour mb &amp;&amp; mb != null)\n                    {\n                        // 发送事件的逻辑\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#内存管理的最佳实践","level":4,"title":"内存管理的最佳实践","text":"<pre><code>// ✅ QFramework 中的内存优化技巧\npublic class MemoryOptimizedModel : AbstractModel, IDisposable\n{\n    // 使用结构体减少堆内存分配\n    public struct PlayerState\n    {\n        public int Health;\n        public int Mana;\n        public Vector3 Position;\n        public bool IsAlive;\n    }\n\n    private readonly BindableProperty&lt;PlayerState&gt; playerState = new BindableProperty&lt;PlayerState&gt;();\n\n    // 缓存频繁计算的结果\n    private readonly Dictionary&lt;string, float&gt; cachedCalculations = new Dictionary&lt;string, float&gt;();\n    private float lastCalculationTime;\n\n    public float GetDamageMultiplier()\n    {\n        const string cacheKey = \"damageMultiplier\";\n\n        // 缓存 1 秒钟内的计算结果\n        if (Time.time - lastCalculationTime &lt; 1f &amp;&amp; cachedCalculations.ContainsKey(cacheKey))\n        {\n            return cachedCalculations[cacheKey];\n        }\n\n        var multiplier = CalculateDamageMultiplier();\n        cachedCalculations[cacheKey] = multiplier;\n        lastCalculationTime = Time.time;\n\n        return multiplier;\n    }\n\n    private float CalculateDamageMultiplier()\n    {\n        // 复杂的计算逻辑\n        return 1.0f;\n    }\n\n    public void Dispose()\n    {\n        cachedCalculations.Clear();\n        playerState?.Dispose();\n    }\n}\n\n// ✅ 懒加载的数据管理\npublic class LazyLoadedDataModel : AbstractModel\n{\n    private readonly Dictionary&lt;string, WeakReference&gt; dataCache = new Dictionary&lt;string, WeakReference&gt;();\n\n    public T GetData&lt;T&gt;(string key, System.Func&lt;T&gt; factory) where T : class\n    {\n        if (dataCache.TryGetValue(key, out var weakRef) &amp;&amp; weakRef.IsAlive)\n        {\n            return weakRef.Target as T;\n        }\n\n        var data = factory();\n        dataCache[key] = new WeakReference(data);\n        return data;\n    }\n\n    // 定期清理已经被 GC 的弱引用\n    public void CleanupWeakReferences()\n    {\n        var keysToRemove = new List&lt;string&gt;();\n\n        foreach (var kvp in dataCache)\n        {\n            if (!kvp.Value.IsAlive)\n            {\n                keysToRemove.Add(kvp.Key);\n            }\n        }\n\n        foreach (var key in keysToRemove)\n        {\n            dataCache.Remove(key);\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-的测试和调试最佳实践","level":3,"title":"QFramework 的测试和调试最佳实践","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#可测试性设计","level":4,"title":"可测试性设计","text":"<p>QFramework 的分层架构天然支持单元测试和集成测试：</p> <pre><code>// ✅ Model 层的单元测试\n[TestFixture]\npublic class CounterModelTests\n{\n    private CounterModel model;\n    private TestArchitecture architecture;\n\n    [SetUp]\n    public void Setup()\n    {\n        architecture = new TestArchitecture();\n        model = new CounterModel();\n        model.SetArchitecture(architecture);\n        model.Init();\n    }\n\n    [Test]\n    public void IncrementCount_ShouldIncreaseByOne()\n    {\n        // Arrange\n        var initialCount = model.Count.Value;\n\n        // Act\n        model.IncrementCount();\n\n        // Assert\n        Assert.AreEqual(initialCount + 1, model.Count.Value);\n    }\n\n    [Test]\n    public void IncrementCount_ShouldSendEvent()\n    {\n        // Arrange\n        bool eventReceived = false;\n        CountChangedEvent receivedEvent = default;\n\n        architecture.RegisterEvent&lt;CountChangedEvent&gt;(e =&gt; \n        {\n            eventReceived = true;\n            receivedEvent = e;\n        });\n\n        // Act\n        model.IncrementCount();\n\n        // Assert\n        Assert.IsTrue(eventReceived);\n        Assert.AreEqual(model.Count.Value, receivedEvent.NewCount);\n    }\n\n    [TearDown]\n    public void TearDown()\n    {\n        model = null;\n        architecture.Deinit();\n    }\n}\n\n// ✅ 测试用的模拟架构\npublic class TestArchitecture : IArchitecture\n{\n    private readonly Dictionary&lt;Type, object&gt; models = new Dictionary&lt;Type, object&gt;();\n    private readonly Dictionary&lt;Type, object&gt; systems = new Dictionary&lt;Type, object&gt;();\n    private readonly Dictionary&lt;Type, object&gt; utilities = new Dictionary&lt;Type, object&gt;();\n\n    public T GetModel&lt;T&gt;() where T : class, IModel\n    {\n        return models.TryGetValue(typeof(T), out var model) ? model as T : null;\n    }\n\n    public T GetSystem&lt;T&gt;() where T : class, ISystem\n    {\n        return systems.TryGetValue(typeof(T), out var system) ? system as T : null;\n    }\n\n    public T GetUtility&lt;T&gt;() where T : class, IUtility\n    {\n        return utilities.TryGetValue(typeof(T), out var utility) ? utility as T : null;\n    }\n\n    public void RegisterModel&lt;T&gt;(T model) where T : class, IModel\n    {\n        models[typeof(T)] = model;\n    }\n\n    public void RegisterSystem&lt;T&gt;(T system) where T : class, ISystem\n    {\n        systems[typeof(T)] = system;\n    }\n\n    public void RegisterUtility&lt;T&gt;(T utility) where T : class, IUtility\n    {\n        utilities[typeof(T)] = utility;\n    }\n\n    public void SendCommand&lt;T&gt;() where T : ICommand, new()\n    {\n        var command = new T();\n        command.SetArchitecture(this);\n        command.Execute();\n    }\n\n    public void SendCommand&lt;T&gt;(T command) where T : ICommand\n    {\n        command.SetArchitecture(this);\n        command.Execute();\n    }\n\n    public void RegisterEvent&lt;T&gt;(Action&lt;T&gt; onEvent)\n    {\n        // 测试事件注册逻辑\n    }\n\n    public void UnRegisterEvent&lt;T&gt;(Action&lt;T&gt; onEvent)\n    {\n        // 测试事件取消注册逻辑\n    }\n\n    public void SendEvent&lt;T&gt;(T e)\n    {\n        // 测试事件发送逻辑\n    }\n\n    public void Deinit()\n    {\n        models.Clear();\n        systems.Clear();\n        utilities.Clear();\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#command-的集成测试","level":4,"title":"Command 的集成测试","text":"<pre><code>// ✅ Command 的集成测试\n[TestFixture]\npublic class PurchaseItemCommandTests\n{\n    private TestArchitecture architecture;\n    private IPlayerModel playerModel;\n    private IInventoryModel inventoryModel;\n    private IShopSystem shopSystem;\n\n    [SetUp]\n    public void Setup()\n    {\n        architecture = new TestArchitecture();\n\n        // 模拟依赖\n        playerModel = new MockPlayerModel();\n        inventoryModel = new MockInventoryModel();\n        shopSystem = new MockShopSystem();\n\n        architecture.RegisterModel&lt;IPlayerModel&gt;(playerModel);\n        architecture.RegisterModel&lt;IInventoryModel&gt;(inventoryModel);\n        architecture.RegisterSystem&lt;IShopSystem&gt;(shopSystem);\n    }\n\n    [Test]\n    public void PurchaseItem_WithSufficientCoins_ShouldSucceed()\n    {\n        // Arrange\n        playerModel.Coins.Value = 100;\n        var itemId = \"sword\";\n        var price = 50;\n        var command = new PurchaseItemCommand(itemId, price);\n\n        // Act\n        architecture.SendCommand(command);\n\n        // Assert\n        Assert.AreEqual(50, playerModel.Coins.Value);\n        Assert.IsTrue(inventoryModel.HasItem(itemId));\n    }\n\n    [Test]\n    public void PurchaseItem_WithInsufficientCoins_ShouldFail()\n    {\n        // Arrange\n        playerModel.Coins.Value = 30;\n        var itemId = \"sword\";\n        var price = 50;\n        var command = new PurchaseItemCommand(itemId, price);\n\n        // Act &amp; Assert\n        Assert.Throws&lt;InsufficientCoinsException&gt;(() =&gt; \n        {\n            architecture.SendCommand(command);\n        });\n\n        Assert.AreEqual(30, playerModel.Coins.Value);\n        Assert.IsFalse(inventoryModel.HasItem(itemId));\n    }\n}\n\n// ✅ Mock 对象的实现\npublic class MockPlayerModel : IPlayerModel\n{\n    public BindableProperty&lt;int&gt; Coins { get; } = new BindableProperty&lt;int&gt;(0);\n    public BindableProperty&lt;int&gt; Level { get; } = new BindableProperty&lt;int&gt;(1);\n\n    public void Init() { }\n    public IArchitecture GetArchitecture() =&gt; null;\n    public void SetArchitecture(IArchitecture architecture) { }\n}\n\npublic class MockInventoryModel : IInventoryModel\n{\n    private readonly Dictionary&lt;string, int&gt; items = new Dictionary&lt;string, int&gt;();\n\n    public void AddItem(string itemId, int quantity)\n    {\n        if (!items.ContainsKey(itemId))\n            items[itemId] = 0;\n        items[itemId] += quantity;\n    }\n\n    public bool HasItem(string itemId)\n    {\n        return items.ContainsKey(itemId) &amp;&amp; items[itemId] &gt; 0;\n    }\n\n    public void Init() { }\n    public IArchitecture GetArchitecture() =&gt; null;\n    public void SetArchitecture(IArchitecture architecture) { }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#运行时调试工具","level":4,"title":"运行时调试工具","text":"<p>QFramework 可以集成强大的运行时调试工具：</p> <pre><code>// ✅ 运行时架构监控器\npublic class ArchitectureDebugger : MonoBehaviour\n{\n    [Header(\"架构调试信息\")]\n    [SerializeField] private bool showDebugInfo = true;\n    [SerializeField] private KeyCode debugToggleKey = KeyCode.F1;\n\n    private IArchitecture architecture;\n    private readonly List&lt;string&gt; commandHistory = new List&lt;string&gt;();\n    private readonly List&lt;string&gt; eventHistory = new List&lt;string&gt;();\n\n    void Start()\n    {\n        architecture = GameApp.Interface;\n\n        if (showDebugInfo)\n        {\n            // 监控所有 Command 执行\n            HookCommandExecution();\n\n            // 监控所有 Event 发送\n            HookEventSending();\n        }\n    }\n\n    void Update()\n    {\n        if (Input.GetKeyDown(debugToggleKey))\n        {\n            showDebugInfo = !showDebugInfo;\n        }\n    }\n\n    void OnGUI()\n    {\n        if (!showDebugInfo) return;\n\n        GUILayout.BeginArea(new Rect(10, 10, 400, Screen.height - 20));\n\n        GUILayout.Label(\"QFramework 架构调试器\", EditorStyles.boldLabel);\n\n        // 显示最近的 Command 历史\n        GUILayout.Label(\"Command 历史:\");\n        GUILayout.BeginScrollView(Vector2.zero, GUILayout.Height(150));\n        foreach (var command in commandHistory.TakeLast(10))\n        {\n            GUILayout.Label(command);\n        }\n        GUILayout.EndScrollView();\n\n        // 显示最近的 Event 历史\n        GUILayout.Label(\"Event 历史:\");\n        GUILayout.BeginScrollView(Vector2.zero, GUILayout.Height(150));\n        foreach (var evt in eventHistory.TakeLast(10))\n        {\n            GUILayout.Label(evt);\n        }\n        GUILayout.EndScrollView();\n\n        // 架构状态信息\n        GUILayout.Label(\"Model 状态:\");\n        DisplayModelStates();\n\n        GUILayout.EndArea();\n    }\n\n    private void HookCommandExecution()\n    {\n        // 使用反射或 AOP 技术监控 Command 执行\n        // 这里简化处理\n    }\n\n    private void HookEventSending()\n    {\n        // 使用反射或 AOP 技术监控 Event 发送\n        // 这里简化处理\n    }\n\n    private void DisplayModelStates()\n    {\n        // 显示各个 Model 的当前状态\n        if (architecture.GetModel&lt;IPlayerModel&gt;() is PlayerModel playerModel)\n        {\n            GUILayout.Label($\"玩家等级: {playerModel.Level.Value}\");\n            GUILayout.Label($\"玩家金币: {playerModel.Coins.Value}\");\n        }\n\n        if (architecture.GetModel&lt;IInventoryModel&gt;() is InventoryModel inventoryModel)\n        {\n            GUILayout.Label($\"背包物品数: {inventoryModel.Items.Value.Count}\");\n        }\n    }\n}\n\n// ✅ 性能监控器\npublic class PerformanceMonitor : MonoBehaviour\n{\n    [Header(\"性能监控\")]\n    [SerializeField] private bool enableProfiling = true;\n\n    private readonly Dictionary&lt;string, float&gt; commandExecutionTimes = new Dictionary&lt;string, float&gt;();\n    private readonly Dictionary&lt;string, int&gt; commandExecutionCounts = new Dictionary&lt;string, int&gt;();\n\n    public void LogCommandExecution(string commandName, float executionTime)\n    {\n        if (!enableProfiling) return;\n\n        if (!commandExecutionTimes.ContainsKey(commandName))\n        {\n            commandExecutionTimes[commandName] = 0;\n            commandExecutionCounts[commandName] = 0;\n        }\n\n        commandExecutionTimes[commandName] += executionTime;\n        commandExecutionCounts[commandName]++;\n\n        // 发现性能问题时警告\n        if (executionTime &gt; 0.1f) // 100ms\n        {\n            Debug.LogWarning($\"Command {commandName} 执行耗时过长: {executionTime:F3}s\");\n        }\n    }\n\n    public void PrintPerformanceReport()\n    {\n        Debug.Log(\"=== QFramework 性能报告 ===\");\n\n        foreach (var kvp in commandExecutionTimes)\n        {\n            var commandName = kvp.Key;\n            var totalTime = kvp.Value;\n            var count = commandExecutionCounts[commandName];\n            var averageTime = totalTime / count;\n\n            Debug.Log($\"{commandName}: 总耗时 {totalTime:F3}s, 执行次数 {count}, 平均耗时 {averageTime:F3}s\");\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#qframework-的渐进式架构演进策略","level":3,"title":"QFramework 的渐进式架构演进策略","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#架构成熟度模型","level":4,"title":"架构成熟度模型","text":"成熟度级别 特征描述 适用项目规模 演进重点 初始级 功能优先、快速实现 小型项目、原型验证 建立基本结构 管理级 规范流程、模块划分 中型项目、团队协作 制定开发规范 定义级 标准化开发、质量保证 大型项目、长期维护 建立质量体系 量化级 数据驱动、性能监控 商业产品、高要求 优化关键指标 优化级 持续改进、自动化 企业级、多项目 平台化建设 <pre><code>}\n\nprivate void OnItemsChanged(List&lt;ItemData&gt; items)\n{\n    // 清理旧的 UI\n    foreach (var view in itemViews)\n    {\n        if (view != null)\n            Destroy(view.gameObject);\n    }\n    itemViews.Clear();\n\n    // 创建新的 UI\n    foreach (var item in items)\n    {\n        var itemView = Instantiate(itemPrefab, itemContainer);\n        itemView.SetData(item);\n        itemView.OnItemClicked += (clickedItem) =&gt; \n        {\n            this.SendCommand&lt;UseItemCommand&gt;(new UseItemCommand(clickedItem.Id));\n        };\n        itemViews.Add(itemView);\n    }\n}\n\nprivate void OnCapacityChanged(int capacity)\n{\n    var currentCount = inventoryModel.Items.Value.Count;\n    capacityText.text = $\"{currentCount}/{capacity}\";\n\n    // 容量警告\n    if (currentCount &gt;= capacity * 0.9f)\n    {\n        capacityText.color = Color.red;\n    }\n    else if (currentCount &gt;= capacity * 0.7f)\n    {\n        capacityText.color = Color.yellow;\n    }\n    else\n    {\n        capacityText.color = Color.white;\n    }\n}\n\nprivate void OnItemUsed(ItemUsedEvent e)\n{\n    // 播放使用物品的特效\n    PlayItemUseEffect(e.ItemId);\n}\n\npublic IArchitecture GetArchitecture() =&gt; RPGGameApp.Interface;\n</code></pre> <p>}</p> <p>// ✅ 可复用的物品视图组件 public class InventoryItemView : MonoBehaviour {     [SerializeField] private Image iconImage;     [SerializeField] private Text nameText;     [SerializeField] private Text quantityText;     [SerializeField] private Button useButton;</p> <pre><code>public event System.Action&lt;ItemData&gt; OnItemClicked;\n\nprivate ItemData itemData;\n\nvoid Start()\n{\n    useButton.onClick.AddListener(() =&gt; \n    {\n        OnItemClicked?.Invoke(itemData);\n    });\n}\n\npublic void SetData(ItemData data)\n{\n    itemData = data;\n    iconImage.sprite = data.Icon;\n    nameText.text = data.Name;\n    quantityText.text = data.Quantity &gt; 1 ? data.Quantity.ToString() : \"\";\n\n    // 根据物品类型设置不同的显示状态\n    useButton.interactable = data.IsUsable;\n}\n</code></pre> <p>}</p> <pre><code>### QFramework 的性能优化最佳实践\n\n#### 事件系统的性能优化\n\nQFramework 的事件系统在大量事件监听和发送时的性能优化：\n\n```csharp\n// ✅ 优化的事件处理\npublic class OptimizedEventSystem : MonoBehaviour\n{\n    // 使用对象池减少 GC\n    private static readonly ObjectPool&lt;List&lt;System.Action&gt;&gt; ActionListPool = \n        new ObjectPool&lt;List&lt;System.Action&gt;&gt;(() =&gt; new List&lt;System.Action&gt;(), null, l =&gt; l.Clear());\n\n    void Start()\n    {\n        // 批量事件处理\n        var actions = ActionListPool.Get();\n\n        // 收集所有需要执行的事件\n        CollectPendingEvents(actions);\n\n        // 批量执行\n        foreach (var action in actions)\n        {\n            action?.Invoke();\n        }\n\n        // 回收对象\n        ActionListPool.Release(actions);\n    }\n\n    // ✅ 按需加载的事件监听\n    private readonly Dictionary&lt;System.Type, bool&gt; eventSubscriptions = new Dictionary&lt;System.Type, bool&gt;();\n\n    private void RegisterEventOnDemand&lt;T&gt;(System.Action&lt;T&gt; handler) where T : struct\n    {\n        var eventType = typeof(T);\n\n        if (!eventSubscriptions.ContainsKey(eventType))\n        {\n            this.RegisterEvent&lt;T&gt;(handler);\n            eventSubscriptions[eventType] = true;\n        }\n    }\n\n    // ✅ 按区域的事件管理\n    public class RegionalEventManager : IUtility\n    {\n        private readonly Dictionary&lt;string, HashSet&lt;IController&gt;&gt; regionControllers = new Dictionary&lt;string, HashSet&lt;IController&gt;&gt;();\n\n        public void RegisterControllerToRegion(string region, IController controller)\n        {\n            if (!regionControllers.ContainsKey(region))\n                regionControllers[region] = new HashSet&lt;IController&gt;();\n\n            regionControllers[region].Add(controller);\n        }\n\n        public void SendEventToRegion&lt;T&gt;(string region, T eventData) where T : struct\n        {\n            if (regionControllers.TryGetValue(region, out var controllers))\n            {\n                foreach (var controller in controllers)\n                {\n                    // 只向特定区域的控制器发送事件\n                    if (controller is MonoBehaviour mb &amp;&amp; mb != null)\n                    {\n                        // 发送事件的逻辑\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#内存管理的最佳实践_1","level":4,"title":"内存管理的最佳实践","text":"<pre><code>// ✅ QFramework 中的内存优化技巧\npublic class MemoryOptimizedModel : AbstractModel, IDisposable\n{\n    // 使用结构体减少堆内存分配\n    public struct PlayerState\n    {\n        public int Health;\n        public int Mana;\n        public Vector3 Position;\n        public bool IsAlive;\n    }\n\n    private readonly BindableProperty&lt;PlayerState&gt; playerState = new BindableProperty&lt;PlayerState&gt;();\n\n    // 缓存频繁计算的结果\n    private readonly Dictionary&lt;string, float&gt; cachedCalculations = new Dictionary&lt;string, float&gt;();\n    private float lastCalculationTime;\n\n    public float GetDamageMultiplier()\n    {\n        const string cacheKey = \"damageMultiplier\";\n\n        // 缓存 1 秒钟内的计算结果\n        if (Time.time - lastCalculationTime &lt; 1f &amp;&amp; cachedCalculations.ContainsKey(cacheKey))\n        {\n            return cachedCalculations[cacheKey];\n        }\n\n        var multiplier = CalculateDamageMultiplier();\n        cachedCalculations[cacheKey] = multiplier;\n        lastCalculationTime = Time.time;\n\n        return multiplier;\n    }\n\n    private float CalculateDamageMultiplier()\n    {\n        // 复杂的计算逻辑\n        return 1.0f;\n    }\n\n    public void Dispose()\n    {\n        cachedCalculations.Clear();\n        playerState?.Dispose();\n    }\n}\n\n// ✅ 懒加载的数据管理\npublic class LazyLoadedDataModel : AbstractModel\n{\n    private readonly Dictionary&lt;string, WeakReference&gt; dataCache = new Dictionary&lt;string, WeakReference&gt;();\n\n    public T GetData&lt;T&gt;(string key, System.Func&lt;T&gt; factory) where T : class\n    {\n        if (dataCache.TryGetValue(key, out var weakRef) &amp;&amp; weakRef.IsAlive)\n        {\n            return weakRef.Target as T;\n        }\n\n        var data = factory();\n        dataCache[key] = new WeakReference(data);\n        return data;\n    }\n\n    // 定期清理已经被 GC 的弱引用\n    public void CleanupWeakReferences()\n    {\n        var keysToRemove = new List&lt;string&gt;();\n\n        foreach (var kvp in dataCache)\n        {\n            if (!kvp.Value.IsAlive)\n            {\n                keysToRemove.Add(kvp.Key);\n            }\n        }\n\n        foreach (var key in keysToRemove)\n        {\n            dataCache.Remove(key);\n        }\n    }\n}\n</code></pre> 成熟度级别 特征描述 适用项目规模 演进重点 初始级 功能优先、快速实现 小型项目、原型验证 建立基本结构 管理级 规范流程、模块划分 中型项目、团队协作 制定开发规范 定义级 标准化开发、质量保证 大型项目、长期维护 建立质量体系 量化级 数据驱动、性能监控 商业产品、高要求 优化关键指标 优化级 持续改进、自动化 企业级、多项目 平台化建设","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#团队协作和知识传承","level":3,"title":"团队协作和知识传承","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#知识管理策略","level":4,"title":"知识管理策略","text":"<pre><code>graph LR\n    A[知识获取] --&gt; B[知识整理]\n    B --&gt; C[知识分享]\n    C --&gt; D[知识应用]\n    D --&gt; E[知识创新]\n    E --&gt; A\n\n    F[代码评审] --&gt; B\n    G[技术文档] --&gt; C\n    H[培训分享] --&gt; C\n    I[最佳实践] --&gt; D\n    J[工具平台] --&gt; E</code></pre>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#常见陷阱和解决方案","level":3,"title":"常见陷阱和解决方案","text":"","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#架构反模式识别","level":4,"title":"架构反模式识别","text":"反模式名称 症状描述 危害分析 解决方案 神类模式 单个类承担过多职责 难以维护、测试困难 应用单一职责原则拆分 复制粘贴编程 大量重复代码 维护成本高、错误传播 提取公共抽象和工具类 硬编码配置 配置值写死在代码中 灵活性差、难以调优 使用配置文件和数据驱动 循环依赖 模块间相互依赖 耦合度高、难以解耦 引入中介者或事件机制 过度设计 提前优化、过度抽象 复杂度高、开发效率低 按需设计、渐进式重构","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/csharp-architecture-design/#结论","level":2,"title":"结论","text":"<p>Unity 中的 C# 代码设计是一个系统性工程，需要在数据容器设计、接口驱动开发、组件化架构等多个维度上建立正确的设计理念。通过遵循 SOLID 原则，采用事件驱动和数据驱动的设计模式，结合 Unity 特性进行架构优化，可以构建出高质量、易维护、可扩展的游戏项目。</p> <p>成功的架构设计不是一蹴而就的，而是需要在项目实践中不断演进和完善。关键在于建立正确的设计思维，掌握核心的设计原则，并在团队中形成良好的开发规范和知识传承机制。</p>","path":["Artical","2025 年 11 月","C# 架构设计"],"tags":["QFramework","SOLID"]},{"location":"Artical/serializereference-attribute/","level":1,"title":"Unity SerializeReferenceAttribute","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#概述","level":2,"title":"概述","text":"<p><code>SerializeReferenceAttribute</code> 是 Unity 2019.3 引入的重要特性，它彻底改变了 Unity 序列化系统对多态类型的支持。本文将深入探讨这个特性的使用方法、实现原理以及在游戏开发中的实际应用。</p>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#serializereferenceattribute-基础","level":2,"title":"SerializeReferenceAttribute 基础","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#传统序列化的限制","level":3,"title":"传统序列化的限制","text":"<p>在 <code>SerializeReferenceAttribute</code> 出现之前，Unity 的序列化系统存在以下限制：</p> <pre><code>public class TraditionalSerializationExample : MonoBehaviour \n{\n    [SerializeField] private IWeapon weapon;        // ❌ 无法序列化接口\n    [SerializeField] private BaseEnemy enemy;       // ❌ 只能序列化具体类型\n    [SerializeField] private List&lt;ISkill&gt; skills;   // ❌ 接口集合无法序列化\n}\n</code></pre> <p>这些限制导致开发者难以实现真正的多态设计，往往需要使用复杂的工厂模式或枚举驱动的实现。</p>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#serializereferenceattribute-的解决方案","level":3,"title":"SerializeReferenceAttribute 的解决方案","text":"<pre><code>public class ModernSerializationExample : MonoBehaviour \n{\n    [SerializeReference] private IWeapon weapon;        // ✅ 可以序列化接口实现\n    [SerializeReference] private BaseEnemy enemy;       // ✅ 支持多态序列化\n    [SerializeReference] private List&lt;ISkill&gt; skills;   // ✅ 接口集合完全支持\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#核心特性分析","level":2,"title":"核心特性分析","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#引用序列化-vs-值序列化","level":3,"title":"引用序列化 vs 值序列化","text":"特性对比 SerializeField SerializeReference 序列化方式 值拷贝 引用序列化 类型支持 具体类型 接口/抽象类 多态支持 ❌ ✅ 空值处理 默认构造 支持 null 引用共享 ❌ ✅ 性能开销 低 中等","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#实现原理","level":3,"title":"实现原理","text":"<p><code>SerializeReferenceAttribute</code> 的工作机制包括：</p> <pre><code>graph TD\n    A[序列化时] --&gt; B[保存类型信息]\n    A --&gt; C[保存实例数据]\n    A --&gt; D[维护引用关系]\n\n    E[反序列化时] --&gt; F[读取类型信息]\n    E --&gt; G[创建正确类型实例]\n    E --&gt; H[恢复引用关系]\n\n    B --&gt; I[完整类型名称]\n    C --&gt; J[实例字段数据]\n    D --&gt; K[引用ID映射]</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#实际应用场景","level":2,"title":"实际应用场景","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#武器系统设计","level":3,"title":"武器系统设计","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#接口定义","level":4,"title":"接口定义","text":"<pre><code>public interface IWeapon\n{\n    string Name { get; }\n    float Damage { get; }\n    float FireRate { get; }\n    void Fire(Vector3 firePoint, Vector3 direction);\n    bool CanFire();\n}\n\npublic interface IReloadable\n{\n    int CurrentAmmo { get; }\n    int MaxAmmo { get; }\n    void Reload();\n    bool NeedsReload();\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#具体实现","level":4,"title":"具体实现","text":"<pre><code>[System.Serializable]\npublic class Pistol : IWeapon, IReloadable\n{\n    [SerializeField] private string weaponName = \"手枪\";\n    [SerializeField] private float damage = 25f;\n    [SerializeField] private float fireRate = 2f;\n    [SerializeField] private int currentAmmo = 12;\n    [SerializeField] private int maxAmmo = 12;\n\n    public string Name =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n    public int CurrentAmmo =&gt; currentAmmo;\n    public int MaxAmmo =&gt; maxAmmo;\n\n    public void Fire(Vector3 firePoint, Vector3 direction)\n    {\n        if (!CanFire()) return;\n\n        currentAmmo--;\n        // 发射逻辑\n        Debug.Log($\"{weaponName} 发射！剩余弹药：{currentAmmo}\");\n    }\n\n    public bool CanFire() =&gt; currentAmmo &gt; 0;\n\n    public void Reload()\n    {\n        currentAmmo = maxAmmo;\n        Debug.Log($\"{weaponName} 重新装弹完成\");\n    }\n\n    public bool NeedsReload() =&gt; currentAmmo == 0;\n}\n\n[System.Serializable]\npublic class Rifle : IWeapon, IReloadable\n{\n    [SerializeField] private string weaponName = \"步枪\";\n    [SerializeField] private float damage = 45f;\n    [SerializeField] private float fireRate = 5f;\n    [SerializeField] private int currentAmmo = 30;\n    [SerializeField] private int maxAmmo = 30;\n\n    // 实现与 Pistol 类似...\n    public string Name =&gt; weaponName;\n    public float Damage =&gt; damage;\n    public float FireRate =&gt; fireRate;\n    public int CurrentAmmo =&gt; currentAmmo;\n    public int MaxAmmo =&gt; maxAmmo;\n\n    public void Fire(Vector3 firePoint, Vector3 direction)\n    {\n        if (!CanFire()) return;\n\n        currentAmmo--;\n        Debug.Log($\"{weaponName} 连射！剩余弹药：{currentAmmo}\");\n    }\n\n    public bool CanFire() =&gt; currentAmmo &gt; 0;\n    public void Reload() =&gt; currentAmmo = maxAmmo;\n    public bool NeedsReload() =&gt; currentAmmo == 0;\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#武器控制器","level":4,"title":"武器控制器","text":"<pre><code>public class WeaponController : MonoBehaviour\n{\n    [SerializeReference] private IWeapon primaryWeapon;\n    [SerializeReference] private IWeapon secondaryWeapon;\n    [SerializeReference] private List&lt;IWeapon&gt; weaponInventory = new List&lt;IWeapon&gt;();\n\n    [SerializeField] private Transform firePoint;\n    [SerializeField] private LayerMask targetLayers;\n\n    private IWeapon currentWeapon;\n\n    private void Start()\n    {\n        currentWeapon = primaryWeapon;\n    }\n\n    private void Update()\n    {\n        HandleInput();\n    }\n\n    private void HandleInput()\n    {\n        if (Input.GetMouseButtonDown(0))\n        {\n            FireCurrentWeapon();\n        }\n\n        if (Input.GetKeyDown(KeyCode.R))\n        {\n            ReloadCurrentWeapon();\n        }\n\n        if (Input.GetKeyDown(KeyCode.Q))\n        {\n            SwitchWeapon();\n        }\n    }\n\n    private void FireCurrentWeapon()\n    {\n        if (currentWeapon?.CanFire() == true)\n        {\n            Vector3 fireDirection = Camera.main.transform.forward;\n            currentWeapon.Fire(firePoint.position, fireDirection);\n        }\n    }\n\n    private void ReloadCurrentWeapon()\n    {\n        if (currentWeapon is IReloadable reloadable &amp;&amp; reloadable.NeedsReload())\n        {\n            reloadable.Reload();\n        }\n    }\n\n    private void SwitchWeapon()\n    {\n        currentWeapon = currentWeapon == primaryWeapon ? secondaryWeapon : primaryWeapon;\n        Debug.Log($\"切换到武器：{currentWeapon?.Name}\");\n    }\n\n    public void AddWeapon(IWeapon weapon)\n    {\n        weaponInventory.Add(weapon);\n    }\n\n    public void EquipWeapon(IWeapon weapon)\n    {\n        if (primaryWeapon == null)\n            primaryWeapon = weapon;\n        else if (secondaryWeapon == null)\n            secondaryWeapon = weapon;\n        else\n            primaryWeapon = weapon; // 替换主武器\n\n        currentWeapon = weapon;\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#技能系统设计","level":3,"title":"技能系统设计","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#技能接口层次","level":4,"title":"技能接口层次","text":"<pre><code>public interface ISkill\n{\n    string Name { get; }\n    string Description { get; }\n    float Cooldown { get; }\n    float ManaCost { get; }\n    bool CanActivate();\n    void Activate(GameObject caster);\n}\n\npublic interface ITargetedSkill : ISkill\n{\n    float Range { get; }\n    bool IsValidTarget(GameObject target);\n    void ActivateOnTarget(GameObject caster, GameObject target);\n}\n\npublic interface IAreaSkill : ISkill\n{\n    float Radius { get; }\n    void ActivateInArea(GameObject caster, Vector3 center);\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#具体技能实现","level":4,"title":"具体技能实现","text":"<pre><code>[System.Serializable]\npublic class FireballSkill : ITargetedSkill\n{\n    [SerializeField] private string skillName = \"火球术\";\n    [SerializeField] private string description = \"发射一个火球攻击目标\";\n    [SerializeField] private float cooldown = 3f;\n    [SerializeField] private float manaCost = 20f;\n    [SerializeField] private float range = 10f;\n    [SerializeField] private float damage = 50f;\n\n    private float lastActivateTime;\n\n    public string Name =&gt; skillName;\n    public string Description =&gt; description;\n    public float Cooldown =&gt; cooldown;\n    public float ManaCost =&gt; manaCost;\n    public float Range =&gt; range;\n\n    public bool CanActivate()\n    {\n        return Time.time &gt;= lastActivateTime + cooldown;\n    }\n\n    public void Activate(GameObject caster)\n    {\n        // 自动寻找最近目标\n        var target = FindNearestEnemy(caster);\n        if (target != null &amp;&amp; IsValidTarget(target))\n        {\n            ActivateOnTarget(caster, target);\n        }\n    }\n\n    public bool IsValidTarget(GameObject target)\n    {\n        return target.CompareTag(\"Enemy\");\n    }\n\n    public void ActivateOnTarget(GameObject caster, GameObject target)\n    {\n        if (!CanActivate()) return;\n\n        lastActivateTime = Time.time;\n\n        // 创建火球效果\n        CreateFireballEffect(caster.transform.position, target.transform.position);\n\n        // 对目标造成伤害\n        var health = target.GetComponent&lt;Health&gt;();\n        health?.TakeDamage(damage);\n\n        Debug.Log($\"{skillName} 命中 {target.name}，造成 {damage} 点伤害\");\n    }\n\n    private GameObject FindNearestEnemy(GameObject caster)\n    {\n        var enemies = GameObject.FindGameObjectsWithTag(\"Enemy\");\n        GameObject nearest = null;\n        float nearestDistance = float.MaxValue;\n\n        foreach (var enemy in enemies)\n        {\n            float distance = Vector3.Distance(caster.transform.position, enemy.transform.position);\n            if (distance &lt; nearestDistance &amp;&amp; distance &lt;= range)\n            {\n                nearestDistance = distance;\n                nearest = enemy;\n            }\n        }\n\n        return nearest;\n    }\n\n    private void CreateFireballEffect(Vector3 start, Vector3 end)\n    {\n        // 创建火球视觉效果的逻辑\n        Debug.Log($\"火球从 {start} 飞向 {end}\");\n    }\n}\n\n[System.Serializable]\npublic class HealingSkill : ISkill\n{\n    [SerializeField] private string skillName = \"治疗术\";\n    [SerializeField] private string description = \"恢复生命值\";\n    [SerializeField] private float cooldown = 5f;\n    [SerializeField] private float manaCost = 30f;\n    [SerializeField] private float healAmount = 75f;\n\n    private float lastActivateTime;\n\n    public string Name =&gt; skillName;\n    public string Description =&gt; description;\n    public float Cooldown =&gt; cooldown;\n    public float ManaCost =&gt; manaCost;\n\n    public bool CanActivate()\n    {\n        return Time.time &gt;= lastActivateTime + cooldown;\n    }\n\n    public void Activate(GameObject caster)\n    {\n        if (!CanActivate()) return;\n\n        lastActivateTime = Time.time;\n\n        var health = caster.GetComponent&lt;Health&gt;();\n        if (health != null)\n        {\n            health.Heal(healAmount);\n            Debug.Log($\"{skillName} 恢复了 {healAmount} 点生命值\");\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#技能管理器","level":4,"title":"技能管理器","text":"<pre><code>public class SkillManager : MonoBehaviour\n{\n    [SerializeReference] private List&lt;ISkill&gt; availableSkills = new List&lt;ISkill&gt;();\n    [SerializeReference] private List&lt;ISkill&gt; equippedSkills = new List&lt;ISkill&gt;();\n\n    [SerializeField] private int maxEquippedSkills = 4;\n    [SerializeField] private PlayerMana playerMana;\n\n    private void Update()\n    {\n        HandleSkillInput();\n    }\n\n    private void HandleSkillInput()\n    {\n        if (Input.GetKeyDown(KeyCode.Alpha1)) ActivateSkill(0);\n        if (Input.GetKeyDown(KeyCode.Alpha2)) ActivateSkill(1);\n        if (Input.GetKeyDown(KeyCode.Alpha3)) ActivateSkill(2);\n        if (Input.GetKeyDown(KeyCode.Alpha4)) ActivateSkill(3);\n    }\n\n    public void ActivateSkill(int skillIndex)\n    {\n        if (skillIndex &lt; 0 || skillIndex &gt;= equippedSkills.Count) return;\n\n        var skill = equippedSkills[skillIndex];\n        if (skill == null) return;\n\n        if (!skill.CanActivate())\n        {\n            Debug.Log($\"{skill.Name} 冷却中\");\n            return;\n        }\n\n        if (playerMana.CurrentMana &lt; skill.ManaCost)\n        {\n            Debug.Log($\"法力值不足，无法释放 {skill.Name}\");\n            return;\n        }\n\n        playerMana.ConsumeMana(skill.ManaCost);\n        skill.Activate(gameObject);\n    }\n\n    public bool EquipSkill(ISkill skill)\n    {\n        if (equippedSkills.Count &gt;= maxEquippedSkills)\n        {\n            Debug.Log(\"技能栏已满\");\n            return false;\n        }\n\n        if (!availableSkills.Contains(skill))\n        {\n            Debug.Log(\"技能未解锁\");\n            return false;\n        }\n\n        equippedSkills.Add(skill);\n        Debug.Log($\"装备技能：{skill.Name}\");\n        return true;\n    }\n\n    public void UnequipSkill(ISkill skill)\n    {\n        if (equippedSkills.Remove(skill))\n        {\n            Debug.Log($\"卸下技能：{skill.Name}\");\n        }\n    }\n\n    public void LearnSkill(ISkill skill)\n    {\n        if (!availableSkills.Contains(skill))\n        {\n            availableSkills.Add(skill);\n            Debug.Log($\"学会新技能：{skill.Name}\");\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#高级使用技巧","level":2,"title":"高级使用技巧","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#引用共享","level":3,"title":"引用共享","text":"<p><code>SerializeReference</code> 支持引用共享，多个字段可以引用同一个对象：</p> <pre><code>public class ReferenceSharing : MonoBehaviour\n{\n    [SerializeReference] private IWeapon playerWeapon;\n    [SerializeReference] private IWeapon droppedWeapon;\n\n    // 两个字段可以引用同一个武器对象\n    private void Start()\n    {\n        var sharedWeapon = new Pistol();\n        playerWeapon = sharedWeapon;\n        droppedWeapon = sharedWeapon; // 共享引用\n\n        // 修改其中一个会影响另一个\n        if (playerWeapon is Pistol pistol)\n        {\n            pistol.Fire(Vector3.zero, Vector3.forward);\n            // droppedWeapon 的弹药也会减少\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#空值处理","level":3,"title":"空值处理","text":"<pre><code>public class NullHandling : MonoBehaviour\n{\n    [SerializeReference] private IWeapon weapon; // 可以为 null\n\n    private void Update()\n    {\n        // 安全的空值检查\n        if (weapon?.CanFire() == true)\n        {\n            weapon.Fire(transform.position, transform.forward);\n        }\n    }\n\n    public void EquipWeapon(IWeapon newWeapon)\n    {\n        weapon = newWeapon; // 可以赋值为 null 来卸下武器\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#类型过滤","level":3,"title":"类型过滤","text":"<p>使用 <code>SubclassSelector</code> 特性（需要 Odin Inspector）来限制可选择的类型：</p> <pre><code>public class TypeFiltering : MonoBehaviour\n{\n    [SerializeReference, SubclassSelector]\n    private IWeapon restrictedWeapon; // 只显示 IWeapon 的实现类\n\n    [SerializeReference]\n    [SubclassSelector(IncludeBaseType = false)]\n    private BaseEnemy enemyType; // 排除基类，只显示派生类\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#性能考量","level":2,"title":"性能考量","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#序列化性能","level":3,"title":"序列化性能","text":"操作类型 相对性能 影响因素 序列化 85% 类型信息存储开销 反序列化 80% 反射创建实例开销 内存占用 110% 额外的类型信息 加载时间 90% 类型解析开销","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#优化建议","level":3,"title":"优化建议","text":"<ol> <li>避免深度嵌套：限制 <code>SerializeReference</code> 对象的嵌套层次</li> <li>合理使用缓存：缓存频繁访问的接口实现</li> <li>类型预热：在游戏启动时预先创建常用类型实例</li> <li>批量序列化：将相关对象组合到容器中一起序列化</li> </ol> <pre><code>// 推荐：批量序列化\n[System.Serializable]\npublic class WeaponLoadout\n{\n    [SerializeReference] public List&lt;IWeapon&gt; weapons;\n    [SerializeReference] public List&lt;ISkill&gt; skills;\n}\n\npublic class OptimizedPlayerController : MonoBehaviour\n{\n    [SerializeReference] private WeaponLoadout loadout; // 批量序列化\n\n    // 避免：大量独立的 SerializeReference 字段\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#常见问题与解决方案","level":2,"title":"常见问题与解决方案","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#问题1接口在-inspector-中显示为-none","level":3,"title":"问题1：接口在 Inspector 中显示为 None","text":"<p>原因：没有具体的实现类或类型不可序列化</p> <p>解决方案：</p> <pre><code>// 确保实现类标记为 [System.Serializable]\n[System.Serializable]\npublic class SwordWeapon : IWeapon\n{\n    // 实现内容...\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#问题2序列化后数据丢失","level":3,"title":"问题2：序列化后数据丢失","text":"<p>原因：类型重命名或命名空间变更</p> <p>解决方案：</p> <pre><code>// 使用 FormerlySerializedAs 特性保持兼容性\n[System.Serializable]\npublic class RenamedWeapon : IWeapon\n{\n    [FormerlySerializedAs(\"oldFieldName\")]\n    [SerializeField] private float newFieldName;\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#问题3运行时性能问题","level":3,"title":"问题3：运行时性能问题","text":"<p>原因：频繁的类型检查和转换</p> <p>解决方案：</p> <pre><code>public class PerformanceOptimized : MonoBehaviour\n{\n    [SerializeReference] private IWeapon weapon;\n\n    // 缓存类型检查结果\n    private IReloadable reloadableWeapon;\n    private bool isReloadable;\n\n    private void Start()\n    {\n        // 启动时进行类型检查并缓存\n        reloadableWeapon = weapon as IReloadable;\n        isReloadable = reloadableWeapon != null;\n    }\n\n    private void Update()\n    {\n        // 使用缓存的结果，避免重复类型检查\n        if (isReloadable &amp;&amp; reloadableWeapon.NeedsReload())\n        {\n            reloadableWeapon.Reload();\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#与-odin-inspector-的协同","level":2,"title":"与 Odin Inspector 的协同","text":"<p><code>Odin Inspector</code> 进一步增强了 <code>SerializeReference</code> 的功能：</p>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#增强的类型选择器","level":3,"title":"增强的类型选择器","text":"<pre><code>public class OdinEnhanced : SerializedMonoBehaviour\n{\n    [SerializeReference, SubclassSelector]\n    private IWeapon weapon; // 友好的类型选择下拉菜单\n\n    [SerializeReference, ShowInInspector]\n    private List&lt;ISkill&gt; skills; // 支持复杂集合的可视化编辑\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#自定义绘制器","level":3,"title":"自定义绘制器","text":"<pre><code>public class WeaponDrawer : OdinAttributeDrawer&lt;WeaponAttribute&gt;\n{\n    protected override void DrawPropertyLayout(GUIContent label)\n    {\n        // 自定义武器字段的绘制方式\n        Property.Draw(label);\n\n        if (Property.ValueEntry.SmartValue is IWeapon weapon)\n        {\n            EditorGUILayout.LabelField($\"伤害: {weapon.Damage}\");\n            EditorGUILayout.LabelField($\"射速: {weapon.FireRate}\");\n        }\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#最佳实践总结","level":2,"title":"最佳实践总结","text":"","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#设计原则","level":3,"title":"设计原则","text":"<ol> <li>接口优先：优先设计接口，后实现具体类</li> <li>职责单一：每个接口专注于单一职责</li> <li>组合优于继承：通过接口组合实现复杂功能</li> <li>数据驱动：将配置数据与行为逻辑分离</li> </ol>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#代码规范","level":3,"title":"代码规范","text":"<pre><code>// ✅ 推荐的命名和结构\npublic interface IGameplayElement\n{\n    string DisplayName { get; }\n    bool IsActive { get; }\n    void Initialize();\n    void Cleanup();\n}\n\n[System.Serializable]\npublic class ConcreteGameplayElement : IGameplayElement\n{\n    [SerializeField] private string displayName;\n    [SerializeField] private bool isActive = true;\n\n    public string DisplayName =&gt; displayName;\n    public bool IsActive =&gt; isActive;\n\n    public void Initialize()\n    {\n        // 初始化逻辑\n    }\n\n    public void Cleanup()\n    {\n        // 清理逻辑\n    }\n}\n</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#架构建议","level":3,"title":"架构建议","text":"<pre><code>graph TD\n    A[游戏对象] --&gt; B[主控制器组件]\n    B --&gt; C[SerializeReference 接口字段]\n    C --&gt; D[具体实现类]\n\n    E[配置资产] --&gt; F[ScriptableObject]\n    F --&gt; G[SerializeReference 配置]\n    G --&gt; H[运行时实例化]</code></pre>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/serializereference-attribute/#结语","level":2,"title":"结语","text":"<p><code>SerializeReferenceAttribute</code> 为 Unity 开发带来了真正的多态序列化能力，使得我们能够构建更加灵活、可扩展的游戏架构。通过合理使用这个特性，结合良好的接口设计和组件化思维，可以大大提升代码的可维护性和扩展性。</p> <p>在实际项目中，建议：</p> <ol> <li>渐进式采用：从简单的系统开始使用，逐步扩展到复杂场景</li> <li>性能监控：注意序列化性能，在必要时进行优化</li> <li>团队培训：确保团队成员理解接口设计和多态序列化的概念</li> <li>工具支持：配合 Odin Inspector 等工具提升开发体验</li> </ol> <p>通过掌握 <code>SerializeReferenceAttribute</code>，我们能够编写出更加优雅、灵活的 Unity 代码，为游戏开发带来新的可能性。</p> <p>本文是 Odin Toolkits 系列文章的一部分，致力于分享 Unity 开发中的最佳实践和进阶技巧。</p>","path":["Artical","2025 年 11 月","Unity SerializeReferenceAttribute"],"tags":[]},{"location":"Artical/OdinInspector/OnInspectorInit/","level":1,"title":"<code>[OnInspectorInit]</code> 特性","text":"官方英文原文 <p>The OnInspectorInit attribute takes in an action string as an argument (typically the name of a method to be invoked, or an expression to be executed), and executes that action when the property's drawers are initialized in the inspector. Initialization will happen at least once during the first drawn frame of any given property, but may also happen several times later, most often when the type of a polymorphic property changes and it refreshes its drawer setup and recreates all its children.</p> <p>OnInspectorInit 特性填写一个方法，或者一个表达式，当被挂载此特性的 Property<sup>1</sup> 初始化时，执行对应的方法或者表达式。</p> <p>Odin Inspector 是懒加载，只有当 Property 被显示在 Inspector 面板时，才会初始化，如果 Property 折叠在 Group 中，那么没有打开 Group 时，就不会初始化。</p> <p>Unity 原生是全部 Property 一次初始化。</p> <ol> <li> <p>Inspector 面板中显示的每一个内容在编辑器中被称为一个 Property，这里的 Property 和逻辑代码中说的属性(Property) 不是相同概念。 ↩</p> </li> </ol>","path":["Artical","Odin Inspector","[OnInspectorInit] 特性"],"tags":["odin-inspector"]},{"location":"Artical/OdinInspector/auto-open-gettingstarted/","level":1,"title":"Odin Inspector 自动打开 GettingStartedWindow 的问题","text":"<p>Odin Inspector 是依靠 EditorPrefs 来控制窗口的，初始为 true，显示过之后，变为 false。</p> <pre><code>[Button]\nprivate static void SetPrefs()\n{\n    EditorPrefs.SetBool(\"ODIN_INSPECTOR_SHOW_GETTING_STARTED\", true);\n    EditorPrefs.SetBool(\"ACCEPTED_ODIN_3_0_PERSONAL_EULA\", true);\n}\n</code></pre>","path":["Artical","Odin Inspector","Odin Inspector 自动打开 GettingStartedWindow 的问题"],"tags":["odin-inspector"]},{"location":"Artical/OdinInspector/visual-designer/","level":1,"title":"Visual Designer 设计","text":"<p>Odin Inspector 4.0 Visual Designer 定义了一个新的文本文件类型，<code>ovdf</code>。这个文件类型用于定义可视化设计师的布局和行为。</p> <ol> <li> <p>用户可以发布包含 <code>ovdf</code> 文件的插件，而无需任何代码依赖。此类型的文本不会影响项目，只有在用户安装了 Odin Inspector 4.0 或更高版本时，才会使得 <code>ovdf</code> 文件生效。这样的话，使用或者支持 Odin Inspector 4.0 变得更加简单和灵活，无需依赖任何代码。</p> </li> <li> <p>可视化设计器，默认是不允许修改 Unity 拥有自定义编辑器的脚本的样式的，不打算支持修改自定义编辑器的脚本的样式，未来会确保无法编辑带有自定义编辑器的类型，这样可以避免一些潜在的问题。</p> </li> </ol> <p>Note</p> <p>为了兼容旧版本的 Odin Inspector，可以先用 Visual Designer 设计布局，然后再用代码实现逻辑。</p>","path":["Artical","Odin Inspector","Visual Designer 设计"],"tags":["odin-inspector"]},{"location":"Information/CHANGELOG/","level":1,"title":"CHANGELOG","text":"<p>这个项目的所有显著变化都将记录在这个文件中。</p> <p>格式基于 Keep a Changelog，以及这个项目尽量遵循 Semantic Versioning。</p> <p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog,and this project adheres to Semantic Versioning.</p>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#054---alpha---2025-11-23","level":2,"title":"[0.5.4 - alpha] - 2025-11-23","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added","level":3,"title":"Added","text":"<ul> <li><code>[Important]</code> 新增 <code>Attribute Overview Pro</code> Beta 版本，已完成基础框架设计，只需填充数据内容。Beta 版由旧版，官方 Attribute Overview，Resolved Paramater Window 三部分整合而成。原来的旧版 <code>Attribute Overview Pro</code> 模块内容已经归纳到 Deprecated 文件夹，为 Deprecated 版，后续将不再维护，将在 Beta 版完成数据填充后移除。<ul> <li>新增 <code>AssetsOnly Attribute</code>。</li> <li>新增 <code>AssetList Attribute</code>。</li> </ul> </li> <li>新增 <code>Tuanjie 1.6.7 LTS</code> 版本项目，将作为 Odin Toolkits 的后续开发版本。同时保留原有 <code>Unity 2021.3.45f2c1</code> 版本项目，新版本将导入 <code>Unity 2021.3.45f2c1</code> 版本验证。</li> <li>新增 <code>Script Doc Generator</code> 可视化面板拖拽脚本操作，相比之前的选择 Type 操作，更加方便快捷。优化使用体验。</li> <li>新增 <code>Script Doc Generator</code> 右键菜单，在选中脚本文件后，可以一键添加到可视化面板中，以及直接打开可视化面板。优化使用体验。</li> <li>新增 <code>EditorScriptableSingleton&lt;T&gt;</code>，非 Odin 序列化的编辑器阶段的 ScriptableObject 单例类，用于在编辑器阶段管理单例资源。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed","level":3,"title":"Changed","text":"<ul> <li>优化 <code>BilingualHeaderWidget</code> 布局，使用 4.0.1.0 版本的 <code>Visual Designer</code> 进行布局设计，再编写代码实现。用于兼容 Odin Inspector 低版本。</li> <li>整合 <code>Process Summary</code> 菜单项，将 <code>Summary</code> 有关的菜单项调整为 <code>Process Summary/Sync</code>,<code>Process Summary/Replace</code>,<code>Process Summary/Remove</code> 三个子菜单项。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#fixed","level":3,"title":"Fixed","text":"<ul> <li>优化 Odin Toolkits 菜单项设计，修复 v0.5.3 - alpha 版本中的不足。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#053---alpha---2025-11-15","level":2,"title":"[0.5.3 - alpha] - 2025-11-15","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_1","level":3,"title":"Added","text":"<ul> <li>新增工具 MenuItemViewer，一键查看项目内所有的菜单项，收录到 Tool Packages 模块。</li> <li>新增 Script Doc Generator 工具生成文档时，支持保留 Front Matter 部分，目前支持 \"---\" 和 \"+++\" 格式的 Front Matter。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_1","level":3,"title":"Changed","text":"<ul> <li>修改菜单项，使 Odin Toolkits 和 Odin 菜单项更加接近，减少其他插件的菜单项插入到两者之间的可能性，避免用户体验产生割裂感。</li> <li>优化 Odin Toolkits 导出设置，将 <code>OdinToolkitsEditorInfo</code> 版本信息同步到导出设置中，防止再次出现滞后的问题。</li> <li>优化 Script Doc Generator 模块，将可视化面板与生成文档逻辑代码分离，<code>ScriptDocGeneratorVisualPanelSO</code> 负责接收用户配置输入和行为输入，<code>ScriptDocGeneratorController</code> 负责处理业务逻辑，生成文档。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#fixed_1","level":3,"title":"Fixed","text":"<ul> <li>修复 <code>OdinToolkitsEditorInfo</code> 中版本滞后的问题。</li> <li>修复 Script Doc Generator 生成文档时，首次生成的文档包含增量标识符，之后修改文档生成设置，关闭生成增量标识符后，覆盖原有文档造成用户自定义内容丢失的问题。如果原有文档包含增量标识符和自定义内容，即使此时文档生成设置中关闭了生成增量标识符，新生成的相同文档覆盖时仍然会保留自定义内容.</li> <li>修复 Community 的 SwitchButtonAttribute 模块的路径问题。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#052---alpha---2025-11-12","level":2,"title":"[0.5.2 - alpha] - 2025-11-12","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#fixed_2","level":3,"title":"Fixed","text":"<ul> <li>修复中文 API 文档生成设置中，接口的类型种类的字符串中包含 <code>abstract</code> 关键字的问题。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#051---alpha---2025-11-11","level":2,"title":"[0.5.1 - alpha] - 2025-11-11","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_2","level":3,"title":"Added","text":"<ul> <li>新增 TypeData 完整解析 <code>ReferenceLinkURLAttribute</code> 处理。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#fixed_3","level":3,"title":"Fixed","text":"<ul> <li>修复 Script Doc Generator 生成文档目标文件夹不支持绝对路径的问题。</li> <li>修复 Script Doc Generator 生成文档时，文档编码格式默认使用 UTF-8 with BOM 的问题，此问题曾导致文档的首个标题在特定情况下渲染异常。</li> <li>修复因移除实例成员的自定义默认值解析而出现的单元测试问题。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#050---alpha---2025-11-10","level":2,"title":"[0.5.0 - alpha] - 2025-11-10","text":"<ul> <li>Alpha 阶段不保证向前兼容性。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#核心架构","level":3,"title":"核心架构","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_2","level":4,"title":"Changed","text":"<ul> <li>优化插件结构，设置一级模块和二级模块概念，突出重要模块，一级模块位于 OdinToolkits 文件夹下，二级模块位于 OdinToolkits/Modules 文件夹下。</li> <li>移动 Community 模块，文件路径和 OdinToolkits 同级，将发布两个版本的 UnityPackage，一个包含 Community 模块，一个不包含 Community 模块。修正依赖关系，Community 依赖 OdinToolkits 集成模块，没有循环依赖。因此 OdinToolkits 集成模块可以独立使用。</li> <li>更新项目 Unity 版本为 2021.3.45f2c1</li> <li>修改 <code>AttributeOverviewPro</code> 为一级模块，位于 OdinToolkits 文件夹下。</li> <li>修改 <code>ChineseSummaryAttribute</code> 为 <code>SummaryAttribute</code>，不考虑同时存在中文和英文的注释特性情况，只有一个 Summary 注释。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#script-doc-generator-脚本文档生成器","level":3,"title":"Script Doc Generator 脚本文档生成器","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_3","level":4,"title":"Added","text":"<ul> <li>新增 <code>MemberData</code>、<code>TypeData</code>、<code>ConstructorData</code>、<code>EventData</code>、<code>MethodData</code>、<code>ParameterData</code>、<code>PropertyData</code>、<code>FieldData</code> 类，用于存储成员的解析数据，与 C# 反射相关的类一一对应。其中 <code>MethodData</code> 类不包含构造方法。</li> <li>新增 TypeAnalyzer 类型解析器的类的单元测试，共 143 个测试用例，其中 <code>TypeData</code> 14 个，<code>ConstructorData</code> 2 个，<code>EventData</code> 6 个，<code>MethodData</code> 23 个，<code>PropertyData</code>  13 个，<code>FieldData</code> 85 个，基本覆盖大部分类型解析情况。</li> <li>新增 <code>IsFromInheritance(this MemberInfo memberInfo)</code> 方法的单元测试，一共 4 个测试用例，确保方法可以正确判断成员是否来自继承关系。</li> <li>新增 <code>DocGeneratorSettingSO</code> 的设置字段，包括是否生成命名空间文件夹，是否自定义文档扩展名，是否自动生成增量标识符。增加了文档生成的灵活性，可以根据需要自定义文档的组织方式和文件名。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_3","level":4,"title":"Changed","text":"<ul> <li>遵循 SOLID 原则，使用工厂模式，优化代码结构，增强代码结构扩展性，但是增加了代码冗余，可以作为工厂模式参考的示例。</li> <li>修改部分脚本命名。</li> <li>补充部分脚本注释。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#removed","level":4,"title":"Removed","text":"<ul> <li>移除解析实例成员的自定义默认值，仅支持静态、常量默认值。实例成员的默认值可以从构造函数中初始化，也可以硬编码在类中。实际源代码中，可能存在多个构造函数，仅能部分特定实例成员的自定义默认值，避免文档造成误导，因此移除所有实例成员的自定义默认值解析。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#040---alpha---2025-09-21","level":2,"title":"[0.4.0 - alpha] - 2025-09-21","text":"<ul> <li>Alpha 阶段不保证兼容性，内容随时可能修改。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#已知问题","level":3,"title":"已知问题","text":"<ul> <li><code>Attribute Overview Pro</code> 处于重制阶段（其原模块为 <code>Chinese Attribute Overview</code>），当前仍存在错误；但该错误仅属于展示层面问题，大部分特性正常显示，不影响其他未报错内容，且不影响打包流程</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_4","level":3,"title":"Changed","text":"<ul> <li>优化代码架构，更新版本需要重新导入</li> <li>移动 <code>Wigdet</code> 部分到 <code>YuumixEditor</code> 中，重命名为 <code>InspectorWigdet</code>，设计为仅限编辑器阶段使用，打包后剔除，需要使用 <code>UNITY_EDITOR</code> 宏定义包裹</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_4","level":3,"title":"Added","text":"<ul> <li>新增 <code>InspectorBiligualismConfigSO</code>，设置面板语言，提供 <code>OnLanguageChange</code> 事件接口</li> <li>新增 <code>OdinToolkits</code> 文件夹定位接口，<code>OdinToolkitsPaths.GetRootPath()</code> 可以获取到 <code>OdinToolkits</code> 文件夹的相对路径，默认为 <code>\"Assets/Plugins/Yuumix/OdinToolkits\"</code></li> <li>新增 <code>Add ChineseSummary</code> 和 <code>Remove ChineseSummary</code> 右键菜单项，可以一键同步脚本中的 <code>Summary</code> 注释到 <code>ChineseSummary</code> 特性，同时提供一键移除操作，在不需要时可以快速脱离，不影响项目</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#重要更新---script-doc-generator-脚本文档生成器","level":3,"title":"重要更新 - Script Doc Generator 脚本文档生成器","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_5","level":4,"title":"Changed","text":"<ul> <li>升级为独立模块，重构代码逻辑和用户 UI 界面</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_5","level":4,"title":"Added","text":"<ul> <li>新增 <code>ChineseSummaryAttribute</code> 特性，用于替代 XML 的 Summary 注释，将内容作为元数据标记到成员中，使得反射可以获取</li> <li>新增支持分析公共实例构造函数、非构造方法、运算符重载方法、属性、事件及字段</li> <li>新增支持分析目标程序集中的类型并生成文档</li> <li>新增 <code>Test</code> 文件夹，经手动测试，可以支持相当多的脚本内容分析。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#fixed_4","level":4,"title":"Fixed","text":"<ul> <li>修复在中文 API 文档生成器中，方法在高层级基类（不限层级，如祖父类及以上）声明、在下层基类（不限层级）重写时未被正确归纳至继承方法列表的问题</li> <li>修复在方法分析数据中，接口声明的方法在当前类实现时，代码逻辑中并不存在 override 关键字，而方法声明字符串中错误显示 override 的问题</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#community-社区模块","level":3,"title":"Community 社区模块","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_6","level":4,"title":"Added","text":"<ul> <li>新增 <code>ResolvedParametersOverviewCardSO</code> 卡片案例，为纯 <code>Editor</code> 模块</li> <li>新增 <code>SwitchButtonAttributeCardSO</code> 卡片案例，包含 <code>Runtime</code> 和 <code>Editor</code> 两部分</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#033---alpha---2025-08-17","level":2,"title":"[0.3.3 - alpha] - 2025-08-17","text":"<ul> <li>Alpha 阶段不保证兼容性，内容随时可能修改。</li> <li>目前 <code>v0.3.3 - alpha</code> 已经可以支持基础功能运行，具体查看 Odin Toolkits For Unity</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#013beta---2025-05-21","level":2,"title":"[0.1.3.beta] - 2025-05-21","text":"<ul> <li>Beta 阶段不保证向前兼容，删除旧版本再导入</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_7","level":3,"title":"Added","text":"<ul> <li>新增 <code>SwitchButtonAttribute</code>，将 <code>bool</code> 显示为开关，兼容 <code>ToggleLeftAttribute</code> 特性 - 修改自 <code>Schwapo</code> 开源项目</li> <li>新增 <code>Singleton</code> 单例模块</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_6","level":3,"title":"Changed","text":"<ul> <li>完善生成模板代码工具 <code>GenerateTemplateCode</code>，并完善 <code>OdinToolkits</code> 文档网站信息</li> <li>调整菜单路径</li> <li>调整 <code>OdinToolkits</code> 文件夹定位，支持 <code>OdinToolkits</code> 文件夹整体移动</li> <li>调整 <code>Common</code> 文件夹</li> <li>完善 <code>QuickGenerateSO</code> 文档信息</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#removed_1","level":3,"title":"Removed","text":"<ul> <li><code>ComponentBinder</code>，组件绑定工具，在项目中并未完善，无法使用</li> <li>移除 <code>OdinToolkits</code> 编辑器配置，未修改完善</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#012beta---2025-05-09","level":2,"title":"[0.1.2.beta] - 2025-05-09","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#changed_7","level":3,"title":"Changed","text":"<ul> <li>Beta 阶段不向前兼容</li> <li>重新设计项目结构，根目录为 Plugins/Yuumix/OdinToolkits，将 SO 框架移至 OdinToolkits 文件夹内。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#011---2025-04-28","level":2,"title":"[0.1.1] - 2025-04-28","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_8","level":3,"title":"Added","text":"<ul> <li>新增两个第三方引用，位于 ThirdParty 文件夹，包括一个 Odin 相关开源库 和一个 Log相关免费资源</li> <li>新增 Odin 自带特性解析手册，中文解析 Odin 默认提供的 Attributes，比官方的手册更适合中文开发者。</li> <li>新增模版代码生成工具</li> <li>新增 ComponentBinder ，组件绑定工具</li> <li>新增 OdinToolkits 编辑器配置</li> <li>新增自定义扩展 Odin Attribute</li> <li>新增提取 Odin Syntax Highlight 资源文件，让 Odin 的语法高亮为开发者所用</li> <li>新增通用模块 Common，一些跨项目通用类，方法</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#010---2025-04-21","level":2,"title":"[0.1.0] - 2025-04-21","text":"","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CHANGELOG/#added_9","level":3,"title":"Added","text":"<ul> <li>新增一个简单工具，QuickGenerateSO - 快速右键生成 SO 资源，自动遍历选择的资源，根据继承了 <code>ScriptableObject</code> 的脚本，生成 SO 资源。</li> </ul>","path":["Information","CHANGELOG"],"tags":["changelog"]},{"location":"Information/CONTRIBUTING/","level":1,"title":"CONTRIBUTING","text":"<p>Contributor Covenant - 贡献者公约</p> <p>Warning</p> <p>在 v1.0.0 版本前，API 可能随时改变。不推荐依赖 <code>Odin Toolkits</code> API，建议仅作为编辑器工具使用。</p>","path":["Information","CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#贡献准备","level":2,"title":"贡献准备","text":"<p>fork 项目到自己的仓库，clone 到本地。</p> <p>Warning</p> <p>首次打开时报错为正常现象，因为项目本身并不包含 <code>Odin Inspector</code> 插件。请无视错误进入项目后，自行导入 <code>Odin Inspector</code> 插件。</p> <p>如有其他问题，请邮箱联系。</p>","path":["Information","CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#odin-toolkits-集成模块贡献指南","level":2,"title":"<code>Odin Toolkits</code> 集成模块贡献指南","text":"","path":["Information","CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#代码样式规范","level":3,"title":"代码样式规范","text":"<ol> <li><code>Odin Toolkits</code> 代码样式基于 Rider 默认的代码样式。<ol> <li>修改常量命名样式为 <code>ALL_UPPER</code>，完全大写样式。</li> <li><code>换行/特性的排列</code> 中，除了记录字段以外，其他情况特性均独占一行，设置为 <code>从不</code>。</li> <li><code>文件布局</code> 中使用 <code>Unity/带区域的默认值</code>。</li> </ol> </li> </ol>","path":["Information","CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#其他要求","level":3,"title":"其他要求","text":"<p>静态变量要求兼容 <code>Play Mode</code>，尤其是运行时的静态变量，需要手动处理初始化，避免用户在 <code>Play Mode</code> 时出错。</p>","path":["Information","CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#注意事项","level":3,"title":"注意事项","text":"<p>推荐贡献者在脚本最上方添加贡献注释，包括但不限于名称，邮箱，贡献时间，采用后将持续保留在脚本中。</p> <p>此模块将由 <code>Odin Toolkits</code> 核心开发者维护，将进行代码审查，保障不出现恶意代码。</p> <p>后续修改已贡献内容将不会告知原贡献者。</p>","path":["Information","CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#community-社区模块贡献指南","level":2,"title":"<code>Community</code> 社区模块贡献指南","text":"","path":["Information","CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#贡献规范","level":3,"title":"贡献规范","text":"<ol> <li>尽量以单个文件夹的形式贡献</li> <li>在用户不主动使用的情况下，不能影响运行逻辑，不影响其他模块的正常使用。可以有后台自动运行的实例，比如场景单例。</li> <li>删除相关文件夹不报错，不会导致项目运行时错误。</li> <li>编辑器扩展方面尽量使用 <code>Odin Inspector</code>，可以给其他开发者参考，学习 <code>Odin Inspector</code> 的使用。</li> <li>Community 模块的代码样式无要求，选择你喜欢的方式，但是保持一致性，推荐采用 Rider 设置 <code>编辑器/代码样式/C#/文件布局/Unity/带区域的默认值</code>。</li> <li>只包含 <code>Odin Toolkits</code> 集成模块和 <code>Community</code> 模块的新项目打包无警告或错误。</li> <li>静态变量要求兼容 <code>Play Mode</code>，尤其是运行时的静态变量，需要手动处理初始化，避免用户在 <code>Play Mode</code> 时出错。</li> </ol> <p>免责声明</p> <p>Community 模块主要基于社区贡献，<code>Odin Toolkits</code> 核心开发者不负责维护 Community 模块的代码样式，也不对 Community 模块的代码负责。使用时请自行承担风险。</p> <p><code>Odin Toolkits</code> 将默认提供剔除 <code>Community</code> 模块的发行版本。</p>","path":["Information","CONTRIBUTING"],"tags":[]},{"location":"Information/CONTRIBUTING/#静态变量兼容-play-mode-示例","level":2,"title":"静态变量兼容 <code>Play Mode</code> 示例","text":"<p>Tuanjie 关于 Play Mode 的文档</p> <p>Unity 关于 Play Mode 的文档</p> 运行时静态变量初始化<pre><code>// 使用 [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)] 初始化静态变量\npublic class StaticCounterExampleFixed : MonoBehaviour\n{\n    static int counter = 0;\n\n    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]\n    static void Init()\n    {\n        Debug.Log(\"Counter reset.\");\n        counter = 0;   \n    }\n\n    // 每帧调用一次 Update\n    void Update()\n    {\n        if (Input.GetButtonDown(\"Jump\"))\n        {\n        counter++;\n        Debug.Log(\"Counter: \" + counter);\n        }\n    }\n}\n</code></pre> 运行时静态事件订阅处理<pre><code>using UnityEngine;\n\n// 使用 [RuntimeInitializeOnLoadMethod] 初始化静态事件订阅处理\npublic class StaticEventExampleFixed : MonoBehaviour\n{\n    [RuntimeInitializeOnLoadMethod()]\n    static void RunOnStart()\n    {\n        Debug.Log(\"Unregistering quit function\");\n        Application.quitting -= Quit;\n    }\n\n    void Start()\n    {\n        Debug.Log(\"Registering quit function\");\n        Application.quitting += Quit;\n    }\n\n    static void Quit()\n    {\n        Debug.Log(\"Quitting the Player\");\n    }\n}\n</code></pre> <p>对于 Editor 脚本（比如自定义的 Editor 窗口或使用静态对象的 Inspector），使用 <code>[InitializeOnEnterPlayMode]</code> 属性来重置静态字段和事件处理程序。</p>","path":["Information","CONTRIBUTING"],"tags":[]},{"location":"Information/LICENSE/","level":1,"title":"The MIT License (MIT)","text":"<p>Copyright (c) 2025 Yuumix and contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software<sup>1</sup>.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p>现特此授予任何获取本软件及相关文档文件（以下简称“软件”）的人士免费使用该软件的权限，且不受任何限制，包括但不限于使用、复制、修改、合并、发布、分发、转授许可以及/或出售该软件的权利，以及允许因使用该软件而获得该软件的人进行上述操作的权限，但需遵守以下条件：</p> <p>上述版权声明以及本许可声明应包含在所有副本或软件的实质性内容中。</p> <p>该软件“按原样”提供，不提供任何形式的保证，包括但不限于关于其性能、适用性以及不侵犯版权的保证。在任何情况下，作者或版权持有者均不承担任何因该软件或其使用而引起的任何索赔、损害赔偿或其他责任，无论是基于合同、侵权还是其他原因。</p> <ol> <li> <p>在基于 Odin Toolkits 进行修改或衍生的 Unity 插件中应包含本许可声明。 ↩</p> </li> </ol>","path":["Information","The MIT License (MIT)"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/","level":1,"title":"Logo 图标许可证声明","text":"","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#基本信息","level":2,"title":"基本信息","text":"项目 详情 项目名称 Odin Toolkits Logo Logo 设计者 Yuumix 创建日期 2025年 版权归属 Yuumix 许可证 MIT License","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#logo-设计详情","level":2,"title":"Logo 设计详情","text":"","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#设计工具与来源","level":3,"title":"设计工具与来源","text":"<ul> <li>设计工具: ShipFast LogoFast</li> <li>图标来源: Lucide Icons - <code>Webhook</code> 图标</li> <li>图标许可证: ISC License (开源友好)</li> <li>设计方式: 在线工具生成 + 自定义样式配置</li> </ul>","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#设计参数配置","level":3,"title":"设计参数配置","text":"","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#图标设置","level":4,"title":"图标设置","text":"参数 数值 图标名称 Webhook 尺寸 350px 旋转角度 180° 边框宽度 2.5px 主体颜色 <code>#333333</code>","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#背景设计","level":4,"title":"背景设计","text":"参数 数值 圆角 120px 内边距 100px 渐变角度 45° 左下角色 <code>#ff3802</code> 中间过渡 纯白色 (60%位置) 右上角色 <code>#0095ff</code>","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#颜色方案","level":3,"title":"颜色方案","text":"","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#全彩版本","level":4,"title":"全彩版本","text":"<pre><code>/* 主图标颜色 */\n.logo-icon {\n  color: #333333; /* 深灰色 */\n  border: 2.5px solid #333333;\n}\n\n/* 背景渐变 */\n.logo-background {\n  background: linear-gradient(45deg, \n    #ff3802 0%,     /* 橙红色 */\n    #ffffff 60%,    /* 白色过渡 */\n    #0095ff 100%    /* 深蓝色 */\n  );\n  border-radius: 120px;\n  padding: 100px;\n}\n</code></pre>","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#许可证声明","level":2,"title":"许可证声明","text":"","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#logo-版权信息","level":3,"title":"Logo 版权信息","text":"<pre><code>Copyright (c) 2025 Yuumix\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this logo design and associated documentation files (the \"Logo\"), to deal\nin the Logo without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Logo, and to permit persons to whom the Logo is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Logo.\n\nTHE LOGO IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE LOGO OR THE USE OR OTHER DEALINGS IN THE\nLOGO.\n</code></pre>","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#联系","level":2,"title":"联系","text":"<p>如有关于 Logo 使用的疑问，请联系：</p> <ul> <li>邮箱: zeriying@gmail.com</li> <li>项目地址: https://github.com/yuumixcode/OdinToolkits-For-Unity</li> <li>网站: https://www.odintoolkits.cn/</li> </ul>","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#致谢","level":2,"title":"致谢","text":"","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#lucide-icons-致谢","level":3,"title":"Lucide Icons 致谢","text":"<pre><code>本Logo使用了 Lucide Icons 项目中的 \"Webhook\" 图标\n\n- 项目地址: https://lucide.dev/\n- 许可证: ISC License\n- 版权: Lucide Contributors\n- 使用方式: 经过旋转和样式定制后集成到 Logo 设计中\n</code></pre>","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/LOGO-LICENSE/#设计工具致谢","level":3,"title":"设计工具致谢","text":"<pre><code>Logo 通过 ShipFast LogoFast 在线工具生成\n\n- 工具地址: https://shipfa.st/tools/logo-fast\n- 开发者: Marc Lou (Sirenix)\n- 性质: 免费在线设计工具\n- 生成内容版权归用户所有\n</code></pre>","path":["Information","Logo 图标许可证声明"],"tags":["license"]},{"location":"Information/ROADMAP/","level":1,"title":"ROADMAP","text":"<p>记录项目的发展方向和计划。</p>","path":["ROADMAP"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/","level":1,"title":"Quick Generate SO","text":"","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/#简介","level":2,"title":"简介","text":"<p>Quick Generate SO 是一个用于快速生成 ScriptableObject 资源的工具。</p>","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/#开始使用","level":2,"title":"开始使用","text":"<ol> <li>选择继承了 <code>ScriptableObject</code> 的脚本</li> <li>右键选择 <code>Create SO Asset From Selected</code></li> <li>在当前目录生成一个 SO 资源</li> </ol> <p>提示</p> <ol> <li>支持单选和多选。<ol> <li>单选 SO 脚本生成时可以立即设置文件名。</li> <li>多选 SO 脚本生成时将直接生成资源文件，使用默认命名。</li> </ol> </li> <li>只有当选择的资源中包含有继承 <code>ScriptableObject</code> 的脚本文件时才可以点击 <code>Create SO Asset From Selected</code>。</li> </ol>","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/#菜单项","level":2,"title":"菜单项","text":"","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/Modules/QuickGenerateSO/#已知限制","level":2,"title":"已知限制","text":"<p>Warning</p> <p>为确保准确，一个脚本文件中只包含一个 public 的 class，并且继承 <code>ScriptableObject</code>。 </p>","path":["Manual","Modules","Quick Generate SO"],"tags":[]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/","level":1,"title":"Script Doc Generator 使用指南","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#简介","level":2,"title":"简介","text":"<p>Script Doc Generator 是 Odin Toolkits For Unity 的核心模块之一，快捷生成代码注释文档。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#核心特性","level":3,"title":"核心特性","text":"<ol> <li>支持单个类型、多个类型或整个程序集的文档批量生成。</li> <li>支持脚本文档增量生成，默认保留文档中 “## 额外说明” 后的内容，不覆盖生成。</li> <li>支持分析源代码中声明的类，以及类包含的构造函数、方法、事件、属性、字段。</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#开始使用","level":2,"title":"开始使用","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#源代码要求","level":3,"title":"源代码要求","text":"<p>Script Doc Generator 主要依靠 <code>Reflection</code> 反射。注释采用的是读取 <code>[Summary(\"xxx\")]</code> 的值的方案。因此，要求源代码中给需要生成注释的成员添加 <code>[Summary]</code> 。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#summaryprocessormenuitems","level":4,"title":"SummaryProcessorMenuItems","text":"<p>为了更方便地使用工具，设计了 <code>SummaryProcessorMenuItems</code> 右键菜单。</p> <p>提供了三个右键选项，当选择的资源中包含脚本文件时，可以选择执行。</p> <ol> <li>Sync SummaryAttribute。读取 XML 注释中的 <code>&lt;summary&gt;</code> 内容，添加<code>[Summary(\"xxx\")]</code> 特性到成员上方。</li> <li>Replace SummaryAttribute。读取 XML 注释中的 <code>&lt;summary&gt;</code> 内容，删除 XML 的 <code>&lt;summary&gt;</code> 内容，然后添加 <code>[Summary(\"xxx\")]</code> 特性到成员上方。</li> <li>Remove SummaryAttribute。移除选择的脚本源代码中的 <code>[Summary(\"xxx\")]</code> 特性。</li> </ol> <p></p> <p>为了正确添加 <code>[Summary]</code> 特性，在执行操作前，推荐使用 IDE 对代码进行格式化。最好设置为特性和成员永不在同一行，以 Rider 举例。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#打开工具面板","level":3,"title":"打开工具面板","text":"<p>通过 Unity 编辑器菜单打开：Tools/Odin Toolkits/Script Doc Generator。</p> <p></p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#设置文档保存路径","level":3,"title":"设置文档保存路径","text":"<p>在工具窗口的 “存放脚本文档的目标文件夹路径” 输入框中，设置文档导出根目录</p> <ul> <li>支持绝对路径输入</li> <li>支持拖拽文件夹到输入框快速设置</li> <li>若路径不存在，生成时会提示自动创建文件夹</li> </ul> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#文档生成器设置","level":3,"title":"文档生成器设置","text":"<p>默认提供中文 API 文档生成器 <code>CnAPIDocGeneratorSettingSO</code>，可生成包含中文注释的 Markdown 文档。</p> <p>如需自定义文档格式，声明一个继承自 <code>DocGeneratorSettingSO</code> 的类，实现 <code>GetGeneratedDoc</code> 方法，生成 SO 资源文件并更换文档生成设置资源文件。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#docgeneratorsettingso","level":4,"title":"DocGeneratorSettingSO","text":"<ol> <li>是否按命名空间生成文件夹</li> <li>是否使用自定义文档扩展名</li> <li>文档扩展名设置</li> <li>是否自动生成增量标识符</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#中文-api-脚本文档结构默认提供的-docgeneratorsettingso","level":4,"title":"中文 API 脚本文档结构（默认提供的 DocGeneratorSettingSO）","text":"<ol> <li>类型名</li> <li>类型类别（如 class、struct，是否静态 / 抽象）</li> <li>所在程序集</li> <li>命名空间</li> <li>类型声明代码（如 <code>public class TestClass : MonoBehaviour</code>）</li> <li>注释（读取源代码中的 SummaryAttribute 的值）</li> <li>构造方法表格形式展示公共实例构造函数的签名及注释。</li> <li>非构造方法按 “声明的普通方法”“继承的普通方法”“运算符特殊方法” 分类，展示方法签名、注释及声明类。</li> <li>事件按 “声明的事件”“继承的事件” 分类，展示事件名称及注释。</li> <li>属性按 “声明的属性”“继承的属性” 分类，展示属性签名及注释。</li> <li>字段按 “声明的字段”“继承的字段” 分类，展示字段签名及注释。</li> <li>额外说明标识符，持久保留在标识符后的自定义内容（增量生成时不覆盖）。</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#选择类型来源","level":3,"title":"选择类型来源","text":"<p>在 “类型来源” 选项中，选择需要生成文档的目标范围。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#singletype-单个目标类型","level":4,"title":"SingleType 单个目标类型","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#multipletypes-多个类型","level":4,"title":"MultipleTypes 多个类型","text":"<p>多类型模式有两种类型提供方式。</p> <p>第一种是 TypeCacheSO 资源，内部有一个类型列表，可以把多个类型的列表持久化存储，比如某个命名空间下的类，之后如果同时修改了多个类，那么可以直接使用这个资源文件，重新生成这些类的脚本文档。</p> <p>同时，在选择了 TypeCacheSO 资源后，临时的 Type 列表将会隐藏。</p> <p></p> <p>其中一种是临时的列表，逐个添加类型。</p> <p>提供了快捷生成 TypeCacheSO 的解决方案，首次添加列表后，点击保存为 SO 资源，可以一键把该临时列表存储到一个新的 TypeCacheSO 中去。</p> <p>另外，可以自定义新生成 TypeCacheSO 资源的文件夹，点击自定义资源存储位置，即可出现路径设置。点击完成设置后，将会隐藏。</p> <p></p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#singleassembly-单个程序集","level":4,"title":"SingleAssembly 单个程序集","text":"<p>单程序集和多类型模式本质一样，不过是选择程序集后，工具将会收集该程序集中包含的所有的类。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#分析类型","level":3,"title":"分析类型","text":"<p>点击按钮分析设置的 Type 类型。</p> <p>可以在类型分析数据结果中查看具体信息。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#生成文档","level":3,"title":"生成文档","text":"<p>在分析类型完成后，将会自动显示生成按钮，点击后，执行生成文档。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#singletype-单类型","level":4,"title":"SingleType 单类型","text":"<ol> <li>若目标类型已标记为 “过时”，会提示确认是否继续生成。</li> <li>生成文档后，自动用默认程序打开文档，并刷新 Unity 资源面板</li> <li>若目标路径已存在同名文档，会提示是否覆盖（覆盖时保留 “## 额外说明” 后的内容）</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#multipletypes-和-singleassembly","level":4,"title":"MultipleTypes 和 SingleAssembly","text":"<p>生成文档后，将自动打开存放文档的文件夹路径。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#文档结果预览","level":3,"title":"文档结果预览","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#rider-格式化设置推荐","level":3,"title":"Rider 格式化设置推荐","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#设置脚本文件布局","level":4,"title":"设置脚本文件布局","text":"<p>推荐使用带区域的默认值。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#快捷键","level":4,"title":"快捷键","text":"<p>InteliJ 默认快捷键：</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#macos","level":5,"title":"MacOS","text":"<p>Shift+Option+Cmd+L</p> <p>打开重新设置代码格式选择面板，没有自定义格式的话，选择完全清理即可。</p> <p></p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#已知限制","level":3,"title":"已知限制","text":"<p>Warning</p> <ol> <li>不支持分析 <code>unsafe</code> 代码。</li> <li>不支持获取实例成员的默认值。</li> </ol>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#常见问题","level":3,"title":"常见问题","text":"<p>Q：生成的文档缺少某些成员？</p> <p>A：工具只解析公共构造函数，以及用户定义的成员，已经剔除程序集自动生成的成员。</p> <p>Q：如何自定义生成的脚本文档格式？</p> <p>A：声明一个继承自 <code>DocGeneratorSettingSO</code> 的类，实现 <code>GetGeneratedDoc</code> 方法，更换文档生成设置资源文件。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/ScriptDocGeneratorUsageGuide/#推荐阅读","level":3,"title":"推荐阅读","text":"<ul> <li>ScriptDocGenerator 单元测试</li> </ul>","path":["Manual","Script Doc Generator","Script Doc Generator 使用指南"],"tags":["Script Doc Generator"]},{"location":"Manual/ScriptDocGenerator/SupportMemberOverview/","level":1,"title":"ScriptDocGenerator 支持的成员种类","text":"","path":["ScriptDocGenerator 支持的成员种类"],"tags":[]},{"location":"Manual/ScriptDocGenerator/SupportMemberOverview/#type","level":2,"title":"Type","text":"<ol> <li>类</li> <li>结构体</li> <li>枚举</li> <li>委托</li> <li>接口</li> <li>记录（Record）</li> </ol>","path":["ScriptDocGenerator 支持的成员种类"],"tags":[]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/","level":1,"title":"Script Doc Generator 单元测试","text":"","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#概述","level":2,"title":"概述","text":"<p>TypeAnalyzer 类型解析器单元测试，共 143 个测试用例，其中 <code>TypeData</code> 14 个，<code>ConstructorData</code> 2 个，<code>EventData</code> 6 个，<code>MethodData</code> 23 个，<code>PropertyData</code>  13 个，<code>FieldData</code> 85 个，基本覆盖大部分类型解析情况。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#typedata","level":2,"title":"<code>TypeData</code>","text":"<p><code>TypeData</code> 单元测试须知</p> <p>TypeData 一共有 14 个测试用例。</p> <p>类型解析支持包括 <code>class</code>、<code>struct</code>、<code>enum</code>、<code>interface</code>、<code>delegate</code>、<code>nested type</code>、<code>record</code>。</p> 14 个测试用例 No.1 - ITestInterface 源码声明<pre><code>public interface ITestInterface { }\n</code></pre> <p>解析结果<pre><code>public interface ITestInterface\n</code></pre> No.2 - TestAbstractClass 源码声明<pre><code>public abstract class TestAbstractClass { }\n</code></pre> 解析结果<pre><code>public abstract class TestAbstractClass\n</code></pre> No.3 - TestSealedClass 源码声明<pre><code>public sealed class TestSealedClass { }\n</code></pre> 解析结果<pre><code>public sealed class TestSealedClass\n</code></pre> No.4 - TestStaticClass 源码声明<pre><code>public static class TestStaticClass { }\n</code></pre> 解析结果<pre><code>public static class TestStaticClass\n</code></pre></p> <p>No.5 - TestGenericClass 源码声明<pre><code>public class TestGenericClass&lt;T&gt; where T : class\n{\n    public T Owner;\n}\n</code></pre> 解析结果<pre><code>public class TestGenericClass&lt;T&gt; where T : class\n</code></pre> No.6 - UnitTestTypes 源码声明<pre><code>public abstract class TestAbstractClass { }\n\npublic class UnitTestTypes : TestAbstractClass { }\n</code></pre> 解析结果<pre><code>public class UnitTestTypes : Yuumix.OdinToolkits.Tests.Editor.TestAbstractClass\n</code></pre> No.7 - TestClassWithAttribute 源码声明<pre><code>[Summary(\"支持解析特性\")]\n[ReferenceLinkURL(\"https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-9.0\")]\npublic class TestClassWithAttribute { }\n</code></pre> 解析结果<pre><code>[ReferenceLinkURL(\"https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-9.0\")]\npublic class TestClassWithAttribute\n</code></pre> <p>No.8 - TestDelegate 源码声明<pre><code>public delegate void TestDelegate();\n</code></pre> 解析结果<pre><code>public delegate void TestDelegate()\n</code></pre></p> <p>No.9 - TestDelegateHasParameters 源码声明<pre><code>public delegate void TestDelegateHasParameters(int a, List&lt;string&gt; b);\n</code></pre> 解析结果<pre><code>public delegate void TestDelegateHasParameters(int a, List&lt;string&gt; b)\n</code></pre></p> <p>No.10 - TestDelegateHasReturnType 源码声明<pre><code>public delegate bool TestDelegateHasReturnType(float a, int[] b);\n</code></pre> 解析结果<pre><code>public delegate bool TestDelegateHasReturnType(float a, int[] b)\n</code></pre> No.11 - TestRecord 源码声明<pre><code>public record TestRecord;\n</code></pre> 解析结果<pre><code>[NullableContext(NullableContextOptions.flow)]\n[Nullable(NullableContextOptions.flow)]\npublic record TestRecord : System.IEquatable&lt;TestRecord&gt;\n</code></pre></p> <p>No.12 - TestStruct 源码声明<pre><code>public struct TestStruct { }\n</code></pre> 解析结果<pre><code>public struct TestStruct : System.ValueType\n</code></pre></p> No.13 - ScriptDocGeneratorTestEnum 源码声明<pre><code>public enum ScriptDocGeneratorTestEnum\n{\n    Value1,\n    Value2,\n    Value3\n}\n</code></pre> 解析结果<pre><code>public enum ScriptDocGeneratorTestEnum : System.Enum, \nSystem.IFormattable, \nSystem.IComparable, \nSystem.IConvertible\n</code></pre> No.14 - NestedClass 源码声明<pre><code>public class UnitTestTypes\n{\n    class NestedClass { }\n}\n</code></pre> 解析结果<pre><code>private class UnitTestTypes.NestedClass\n</code></pre>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#constructordata","level":2,"title":"<code>ConstructorData</code>","text":"<p><code>ConstructorData</code> 单元测试须知</p> <p><code>ConstructorData</code> 一共有 2 个测试用例。</p> <p>只解析公共实例构造方法。</p> <p>构造方法属于特殊的方法成员，部分可参考 <code>MethodData</code> 解析.</p> 2 个测试用例 源码声明<pre><code>public abstract class TestClassAbstract\n{\n    protected TestClassAbstract(int a) { }\n\n    protected TestClassAbstract() { }\n}\n\npublic class TestClass : TestClassAbstract\n{\n    public TestClass() { }\n\n    public TestClass(bool b, int a) : base(a) { }\n\n    TestClass(string s) { }\n}\n</code></pre> 解析后的构造方法完整签名 <code>public UnitTestConstructorsCommon.TestClass()</code> <code>public UnitTestConstructorsCommon.TestClass(bool b, int a)</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#eventdata","level":2,"title":"<code>EventData</code>","text":"<p><code>EventData</code> 单元测试须知</p> <p><code>EventData</code> 一共有 6 个测试用例。</p> <p>只解析使用 <code>event</code> 关键字声明的事件，简单委托属于字段。</p> <p>事件相当于在字段的声明中添加了 <code>event</code> 关键字，部分可参考 <code>FieldData</code> 解析.</p> 6 个测试用例 <pre><code>public event Action ActionEvent;\npublic event Action&lt;int, string&gt; ActionWithParamsEvent;\npublic event Func&lt;int, string, bool&gt; FuncWithParamsEvent;\npublic event Predicate&lt;int&gt; PredicateEvent;\npublic event Comparison&lt;string&gt; ComparisonEvent;\npublic static event Action&lt;bool&gt; StaticActionEvent;\n</code></pre> 解析后的事件完整签名 <code>public event Action ActionEvent;</code> <code>public event Action&lt;int, string&gt; ActionWithParamsEvent;</code> <code>public event Func&lt;int, string, bool&gt; FuncWithParamsEvent;</code> <code>public event Predicate&lt;int&gt; PredicateEvent;</code> <code>public event Comparison&lt;string&gt; ComparisonEvent;</code> <code>public static event Action&lt;bool&gt; StaticActionEvent;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#methoddata","level":2,"title":"<code>MethodData</code>","text":"<p><code>MethodData</code> 单元测试须知</p> <p><code>MethodData</code> 一共有 23 个测试用例。</p> <p><code>MethodData</code> 不包括构造函数，仅包括普通方法。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#非继承方法测试","level":3,"title":"非继承方法测试","text":"11 个测试用例 No.1 - EmptyParamMethod 方法源码声明<pre><code>public void EmptyParamMethod()\n{\n    Debug.Log(\"EmptyParamMethod\");\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void EmptyParamMethod\n完整方法签名：public void EmptyParamMethod()\n</code></pre> No.2 - OneIntParamMethod 方法源码声明<pre><code>public void OneIntParamMethod(int param)\n{\n    Debug.Log(param);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void OneIntParamMethod\n完整方法签名：public void OneIntParamMethod(int param)\n</code></pre> No.3 - TwoParamMethod 方法源码声明<pre><code>public void TwoParamMethod(string param1, bool param2)\n{\n    Debug.Log(param1 + param2);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void TwoParamMethod\n完整方法签名：public void TwoParamMethod(string param1, bool param2)\n</code></pre> No.4 - GenericMethod 方法源码声明<pre><code>public void GenericMethod&lt;T&gt;(T param)\n{\n    Debug.Log(param);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void GenericMethod&lt;T&gt;\n完整方法签名：public void GenericMethod&lt;T&gt;(T param)\n</code></pre> No.5 - TwoParamsGenericMethod 方法源码声明<pre><code>public void TwoParamsGenericMethod&lt;T, T1&gt;(T param1, List&lt;T1&gt; param2)\n{\n    Debug.Log(param1);\n    Debug.Log(param2);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void TwoParamsGenericMethod&lt;T, T1&gt;\n完整方法签名：public void TwoParamsGenericMethod&lt;T, T1&gt;(T param1, List&lt;T1&gt; param2)\n</code></pre> No.6 - IndefiniteParamsMethod 方法源码声明<pre><code>public void IndefiniteParamsMethod(string param1, params bool[] param2)\n{\n    Debug.Log(param1 + param2);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public void IndefiniteParamsMethod\n完整方法签名：public void IndefiniteParamsMethod(string param1, params bool[] param2)\n</code></pre> No.7 - HasReturnStringMethod 方法源码声明<pre><code>public string HasReturnStringMethod(float param1)\n{\n    Debug.Log(param1);\n    return \"HasReturnStringMethod\";\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public string HasReturnStringMethod\n完整方法签名：public string HasReturnStringMethod(float param1)\n</code></pre> No.8 - StaticMethod 方法源码声明<pre><code>public static void StaticMethod()\n{\n    Debug.Log(\"StaticMethod\");\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public static void StaticMethod\n完整方法签名：public static void StaticMethod()\n</code></pre> No.9 - HasReturnBoolMethodWithDefault 方法源码声明<pre><code>public static bool HasReturnBoolMethodWithDefault(float param1 = 5f, bool param2 = false,\n    string param3 = \"Hello World\", int param4 = 0,\n    ScriptDocGeneratorTestEnum param5 = ScriptDocGeneratorTestEnum.Value3)\n{\n    Debug.Log(param3 + param4);\n    return true;\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public static bool HasReturnBoolMethodWithDefault\n完整方法签名：public static bool HasReturnBoolMethodWithDefault(float param1 = 5f, \nbool param2 = false, string param3 = \"Hello World\", int param4 = 0,\nScriptDocGeneratorTestEnum param5 = ScriptDocGeneratorTestEnum.Value3)\n</code></pre> No.10 - AsyncMethod 方法源码声明<pre><code>public static async Task AsyncMethod()\n{\n    await Task.Delay(1);\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public static async Task AsyncMethod\n完整方法签名：public static async Task AsyncMethod()\n</code></pre> No.11 - AsyncMethodWithReturnValue 方法源码声明<pre><code>public async Task&lt;int&gt; AsyncMethodWithReturnValue()\n{\n    await Task.Delay(1);\n    return 42;\n}\n</code></pre> 解析结果<pre><code>无参数短方法签名：public async Task&lt;int&gt; AsyncMethodWithReturnValue\n完整方法签名：public async Task&lt;int&gt; AsyncMethodWithReturnValue()\n</code></pre>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#继承接口方法测试","level":3,"title":"继承、接口方法测试","text":"4 个测试用例 <pre><code>public interface IInterface\n{\n    void InterfaceMethod();\n}\n\npublic abstract class TestClassAbstract\n{\n    public virtual void OverrideVirtualMethod() { }\n    public abstract void OverrideAbstractMethod();\n}\n\npublic class TestClassImplement : TestClassAbstract, IInterface\n{\n    public override void OverrideAbstractMethod() { }\n    public override void OverrideVirtualMethod() { \n    public void InterfaceMethod()\n    {\n        Debug.Log(\"InterfaceMethod\");\n    }\n}\n</code></pre> 解析后的方法完整签名 <code>public virtual void OverrideVirtualMethod()</code> <code>public override void OverrideAbstractMethod()</code> <code>public override void OverrideVirtualMethod()</code> <code>public void InterfaceMethod()</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#运算符方法测试","level":3,"title":"运算符方法测试","text":"7 个测试用例 <pre><code>public static TestClass operator +(TestClass a, TestClass b) =&gt; new TestClass();\npublic static TestClass operator -(TestClass a, TestClass b) =&gt; new TestClass();\npublic static TestClass operator *(TestClass a, TestClass b) =&gt; new TestClass();\npublic static TestClass operator /(TestClass a, TestClass b) =&gt; new TestClass();\npublic static TestClass operator %(TestClass a, TestClass b) =&gt; new TestClass();\npublic static implicit operator TestClass(int a) =&gt; new TestClass();\npublic static explicit operator float(TestClass a) =&gt; 1f;\n</code></pre> 解析后的运算符方法完整签名 <code>public static UnitTestMethodsOperator.TestClass operator +(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static UnitTestMethodsOperator.TestClass operator -(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static UnitTestMethodsOperator.TestClass operator *(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static UnitTestMethodsOperator.TestClass operator /(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static UnitTestMethodsOperator.TestClass operator %(UnitTestMethodsOperator.TestClass a, UnitTestMethodsOperator.TestClass b)</code> <code>public static implicit operator UnitTestMethodsOperator.TestClass(int a)</code> <code>public static explicit operator float(UnitTestMethodsOperator.TestClass a)</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#静态扩展方法测试","level":3,"title":"静态扩展方法测试","text":"1 个测试用例 <pre><code>public static class TestStaticExtension\n{\n    public static int StaticMethod(this UnitTestMethodsStaticExtension.TestClass t) =&gt; 0;\n}\n</code></pre> 解析后的静态扩展方法完整签名 <code>public static int StaticMethod(this UnitTestMethodsStaticExtension.TestClass t)</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#propertydata","level":2,"title":"<code>PropertyData</code>","text":"<p><code>PropertyData</code> 测试须知</p> <p><code>PropertyData</code> 一共有 13 个测试用例。</p> <p>属性相当于在字段的声明中添加了 <code>get</code> 和 <code>set</code> 访问器，部分属性参考字段解析。</p> <p><code>PropertyData</code> 自定义默认值解析仅支持静态属性。</p> <p>不支持属性的访问修饰符与 get 和 set 访问器都不同的情况</p> <pre><code>protected bool BoolPropertyPrivateGetPublicSet { private get; set; }\n</code></pre>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#实例和静态基础类型属性单元测试","level":3,"title":"实例和静态基础类型属性单元测试","text":"8 个测试用例 <pre><code>public int IntPropertyPublicGetPublicSet { get; set; }\npublic string StringPropertyPublicGetInternalSet { get; internal set; }\npublic float FloatPropertyPublicGetProtectedSet { get; protected set; }\npublic bool BoolPropertyPublicGetPrivateSet { get; private set; }\npublic int IntPropertyInternalGetPublicSet { internal get; set; }\npublic float FloatPropertyProtectedGetPublicSet { protected get; set; }\npublic bool BoolPropertyPrivateGetPublicSet { private get; set; }\npublic static int StaticIntPropertyPublicGetPublicSet { get; set; }\n</code></pre> 解析后的属性完整签名 <code>public int IntPropertyPublicGetPublicSet { get; set; }</code> <code>public string StringPropertyPublicGetInternalSet { get; internal set; }</code> <code>public float FloatPropertyPublicGetProtectedSet { get; protected set; }</code> <code>public bool BoolPropertyPublicGetPrivateSet { get; private set; }</code> <code>public int IntPropertyInternalGetPublicSet { internal get; set; }</code> <code>public float FloatPropertyProtectedGetPublicSet { protected get; set; }</code> <code>public bool BoolPropertyPrivateGetPublicSet { private get; set; }</code> <code>public static int StaticIntPropertyPublicGetPublicSet { get; set; }</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#自定义默认值属性单元测试","level":3,"title":"自定义默认值属性单元测试","text":"5 个测试用例 <pre><code>public static int StaticIntPropertyWithDefaultValue { get; set; } = 1;\npublic static float StaticFloatPropertyWithDefaultValue { get; set; } = 1f;\npublic static bool StaticBoolPropertyWithDefaultValue { get; set; } = true;\npublic static string StaticStringPropertyWithDefaultValue { get; set; } = \"Hello\";\npublic static TestEnum StaticEnumPropertyWithDefaultValue { get; set; } = TestEnum.B;\n</code></pre> 解析后的属性完整签名 <code>public static int StaticIntPropertyWithDefaultValue { get; set; } = 1;</code> <code>public static float StaticFloatPropertyWithDefaultValue { get; set; } = 1f;</code> <code>public static bool StaticBoolPropertyWithDefaultValue { get; set; } = true;</code> <code>public static string StaticStringPropertyWithDefaultValue { get; set; } = \"Hello\";</code> <code>public static TestEnum StaticEnumPropertyWithDefaultValue { get; set; } = TestEnum.B;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#fielddata","level":2,"title":"<code>FieldData</code>","text":"<p><code>FieldData</code> 单元测试须知</p> <p><code>FieldData</code> 一共有 85 个测试用例。</p>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#不同访问修饰符和复合关键字","level":3,"title":"不同访问修饰符和复合关键字","text":"6 个测试用例 <pre><code>int _privateField;\ninternal int InternalField;\nprivate protected int PrivateProtectedField;\nprotected int ProtectedField;\nprotected internal int ProtectedInternalField;\npublic int PublicField;\n</code></pre> 解析后的字段完整签名 <code>private int _privateField;</code> <code>internal int InternalField;</code> <code>private protected int PrivateProtectedField;</code> <code>protected int ProtectedField;</code> <code>protected internal int ProtectedInternalField;</code> <code>public int PublicField;</code> 4 个测试用例 <pre><code>public const int CONST_FIELD = 42;\npublic static readonly int StaticReadOnlyField;\npublic static int StaticField;\npublic readonly int ReadOnlyField;\n</code></pre> 解析后的字段完整签名 <code>public const int CONST_FIELD = 42;</code> <code>public static readonly int StaticReadOnlyField;</code> <code>public static int StaticField;</code> <code>public readonly int ReadOnlyField;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#常量字段","level":3,"title":"常量字段","text":"<p>常量字段单元测试须知</p> <ol> <li> <p>常量字段自定义设置默认值的解析测试只包括基础值类型、枚举类型、特殊的 string 引用类型。</p> </li> <li> <p>常量字段部分类型解析限制如下：</p> <p>a. 长整型常量字段，long，解析后的字段数据设置为以 'L' 字符结尾。</p> <p>b. 无符号长整型常量字段，ulong，解析后的字段数据设置为以 'ul' 字符结尾。</p> <p>c. 无符号整型常量字段，uint，解析后的字段数据设置为以 'u' 字符结尾。</p> <p>d. 双精度浮点型常量字段，double，解析后的字段数据设置为以 'd' 字符结尾，且为了保证精准，位数不能超过 15 位，这里的 15 位是指有效数字的位数，不只是小数点后的位数。</p> <p>e. 十进制浮点型常量字段，decimal，解析后的字段数据设置为以 'm' 字符结尾。</p> <p>f. 嵌套类枚举常量字段，UnitTestFieldsIsConstantWithDefaultValue.TestEnum，解析后的字段数据的字段类型会显示嵌套路径。</p> </li> </ol> 16 个测试用例 <pre><code>public const string STRING_CONST_FIELD = \"Hello, World!\";\npublic const int INT_CONST_FIELD = 2147483647;\npublic const float FLOAT_CONST_FIELD = 3.14159f;\npublic const bool BOOLEAN_CONST_FIELD = true;\npublic const char CHAR_CONST_FIELD = 'A';\npublic const byte BYTE_CONST_FIELD = 255;\npublic const sbyte SBYTE_CONST_FIELD = -128;\npublic const short SHORT_CONST_FIELD = 32767;\npublic const ushort USHORT_CONST_FIELD = 65535;\n</code></pre> 解析后的字段完整签名 <code>public const string STRING_CONST_FIELD = \"Hello, World!\";</code> <code>public const int INT_CONST_FIELD = 2147483647;</code> <code>public const float FLOAT_CONST_FIELD = 3.14159f;</code> <code>public const bool BOOLEAN_CONST_FIELD = true;</code> <code>public const char CHAR_CONST_FIELD = 'A';</code> <code>public const byte BYTE_CONST_FIELD = 255;</code> <code>public const sbyte SBYTE_CONST_FIELD = -128;</code> <code>public const short SHORT_CONST_FIELD = 32767;</code> <code>public const ushort USHORT_CONST_FIELD = 65535;</code> <pre><code>public const long LONG_CONST_FIELD = 9223372036854775807L;\npublic const ulong ULONG_CONST_FIELD = 18446744073709551615ul;\npublic const uint UINT_CONST_FIELD = 4294967295u;\npublic const double DOUBLE_CONST_FIELD = 2.71828182845904d; \npublic const decimal DECIMAL_CONST_FIELD = 123.456m;\npublic const ScriptDocGeneratorTestEnum ENUM_CONST_FIELD = ScriptDocGeneratorTestEnum.Value1;\n\n// 嵌套类枚举常量字段，UnitTestFieldsIsConstantWithDefaultValue.TestEnum\npublic const TestEnum NESTED_ENUM_CONST_FIELD = TestEnum.Value3;\n</code></pre> 解析后的字段完整签名 <code>public const long LONG_CONST_FIELD = 9223372036854775807L;</code> <code>public const ulong ULONG_CONST_FIELD = 18446744073709551615ul;</code> <code>public const uint UINT_CONST_FIELD = 4294967295u;</code> <code>public const double DOUBLE_CONST_FIELD = 2.71828182845904d;</code> <code>public const decimal DECIMAL_CONST_FIELD = 123.456m;</code> <code>public const ScriptDocGeneratorTestEnum ENUM_CONST_FIELD = ScriptDocGeneratorTestEnum.Value1;</code> <code>public const UnitTestFieldsIsConstantWithDefaultValue.TestEnum NESTED_ENUM_CONST_FIELD = TestEnum.Value3;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#静态字段","level":3,"title":"静态字段","text":"<p>静态字段单元测试须知</p> <ol> <li> <p>静态字段自定义设置默认值的解析测试只包括基础值类型、枚举类型、特殊的 string 引用类型。</p> </li> <li> <p>静态字段部分类型解析限制和常量一致</p> </li> </ol> 16 个测试用例 <pre><code>public static string StringStaticField = \"Hello, World!\";\npublic static int INTStaticField = 2147483647;\npublic static float FloatStaticField = 3.14159f;\npublic static bool BooleanStaticField = true;\npublic static char CharStaticField = 'A';\npublic static byte ByteStaticField = 255;\npublic static sbyte SbyteStaticField = -128;\npublic static short ShortStaticField = 32767;\npublic static ushort UshortStaticField = 65535;\n</code></pre> 解析后的字段完整签名 <code>public static string StringStaticField = \"Hello, World!\";</code> <code>public static int INTStaticField = 2147483647;</code> <code>public static float FloatStaticField = 3.14159f;</code> <code>public static bool BooleanStaticField = true;</code> <code>public static char CharStaticField = 'A';</code> <code>public static byte ByteStaticField = 255;</code> <code>public static sbyte SbyteStaticField = -128;</code> <code>public static short ShortStaticField = 32767;</code> <code>public static ushort UshortStaticField = 65535;</code> <pre><code>public static long LongStaticField = 9223372036854775807L;\npublic static ulong UlongStaticField = 18446744073709551615ul;\npublic static uint UintStaticField = 4294967295u;\npublic static double DoubleStaticField = 2.71828182845904d;\npublic static decimal DecimalStaticField = 123.456m;\npublic static ScriptDocGeneratorTestEnum EnumStaticField = ScriptDocGeneratorTestEnum.Value2;\npublic static TestEnum NestedEnumStaticField = TestEnum.Value3;\n</code></pre> 解析后的字段完整签名 <code>public static long LongStaticField = 9223372036854775807L;</code> <code>public static ulong UlongStaticField = 18446744073709551615ul;</code> <code>public static uint UintStaticField = 4294967295u;</code> <code>public static double DoubleStaticField = 2.71828182845904d;</code> <code>public static decimal DecimalStaticField = 123.456m;</code> <code>public static ScriptDocGeneratorTestEnum EnumStaticField = ScriptDocGeneratorTestEnum.Value2;</code> <code>public static UnitTestFieldsIsStaticWithDefaultValue.TestEnum NestedEnumStaticField = TestEnum.Value3;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#实例字段","level":3,"title":"实例字段","text":"<p>实例字段单元测试须知</p> <ol> <li>普通实例字段若成功解析，则只读实例字段也可以成功解析，不做另外测试。</li> </ol> 16 个测试用例 <pre><code>class TestClass\n{\n    public string StringField;\n    public int IntField;\n    public float FloatField;\n    public bool BooleanField;\n    public char CharField;\n    public byte ByteField;\n    public sbyte SbyteField;\n    public short ShortField;\n    public ushort UshortField;\n    public long LongField;\n    public ulong UlongField;\n    public uint UintField;\n    public double DoubleField;\n    public decimal DecimalField;\n    public ScriptDocGeneratorTestEnum EnumField;\n    public TestEnum NestedEnumField;\n}\n\nenum TestEnum\n{\n    Value1,\n    Value2,\n}\n</code></pre> 解析后的字段完整签名 <code>public string StringField;</code> <code>public int IntField;</code> <code>public float FloatField;</code> <code>public bool BooleanField;</code> <code>public char CharField;</code> <code>public byte ByteField;</code> <code>public sbyte SbyteField;</code> <code>public short ShortField;</code> <code>public ushort UshortField;</code> <code>public long LongField;</code> <code>public ulong UlongField;</code> <code>public uint UintField;</code> <code>public double DoubleField;</code> <code>public decimal DecimalField;</code> <code>public ScriptDocGeneratorTestEnum EnumField;</code> <code>public TestEnum NestedEnumField;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#集合字段","level":3,"title":"集合字段","text":"16 个测试用例 <pre><code>public int[] ArrayField;\npublic int[,] MultiArrayField;\npublic int[][] JaggedArrayField;\npublic List&lt;string&gt; ListField;\npublic Dictionary&lt;string, int&gt; DictionaryField;\npublic HashSet&lt;string&gt; HashSetField;\npublic SortedDictionary&lt;string, int&gt; SortedDictionaryField;\npublic SortedList&lt;string, int&gt; SortedListField;\npublic Stack&lt;string&gt; StackField;\npublic Queue&lt;int&gt; QueueField;\npublic LinkedList&lt;string&gt; LinkedListField;\npublic System.Collections.ArrayList ArrayListField;\npublic System.Collections.Hashtable HashtableField;\npublic IReadOnlyList&lt;string&gt; ReadOnlyListField;\npublic IReadOnlyDictionary&lt;string, int&gt; ReadOnlyDictionaryField;\npublic ConcurrentDictionary&lt;string, int&gt; ConcurrentDictionaryField;\n</code></pre> 解析后的字段完整签名 <code>public int[] ArrayField;</code> <code>public int[,] MultiArrayField;</code> <code>public int[][] JaggedArrayField;</code> <code>public List&lt;string&gt; ListField;</code> <code>public Dictionary&lt;string, int&gt; DictionaryField;</code> <code>public HashSet&lt;string&gt; HashSetField;</code> <code>public SortedDictionary&lt;string, int&gt; SortedDictionaryField;</code> <code>public SortedList&lt;string, int&gt; SortedListField;</code> <code>public Stack&lt;string&gt; StackField;</code> <code>public Queue&lt;int&gt; QueueField;</code> <code>public LinkedList&lt;string&gt; LinkedListField;</code> <code>public System.Collections.ArrayList ArrayListField;</code> <code>public System.Collections.Hashtable HashtableField;</code> <code>public IReadOnlyList&lt;string&gt; ReadOnlyListField;</code> <code>public IReadOnlyDictionary&lt;string, int&gt; ReadOnlyDictionaryField;</code> <code>public ConcurrentDictionary&lt;string, int&gt; ConcurrentDictionaryField;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#unity-特有字段","level":3,"title":"Unity 特有字段","text":"7 个测试用例 <pre><code>public GameObject gameObjectField;\npublic Transform transformField;\npublic Rigidbody rigidbodyField;\npublic Vector3 vector3Field;\n</code></pre> 完整声明为单行的字段，包含特性 <code>public GameObject gameObjectField;</code> <code>public Transform transformField;</code> <code>public Rigidbody rigidbodyField;</code> <code>public Vector3 vector3Field;</code> Quaternion 字段源码声明<pre><code>[SerializeField]\n[Tooltip(\"This is a tooltip\")]\n[UnityEngine.Range(0, 100)]\npublic Quaternion quaternionField;\n</code></pre> 解析结果<pre><code>[SerializeField]\n[UnityEngine.Tooltip(\"This is a tooltip\")]\n[UnityEngine.Range(0, 100)]\npublic Quaternion quaternionField;\n</code></pre> Color 字段源码声明<pre><code>[ColorUsage(true, true)]\npublic Color colorField = Color.white;\n</code></pre> 解析结果<pre><code>[UnityEngine.ColorUsage(true, true)]\npublic Color colorField;\n</code></pre> LayerMask 字段源码声明<pre><code>[Obsolete(\"Use newField instead\")]\npublic LayerMask layerMaskField;\n</code></pre> 解析结果<pre><code>[Obsolete(\"Use newField instead\")]\npublic LayerMask layerMaskField;\n</code></pre>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"Manual/ScriptDocGenerator/UnitTestSupports/#杂项","level":3,"title":"杂项","text":"4 个测试用例 <pre><code>public TestAbstractClass AbstractField;\npublic dynamic DynamicField;\npublic ITestInterface InterfaceField;\npublic int? NullableField;\n</code></pre> 解析后的字段完整签名 <code>public TestAbstractClass AbstractField;</code> <code>public dynamic DynamicField;</code> <code>public ITestInterface InterfaceField;</code> <code>public int? NullableField;</code>","path":["Manual","Script Doc Generator","Script Doc Generator 单元测试"],"tags":["Script Doc Generator","UnitTest"]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/","level":1,"title":"<code>ConstructorData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class ConstructorData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IConstructorData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#注释","level":3,"title":"注释","text":"<ul> <li>构造方法解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public ConstructorData(ConstructorInfo constructorInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 构造方法的访问修饰符类型 <code>public MemberTypes MemberType { get; }</code> 构造方法的成员类型 <code>public bool IsStatic { get; }</code> 是否为静态构造方法 <code>public string AccessModifierName { get; }</code> 构造方法的访问修饰符名称字符串 <code>public string FullDeclarationWithAttributes { get; }</code> 包含特性和签名的完整构造方法声明 <code>public string MemberTypeName { get; }</code> 构造方法的成员类型名称字符串 <code>public string ParametersDeclaration { get; }</code> 构造方法的参数声明字符串，包含参数名称和类型 <code>public string Signature { get; }</code> 构造方法的完整签名 <code>public string SignatureWithoutParameters { get; }</code> 不包含参数的简单构造方法签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ConstructorData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/","level":1,"title":"<code>DefaultAttributeFilter</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public class DefaultAttributeFilter : Yuumix.OdinToolkits.ScriptDocGenerator.IAttributeFilter\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#注释","level":3,"title":"注释","text":"<ul> <li>默认特性过滤器，构造函数中传入需要排除的 Attribute 类型</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public DefaultAttributeFilter(Type[] excludeTypes)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public bool ShouldFilterOut(Type type)</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public bool ShouldFilterOut</code> 判断传入的特性类型是否应该被过滤掉","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type[] ExcludeTypes { get; }</code> 排除的特性类型","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DefaultAttributeFilter/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DefaultAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/","level":1,"title":"<code>DerivedMemberDataComparer</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public class DerivedMemberDataComparer : System.Collections.Generic.IComparer&lt;IDerivedMemberData&gt;\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#注释","level":3,"title":"注释","text":"<ul> <li>IDerivedMemberData 比较类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public DerivedMemberDataComparer()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public int Compare(IDerivedMemberData x, IDerivedMemberData y)</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public int Compare</code> 比较两个继承 IDerivedMemberData 的数据类的实例，用于排序","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/DerivedMemberDataComparer/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","DerivedMemberDataComparer"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/","level":1,"title":"<code>EventData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class EventData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IEventData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#注释","level":3,"title":"注释","text":"<ul> <li>事件解析数据类，用于存储事件的解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public EventData(EventInfo eventInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 访问修饰符类型 <code>public MemberTypes MemberType { get; }</code> 成员类型 <code>public Type EventType { get; }</code> 事件类型 <code>public bool IsStatic { get; }</code> 是否为静态事件 <code>public string AccessModifierName { get; }</code> 访问修饰符名称 <code>public string EventTypeFullName { get; }</code> 事件类型的完整名称，包括命名空间 <code>public string EventTypeName { get; }</code> 事件类型名称 <code>public string FullDeclarationWithAttributes { get; }</code> 包含特性和签名的完整事件声明 <code>public string MemberTypeName { get; }</code> 成员类型名称 <code>public string Signature { get; private set; }</code> 事件的完整签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/EventData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","EventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/","level":1,"title":"<code>FieldData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class FieldData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IFieldData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#注释","level":3,"title":"注释","text":"<ul> <li>字段解析数据类，用于存储字段的解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public FieldData(FieldInfo fieldInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 访问修饰符类型 <code>public MemberTypes MemberType { get; }</code> 成员类型，指示该成员的类型 <code>public Type FieldType { get; }</code> 字段的类型 <code>public bool IsConstant { get; }</code> 是否为常量字段 <code>public bool IsDynamic { get; }</code> 是否为动态类型字段 <code>public bool IsReadOnly { get; }</code> 是否为只读字段 <code>public bool IsStatic { get; }</code> 指示该字段是否为静态字段 <code>public object DefaultValue { get; }</code> 字段的默认值，没有默认值返回 null <code>public string AccessModifierName { get; }</code> 访问修饰符名称 <code>public string FieldTypeFullName { get; }</code> 字段类型的完整名称 <code>public string FieldTypeName { get; }</code> 字段类型的名称 <code>public string FullDeclarationWithAttributes { get; }</code> 完整字段声明，包含特性和签名，默认剔除 Summary 特性 <code>public string MemberTypeName { get; }</code> 成员类型名称 <code>public string Signature { get; private set; }</code> 字段签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/FieldData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","FieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/","level":1,"title":"<code>IAnalysisDataFactory</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IAnalysisDataFactory\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#注释","level":3,"title":"注释","text":"<ul> <li>解析数据工厂接口，自定义扩展解析数据工厂</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public abstract IConstructorData CreateConstructorData(ConstructorInfo constructorInfo, IAttributeFilter filter = null)</code> <code>public abstract IEventData CreateEventData(EventInfo eventInfo, IAttributeFilter filter = null)</code> <code>public abstract IFieldData CreateFieldData(FieldInfo fieldInfo, IAttributeFilter filter = null)</code> <code>public abstract IMethodData CreateMethodData(MethodInfo methodInfo, IAttributeFilter filter = null)</code> <code>public abstract IPropertyData CreatePropertyData(PropertyInfo propertyInfo, IAttributeFilter filter = null)</code> <code>public abstract ITypeData CreateTypeData(Type type, IAnalysisDataFactory factory = null, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public abstract IConstructorData CreateConstructorData</code> 创建构造函数数据 <code>public abstract IEventData CreateEventData</code> 创建事件数据 <code>public abstract IFieldData CreateFieldData</code> 创建字段数据 <code>public abstract IMethodData CreateMethodData</code> 创建方法数据 <code>public abstract IPropertyData CreatePropertyData</code> 创建属性数据 <code>public abstract ITypeData CreateTypeData</code> 创建类型数据","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAnalysisDataFactory/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/","level":1,"title":"<code>IAttributeFilter</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IAttributeFilter\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#注释","level":3,"title":"注释","text":"<ul> <li>特性过滤器接口，用于过滤掉不需要的特性</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type[] ExcludeTypes { get; }</code> 排除的特性类型","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IAttributeFilter/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IAttributeFilter"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/","level":1,"title":"<code>IConstructorData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IConstructorData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#注释","level":3,"title":"注释","text":"<ul> <li>构造方法数据接口，继承自 IDerivedMemberData</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public string ParametersDeclaration { get; }</code> 方法的参数声明字符串，包含参数名称和类型 <code>public string SignatureWithoutParameters { get; }</code> 不包含参数的简单方法签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IConstructorData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IConstructorData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/","level":1,"title":"<code>IEventData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IEventData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#注释","level":3,"title":"注释","text":"<ul> <li>事件数据接口，继承自 IDerivedMemberData</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type EventType { get; }</code> 事件类型 <code>public string EventTypeFullName { get; }</code> 事件类型的完整名称，包括命名空间 <code>public string EventTypeName { get; }</code> 事件类型名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IEventData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IEventData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/","level":1,"title":"<code>IFieldData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IFieldData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#注释","level":3,"title":"注释","text":"<ul> <li>字段数据接口，继承自 IDerivedMemberData</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type FieldType { get; }</code> 字段的类型 <code>public bool IsConstant { get; }</code> 是否为常量字段（const） <code>public bool IsDynamic { get; }</code> 是否为动态字段（dynamic） <code>public bool IsReadOnly { get; }</code> 是否为只读字段（readonly） <code>public object DefaultValue { get; }</code> 字段的默认值 <code>public string FieldTypeFullName { get; }</code> 这个字段的类型的完整名称 <code>public string FieldTypeName { get; }</code> 这个字段的类型的名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IFieldData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IFieldData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/","level":1,"title":"<code>IMethodData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IMethodData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#注释","level":3,"title":"注释","text":"<ul> <li>方法数据接口，继承自 IDerivedMemberData</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type ReturnType { get; }</code> 方法的返回类型 <code>public bool IsAbstract { get; }</code> 是否带有抽象属性，不一定声明时带有 abstract 关键字 <code>public bool IsAsync { get; }</code> 是否为异步方法 <code>public bool IsFromAncestor { get; }</code> 此方法继承自祖先（不是直接的基类，而是基类的上层） <code>public bool IsFromInterfaceImplement { get; }</code> 此方法继承自接口，在该类中实现 <code>public bool IsOperator { get; }</code> 是否为运算符方法 <code>public bool IsOverloadMethodInDeclaringType { get; set; }</code> 此方法在当前类中存在重载方法，需要在 Type 解析时进行处理 <code>public bool IsOverride { get; }</code> 是否属于重写的方法，不一定带有 override 关键字 <code>public bool IsVirtual { get; }</code> 是否带有虚方法属性，不一定声明时带有 virtual 关键字 <code>public string ParametersDeclaration { get; }</code> 方法的参数声明字符串，包含参数名称和类型 <code>public string ReturnTypeFullName { get; }</code> 方法的返回类型的完整名称 <code>public string ReturnTypeName { get; }</code> 方法的返回类型名称 <code>public string SignatureWithoutParameters { get; }</code> 不包含参数的简单方法签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IMethodData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IMethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/","level":1,"title":"<code>IParameterData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IParameterData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#注释","level":3,"title":"注释","text":"<ul> <li>参数信息解析数据接口</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public ParameterDirection Direction { get; }</code> 参数方向（in/out/ref） <code>public Type ParameterType { get; }</code> 参数类型 <code>public bool HasDefaultValue { get; }</code> 是否有默认值 <code>public bool IsParams { get; }</code> 是否为 params 参数 <code>public object DefaultValue { get; }</code> 默认值 <code>public string Name { get; }</code> 参数名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IParameterData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/","level":1,"title":"<code>IPropertyData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface IPropertyData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#注释","level":3,"title":"注释","text":"<ul> <li>属性数据接口，继承自 IDerivedMemberData，包含属性特有的数据信息和方法，派生类的通用数据信息和方法</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Type PropertyType { get; }</code> 属性类型 <code>public object DefaultValue { get; }</code> 自定义默认值，如果没有自定义默认值，则为 null <code>public string PropertyTypeFullName { get; }</code> 属性类型的完整名称，包括命名空间 <code>public string PropertyTypeName { get; }</code> 属性类型名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/IPropertyData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","IPropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/","level":1,"title":"<code>ITypeData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>interface</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public interface ITypeData : Yuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#注释","level":3,"title":"注释","text":"<ul> <li>类型解析数据接口，继承自 IDerivedMemberData 接口</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public Assembly Assembly { get; }</code> 类型所在的程序集 <code>public IAnalysisDataFactory DataFactory { get; }</code> 分析数据工厂实例对象 <code>public IConstructorData[] RuntimeReflectedConstructorsData { get; }</code> 类型的构造函数解析数据数组，只包含公共构造函数，GetConstructors() 方法 <code>public IEventData[] RuntimeReflectedEventsData { get; }</code> 类型的事件解析数据数组，GetRuntimeEvents() 方法 <code>public IFieldData[] RuntimeReflectedFieldsData { get; }</code> 类型的字段解析数据数组，GetUserDefinedFields() 方法 <code>public IMethodData[] RuntimeReflectedMethodsData { get; }</code> 类型的方法解析数据数组，GetRuntimeMethods() 方法 <code>public IPropertyData[] RuntimeReflectedPropertiesData { get; }</code> 类型的属性解析数据数组，GetRuntimeProperties() 方法 <code>public TypeCategory TypeCategory { get; }</code> Type 种类 <code>public bool IsAbstract { get; }</code> 是否为抽象类型 <code>public bool IsGenericType { get; }</code> 是否为泛型类型 <code>public bool IsSealed { get; }</code> 是否为密封类型 <code>public string AssemblyName { get; }</code> 类型所在的程序集名称 <code>public string NamespaceName { get; }</code> 类型所在的命名空间 <code>public string[] InheritanceChain { get; }</code> 类型的继承链数组 <code>public string[] InterfaceArray { get; }</code> 类型的接口数组 <code>public string[] ReferenceWebLinkArray { get; }</code> 类型的引用链接数组","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ITypeData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ITypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/","level":1,"title":"<code>MethodData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class MethodData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMethodData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#注释","level":3,"title":"注释","text":"<ul> <li>方法解析数据类，用于存储 MethodInfo 的解析结果</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public MethodData(MethodInfo memberInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>public void AddOverloadPrefix()</code> <code>public static string GetMethodKeywordSnippet(MethodInfo methodInfo)</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public void AddOverloadPrefix</code> 为方法添加重载前缀（[Overload]） <code>public static string GetMethodKeywordSnippet</code> 获取方法的关键字片段字符串","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 方法的访问修饰符类型 <code>public MemberTypes MemberType { get; }</code> 方法的成员类型 <code>public Type ReturnType { get; }</code> 方法的返回类型 <code>public bool IsAbstract { get; }</code> 是否为抽象方法（abstract） <code>public bool IsAsync { get; }</code> 是否为异步方法（async） <code>public bool IsFromAncestor { get; }</code> 是否从祖先类继承的重写方法，在该子类的方法签名中不一定带有 override 关键字 <code>public bool IsFromInterfaceImplement { get; }</code> 是否从接口实现的方法 <code>public bool IsOperator { get; }</code> 是否为运算符方法（operator） <code>public bool IsOverloadMethodInDeclaringType { get; set; }</code> 是否为声明类型中的重载方法 <code>public bool IsOverride { get; }</code> 是否有重写方法（override）的特性，方法签名中不一定带有 override 关键字 <code>public bool IsStatic { get; }</code> 是否为静态方法（static） <code>public bool IsVirtual { get; }</code> 是否有虚拟方法（virtual）的特性，方法签名中不一定带有 virtual 关键字 <code>public string AccessModifierName { get; }</code> 方法的访问修饰符名称字符串 <code>public string FullDeclarationWithAttributes { get; }</code> 包含特性的完整方法声明字符串，包含特性声明和方法签名 <code>public string MemberTypeName { get; }</code> 方法的成员类型名称字符串 <code>public string ParametersDeclaration { get; }</code> 方法的参数声明字符串，包含参数名称和类型 <code>public string ReturnTypeFullName { get; }</code> 方法的返回值完整类型名称字符串 <code>public string ReturnTypeName { get; }</code> 方法的返回类型名称字符串 <code>public string Signature { get; private set; }</code> 方法的签名字符串 <code>public string SignatureWithoutParameters { get; }</code> 不包含参数的简单方法签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/MethodData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","MethodData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/","level":1,"title":"<code>ParameterData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class ParameterData : Yuumix.OdinToolkits.ScriptDocGenerator.IParameterData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#注释","level":3,"title":"注释","text":"<ul> <li>参数信息解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public ParameterData(ParameterInfo parameterInfo)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public string GetFormattedString()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public string GetFormattedString</code> 生成格式化的参数字符串","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public ParameterDirection Direction { get; }</code> 参数方向（in/out/ref） <code>public Type ParameterType { get; }</code> 参数类型 <code>public bool HasDefaultValue { get; }</code> 是否有默认值 <code>public bool IsParams { get; }</code> 是否为 params 参数 <code>public object DefaultValue { get; }</code> 默认值 <code>public string Name { get; }</code> 参数名称","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/ParameterData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","ParameterData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/","level":1,"title":"<code>PropertyData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class PropertyData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IPropertyData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#注释","level":3,"title":"注释","text":"<ul> <li>解析成员数据的基类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public PropertyData(PropertyInfo propertyInfo, IAttributeFilter filter = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 访问修饰符 <code>public MemberTypes MemberType { get; }</code> 成员类型 <code>public Type PropertyType { get; }</code> 属性类型 <code>public bool IsStatic { get; }</code> 是否为静态属性 <code>public object DefaultValue { get; }</code> 属性类型 <code>public string AccessModifierName { get; }</code> 访问修饰符名称 <code>public string FullDeclarationWithAttributes { get; }</code> 完整属性声明 - 包含特性和签名 - 默认剔除 [Summary] 特性 <code>public string MemberTypeName { get; }</code> <code>public string PropertyTypeFullName { get; }</code> 属性类型的完整名称 <code>public string PropertyTypeName { get; }</code> 属性类型名称 <code>public string Signature { get; private set; }</code> 属性签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/PropertyData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","PropertyData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/","level":1,"title":"<code>TypeAnalyzerStaticExtensions</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>static class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Extension]\npublic static class TypeAnalyzerStaticExtensions\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#注释","level":3,"title":"注释","text":"<ul> <li>类型分析器静态扩展类，统一管理类型分析器有关的静态扩展方法</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>[Ext] public static AccessModifierType GetEventAccessModifierType(this EventInfo eventInfo)</code> <code>[Ext] public static AccessModifierType GetFieldAccessModifier(this FieldInfo fieldInfo)</code> <code>[Ext] public static AccessModifierType GetMethodAccessModifierType(this MethodBase method)</code> <code>[Ext] public static AccessModifierType GetPropertyAccessModifierType(this PropertyInfo propertyInfo)</code> <code>[Ext] public static AccessModifierType GetTypeAccessModifier(this Type type)</code> <code>[Ext] public static FieldInfo[] GetUserDefinedFields(this Type type)</code> <code>[Ext] public static TypeCategory GetTypeCategory(this Type type)</code> <code>[Ext] public static bool IsAbstractOrInterface(this Type type)</code> <code>[Ext] public static bool IsApiMember(this IDerivedMemberData derivedMemberData)</code> <code>[Ext] public static bool IsAsyncMethod(this MethodBase methodBase)</code> <code>[Ext] public static bool IsDelegate(this Type type)</code> <code>[Ext] public static bool IsDynamicField(this FieldInfo fieldInfo)</code> <code>[Ext] public static bool IsFromInheritance(this MemberInfo member)</code> <code>[Ext] public static bool IsFromInterfaceImplementMethod(this MethodBase method)</code> <code>[Ext] public static bool IsInheritedOverrideFromAncestor(this MethodInfo method, Type currentType)</code> <code>[Ext] public static bool IsOperatorMethod(this MethodBase methodInfo)</code> <code>[Ext] public static bool IsOverrideMethod(this MethodInfo methodInfo)</code> <code>[Ext] public static bool IsRecord(this Type type)</code> <code>[Ext] public static bool IsRecordStruct(this Type type)</code> <code>[Ext] public static bool IsReferenceTypeExcludeString(this Type type)</code> <code>[Ext] public static bool IsStaticProperty(this PropertyInfo propertyInfo)</code> <code>[Ext] public static bool TryAsIMemberData(this IDerivedMemberData derivedMemberData, out ref IMemberData memberData)</code> <code>[Ext] public static bool TryGetFieldCustomDefaultValue(this FieldInfo fieldInfo, out ref Object defaultValue)</code> <code>[Ext] public static bool TryGetPropertyCustomDefaultValue(this PropertyInfo propertyInfo, out ref Object defaultValue)</code> <code>[Ext] public static string GetAttributesDeclarationWithMultiLine(this MemberInfo member, IAttributeFilter filter = null)</code> <code>[Ext] public static string GetMethodNameAndParameters(this MethodBase method)</code> <code>[Ext] public static string GetParametersNameWithDefaultValue(this MethodBase method)</code> <code>[Ext] public static string GetReadableTypeName(this Type type, bool useFullName = false)</code> <code>[Ext] public static string GetTypeDeclaration(this Type type)</code> <code>[Ext] public static string[] GetInheritanceChain(this Type type)</code> <code>[Ext] public static string[] GetInterfaceArray(this Type type)</code> <code>[Ext] public static string[] GetReferenceLinks(this Type type)</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>[Ext] public static AccessModifierType GetEventAccessModifierType</code> 获取事件的访问修饰符类型 <code>[Ext] public static AccessModifierType GetFieldAccessModifier</code> 获取字段访问修饰符 <code>[Ext] public static AccessModifierType GetMethodAccessModifierType</code> 获取方法的访问修饰符类型 <code>[Ext] public static AccessModifierType GetPropertyAccessModifierType</code> 获取属性的访问修饰符类型 <code>[Ext] public static AccessModifierType GetTypeAccessModifier</code> 获取类型的访问修饰符 <code>[Ext] public static FieldInfo[] GetUserDefinedFields</code> 获取开发者声明的字段，剔除自动属性生成的字段 <code>[Ext] public static TypeCategory GetTypeCategory</code> 获取类型的种类 <code>[Ext] public static bool IsAbstractOrInterface</code> 判断一个类型是否为抽象类或接口 <code>[Ext] public static bool IsApiMember</code> 判断是否为 API 成员，返回 true 表示是 API 成员，返回 false 表示不是。API 成员指的是公共成员或受保护成员。 <code>[Ext] public static bool IsAsyncMethod</code> 判断方法是否是异步方法 <code>[Ext] public static bool IsDelegate</code> 判断指定类型是否为委托类型 <code>[Ext] public static bool IsDynamicField</code> 判断是否为动态字段 <code>[Ext] public static bool IsFromInheritance</code> 判断成员是否从继承中获取，这里的成员不包括 Type 类型 <code>[Ext] public static bool IsFromInterfaceImplementMethod</code> 判断是否为接口的实现方法 <code>[Ext] public static bool IsInheritedOverrideFromAncestor</code> 判断方法是否为从祖先类继承的重写方法，重写声明不是在当前类中 <code>[Ext] public static bool IsOperatorMethod</code> 判断方法是否是运算符方法 <code>[Ext] public static bool IsOverrideMethod</code> 方法是否具有 override 的特性 <code>[Ext] public static bool IsRecord</code> 判断指定类型是否为 record（包括 record class 和 record struct） <code>[Ext] public static bool IsRecordStruct</code> 判断类型是否为 record struct（值类型 record） <code>[Ext] public static bool IsReferenceTypeExcludeString</code> 判断一个类型是否为非字符串的引用类型（非值类型） <code>[Ext] public static bool IsStaticProperty</code> 判断是否为静态属性 <code>[Ext] public static bool TryAsIMemberData</code> 将 IDerivedMemberData 转换为 IMemberData，转换成功返回 true，转换失败返回 false <code>[Ext] public static bool TryGetFieldCustomDefaultValue</code> 获取字段的自定义默认值，不能获取到值则返回 null。只获取静态字段和常量字段的默认值。 <code>[Ext] public static bool TryGetPropertyCustomDefaultValue</code> 获取属性的自定义默认值，不能获取到值则返回 null，只获取静态属性的默认值。 <code>[Ext] public static string GetAttributesDeclarationWithMultiLine</code> 获取特性声明字符串，多行显示 <code>[Ext] public static string GetMethodNameAndParameters</code> 获取方法名称和参数列表，不包含返回值和修饰符 <code>[Ext] public static string GetParametersNameWithDefaultValue</code> 获取方法的参数签名，包含默认值 <code>[Ext] public static string GetReadableTypeName</code> 将反射获取到的系统类型名称转换为人类可读的 C# 风格类型名称 <code>[Ext] public static string GetTypeDeclaration</code> 获取类型声明字符串 <code>[Ext] public static string[] GetInheritanceChain</code> 获取一个类型的继承链，不包括接口 <code>[Ext] public static string[] GetInterfaceArray</code> 获取一个类型继承的所有接口 <code>[Ext] public static string[] GetReferenceLinks</code> 获取一个数组，内容是所有的 ReferenceLinkURL 特性中的网页链接字符串","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerStaticExtensions/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerStaticExtensions"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/","level":1,"title":"<code>TypeAnalyzerUtility</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>static class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public static class TypeAnalyzerUtility\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#注释","level":3,"title":"注释","text":"<ul> <li>类型分析器工具类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>public static bool TreatedAsTypeDefaultValue(object value, Type type)</code> <code>public static bool TryGetFormatedAttributeWithFullParameter(object attrInstance, out ref string attributeFullSignature)</code> <code>public static string GetAttributeNameWithoutSuffix(string attributeName)</code> <code>public static string GetFieldKeywordSnippet(bool isConst, bool isStatic, bool isReadOnly)</code> <code>public static string GetFormattedDefaultValue(Type memberType, object value)</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public static bool TreatedAsTypeDefaultValue</code> 提供的值被视为类型的默认值，返回 true 表示被视为类型的默认值，返回 false 表示不是。 <code>public static bool TryGetFormatedAttributeWithFullParameter</code> 获取格式化的完整特性签名字符串，返回 true 表示该特性支持格式化为完整特性签名字符串，返回 false 表示不支持。 <code>public static string GetAttributeNameWithoutSuffix</code> 获取没有后缀的 Attribute 名称 <code>public static string GetFieldKeywordSnippet</code> 获取字段的关键字片段字符串 <code>public static string GetFormattedDefaultValue</code> 获取格式化的默认值字符串，用于生成签名","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#字段","level":2,"title":"字段","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#声明的普通字段","level":3,"title":"声明的普通字段","text":"字段名称 注释 <code>public static readonly IReadOnlyDictionary&lt;Type, string&gt; TypeAliasMap;</code> 将系统类型名称映射到其 C# 别名的字典","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeAnalyzerUtility/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeAnalyzerUtility"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/","level":1,"title":"<code>TypeCategory</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>enum</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>public enum TypeCategory : System.Enum, \nSystem.IFormattable, \nSystem.IComparable, \nSystem.IConvertible\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public bool HasFlag(Enum flag)</code> <code>public override bool Equals(object obj)</code> <code>public override int GetHashCode()</code> <code>public override string ToString()</code> <code>public string ToString(string format)</code> <code>public virtual TypeCode GetTypeCode()</code> <code>public virtual int CompareTo(object target)</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code> <code>[Overload] [Overload] public virtual string ToString(IFormatProvider provider)</code> <code>[Overload] [Overload] public virtual string ToString(string format, IFormatProvider provider)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public bool HasFlag</code> <code>System.Enum</code> <code>public override bool Equals</code> <code>System.Enum</code> <code>public override int GetHashCode</code> <code>System.Enum</code> <code>public override string ToString</code> <code>System.Enum</code> <code>public string ToString</code> <code>System.Enum</code> <code>public virtual TypeCode GetTypeCode</code> <code>System.Enum</code> <code>public virtual int CompareTo</code> <code>System.Enum</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Enum</code> <code>public virtual string ToString</code> <code>System.Enum</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#字段","level":2,"title":"字段","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#常量字段","level":3,"title":"常量字段","text":"字段完整签名 注释 <code>public const TypeCategory Class;</code> <code>public const TypeCategory Delegate;</code> <code>public const TypeCategory Enum;</code> <code>public const TypeCategory Interface;</code> <code>public const TypeCategory Record;</code> <code>public const TypeCategory Struct;</code> <code>public const TypeCategory Unknown;</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeCategory/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeCategory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/","level":1,"title":"<code>TypeData</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class TypeData : Yuumix.OdinToolkits.ScriptDocGenerator.MemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.ITypeData, \nYuumix.OdinToolkits.ScriptDocGenerator.IDerivedMemberData, \nYuumix.OdinToolkits.ScriptDocGenerator.IMemberData\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#注释","level":3,"title":"注释","text":"<ul> <li>类型解析数据类，存储类型的各种成员的解析数据</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public TypeData(Type type, IAttributeFilter filter = null, IAnalysisDataFactory factory = null)</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#声明的属性","level":3,"title":"声明的属性","text":"属性签名 注释 <code>public AccessModifierType AccessModifier { get; }</code> 访问修饰符 <code>public Assembly Assembly { get; }</code> 类型所在的程序集 <code>public IAnalysisDataFactory DataFactory { get; }</code> 分析数据工厂实例对象 <code>public IConstructorData[] RuntimeReflectedConstructorsData { get; }</code> 声明的构造方法解析数据数组，只包含公共构造函数，GetConstructors() 方法 <code>public IEventData[] RuntimeReflectedEventsData { get; }</code> 声明的事件解析数据数组，GetRuntimeEvents() 方法 <code>public IFieldData[] RuntimeReflectedFieldsData { get; }</code> 类型的字段解析数据数组，GetUserDefinedFields() 方法 <code>public IMethodData[] RuntimeReflectedMethodsData { get; }</code> 声明的方法解析数据数组，GetRuntimeMethods() 方法 <code>public IPropertyData[] RuntimeReflectedPropertiesData { get; }</code> 声明的属性解析数据数组，GetRuntimeProperties() 方法 <code>public MemberTypes MemberType { get; }</code> 成员类型 <code>public TypeCategory TypeCategory { get; }</code> Type 种类 <code>public bool IsAbstract { get; }</code> 是否为抽象类 <code>public bool IsGenericType { get; }</code> 是否为泛型类型 <code>public bool IsSealed { get; }</code> 是否为密封类 <code>public bool IsStatic { get; }</code> 是否为静态类型 <code>public string AccessModifierName { get; }</code> 访问修饰符名称 <code>public string AssemblyName { get; }</code> 程序集名称 <code>public string FullDeclarationWithAttributes { get; }</code> 完整类型声明 - 包含特性和签名 - 默认剔除 [Summary] 特性 <code>public string MemberTypeName { get; }</code> 成员类型名称 <code>public string NamespaceName { get; }</code> 命名空间名称 <code>public string Signature { get; }</code> 类型签名，不包含特性声明 <code>public string[] InheritanceChain { get; }</code> 继承链数组 <code>public string[] InterfaceArray { get; }</code> 接口列表数组 <code>public string[] ReferenceWebLinkArray { get; }</code> 引用链接数组","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public Type DeclaringType { get; }</code> 声明此成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public Type ReflectedType { get; }</code> 通过反射获取该成员的类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsFromInheritance { get; }</code> 成员是否从继承中获取，这里的成员不包括 Type 类型 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public bool IsObsolete { get; }</code> 是否已过时 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string AttributesDeclaration { get; }</code> 特性声明字符串 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeFullName { get; }</code> 声明类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string DeclaringTypeName { get; }</code> 声明类型的名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string Name { get; }</code> 成员名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeFullName { get; }</code> 通过反射获取该成员的类型的完整名称，包括命名空间 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string ReflectedTypeName { get; }</code> 通过反射获取该成员的类型名称 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code> <code>public string SummaryAttributeValue { get; }</code> 注释 <code>Yuumix.OdinToolkits.ScriptDocGenerator.MemberData</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/TypeData/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","TypeData"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/","level":1,"title":"<code>YuumixDefaultAnalysisDataFactory</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Runtime</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator</code></li> </ul> <pre><code>[Serializable]\npublic class YuumixDefaultAnalysisDataFactory : Yuumix.OdinToolkits.ScriptDocGenerator.IAnalysisDataFactory\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#注释","level":3,"title":"注释","text":"<ul> <li>Yuumix 默认提供的解析数据工厂实现类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public YuumixDefaultAnalysisDataFactory()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public IConstructorData CreateConstructorData(ConstructorInfo constructorInfo, IAttributeFilter filter = null)</code> <code>public IEventData CreateEventData(EventInfo eventInfo, IAttributeFilter filter = null)</code> <code>public IFieldData CreateFieldData(FieldInfo fieldInfo, IAttributeFilter filter = null)</code> <code>public IMethodData CreateMethodData(MethodInfo methodInfo, IAttributeFilter filter = null)</code> <code>public IPropertyData CreatePropertyData(PropertyInfo propertyInfo, IAttributeFilter filter = null)</code> <code>public ITypeData CreateTypeData(Type type, IAnalysisDataFactory factory = null, IAttributeFilter filter = null)</code> <code>public Type GetType()</code> <code>public virtual bool Equals(object obj)</code> <code>public virtual int GetHashCode()</code> <code>public virtual string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public IConstructorData CreateConstructorData</code> 创建构造函数数据 <code>public IEventData CreateEventData</code> 创建事件数据 <code>public IFieldData CreateFieldData</code> 创建字段数据 <code>public IMethodData CreateMethodData</code> 创建方法数据 <code>public IPropertyData CreatePropertyData</code> 创建属性数据 <code>public ITypeData CreateTypeData</code> 创建类型数据","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public virtual bool Equals</code> <code>System.Object</code> <code>public virtual int GetHashCode</code> <code>System.Object</code> <code>public virtual string ToString</code> <code>System.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/YuumixDefaultAnalysisDataFactory/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","YuumixDefaultAnalysisDataFactory"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/","level":1,"title":"<code>DocGeneratorSettingSO</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>abstract class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Editor</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator.Editor</code></li> </ul> <pre><code>public abstract class DocGeneratorSettingSO : UnityEngine.ScriptableObject, \nYuumix.OdinToolkits.Core.IOdinToolkitsEditorReset\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#注释","level":3,"title":"注释","text":"<ul> <li>文档生成器设置抽象类</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public abstract string GetGeneratedDoc(ITypeData data)</code> <code>public int GetInstanceID()</code> <code>public override bool Equals(object other)</code> <code>public override int GetHashCode()</code> <code>public override string ToString()</code> <code>public void EditorReset()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code> <code>public void SetDirty()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#声明的普通方法","level":3,"title":"声明的普通方法","text":"普通方法名称 注释 <code>public abstract string GetGeneratedDoc</code> 通过 TypeData 实例对象，生成文档内容。注意：不要在此方法中添加增量生成标识符 <code>public void EditorReset</code> 重置文档生成器设置","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public int GetInstanceID</code> <code>UnityEngine.Object</code> <code>public override bool Equals</code> <code>UnityEngine.Object</code> <code>public override int GetHashCode</code> <code>UnityEngine.Object</code> <code>public override string ToString</code> <code>UnityEngine.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code> <code>public void SetDirty</code> <code>UnityEngine.ScriptableObject</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public HideFlags hideFlags { get; set; }</code> <code>UnityEngine.Object</code> <code>public string name { get; set; }</code> <code>UnityEngine.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#字段","level":2,"title":"字段","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#声明的普通字段","level":3,"title":"声明的普通字段","text":"字段名称 注释 <code>public bool customizeDocFileExtensionName;</code> 是否自定义文档扩展名 <code>public bool generateIdentifier;</code> 是否自动生成增量标识符 <code>public bool generateNamespaceFolder;</code> 是否按命名空间生成文件夹 <code>public string docFileExtensionName;</code> 设置的文档扩展名","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/DocGeneratorSettingSO/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","DocGeneratorSettingSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/","level":1,"title":"<code>TypesCacheSO</code>","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#介绍","level":2,"title":"介绍","text":"<ul> <li>种类: <code>class</code></li> <li>所在程序集: <code>Yuumix.OdinToolkits.Editor</code></li> <li>所在命名空间: <code>Yuumix.OdinToolkits.ScriptDocGenerator.Editor</code></li> </ul> <pre><code>public class TypesCacheSO : Sirenix.OdinInspector.SerializedScriptableObject, \nUnityEngine.ISerializationCallbackReceiver\n</code></pre>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#注释","level":3,"title":"注释","text":"<ul> <li>存储 Type 的资源文件，提供给脚本文档生成工具复用，用户无需每次重新选择 Type</li> </ul>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#构造方法","level":2,"title":"构造方法","text":"构造方法签名 [仅包含公共实例方法] 注释 <code>public TypesCacheSO()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#方法","level":2,"title":"方法","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#所有方法签名总览","level":3,"title":"所有方法签名总览","text":"方法完整签名 <code>public Type GetType()</code> <code>public int GetInstanceID()</code> <code>public override bool Equals(object other)</code> <code>public override int GetHashCode()</code> <code>public override string ToString()</code> <code>protected object MemberwiseClone()</code> <code>protected virtual void Finalize()</code> <code>protected virtual void OnAfterDeserialize()</code> <code>protected virtual void OnBeforeSerialize()</code> <code>public void SetDirty()</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#继承的普通方法","level":3,"title":"继承的普通方法","text":"普通方法名称 注释 声明方法的类 <code>public Type GetType</code> <code>System.Object</code> <code>public int GetInstanceID</code> <code>UnityEngine.Object</code> <code>public override bool Equals</code> <code>UnityEngine.Object</code> <code>public override int GetHashCode</code> <code>UnityEngine.Object</code> <code>public override string ToString</code> <code>UnityEngine.Object</code> <code>protected object MemberwiseClone</code> <code>System.Object</code> <code>protected virtual void Finalize</code> <code>System.Object</code> <code>protected virtual void OnAfterDeserialize</code> <code>Sirenix.OdinInspector.SerializedScriptableObject</code> <code>protected virtual void OnBeforeSerialize</code> <code>Sirenix.OdinInspector.SerializedScriptableObject</code> <code>public void SetDirty</code> <code>UnityEngine.ScriptableObject</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#属性","level":2,"title":"属性","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#继承的属性","level":3,"title":"继承的属性","text":"属性签名 注释 声明属性的类 <code>public HideFlags hideFlags { get; set; }</code> <code>UnityEngine.Object</code> <code>public string name { get; set; }</code> <code>UnityEngine.Object</code>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#字段","level":2,"title":"字段","text":"","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#声明的普通字段","level":3,"title":"声明的普通字段","text":"字段名称 注释 <code>public List&lt;Type&gt; Types;</code> 存储 Type 的列表","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]},{"location":"ScriptingAPI/OdinToolkits/ScriptDocGenerator/Editor/TypesCacheSO/#额外说明","level":2,"title":"额外说明","text":"<p>首个 <code>## 额外说明</code> 是增量生成文档标识符，请勿修改标题级别和内容！本文档由 <code>Odin Toolkits For Unity</code> 辅助生成。</p>","path":["Scripting API","Odin Toolkits","Script Doc Generator","Editor","TypesCacheSO"],"tags":[]}]}